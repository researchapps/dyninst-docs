<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>InstructionAPI Class Reference &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>InstructionAPI Class Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/instructionAPI/3-API.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="instructionapi-class-reference">
<h1>InstructionAPI Class Reference<a class="headerlink" href="#instructionapi-class-reference" title="Permalink to this headline"></a></h1>
<div class="section" id="instruction-class">
<span id="sec-instruction"></span><h2>Instruction Class<a class="headerlink" href="#instruction-class" title="Permalink to this headline"></a></h2>
<p>The Instruction class is a generic instruction representation that
contains operands, read/write semantic information about those operands,
and information about what other registers and memory locations are
affected by the operation the instruction performs.</p>
<p>The purpose of an Instruction object is to join an Operation with a
sequence of Operands, and provide an interface for some common summary
analyses (namely, the read/write sets, memory access information, and
control flow information).</p>
<p>The Operation contains knowledge about its mnemonic and sufficient
semantic details to answer the following questions:</p>
<ul class="simple">
<li>What Operands are read/written?</li>
<li>What registers are implicitly read/written?</li>
<li>What memory locations are implicitly read/written?</li>
<li>What are the possible control flow successors of this instruction?</li>
</ul>
<p>Each Operand is an AST built from RegisterAST and Immediate leaves. For
each Operand, you may determine:</p>
<ul class="simple">
<li>Registers read</li>
<li>Registers written</li>
<li>Whether memory is read or written</li>
<li>Which memory addresses are read or written, given the state of all
relevant registers</li>
</ul>
<p>Instructions should be constructed from an pointing to machine language,
using the InstructionDecoder class. See InstructionDecoder for more
details.</p>
<div class="apient container">
Instruction (Operation::Ptr what, size_t size, const unsigned char *
raw, Dyninst::Architecture arch)</div>
<div class="apient container">
const Operation &amp; getOperation() const</div>
<div class="apient container">
void getOperands(std::vector&lt;Operand&gt; &amp; operands) const</div>
<div class="apient container">
Operand getOperand(int index) const</div>
<div class="apient container">
unsigned char rawByte(unsigned int index) const</div>
<div class="apient container">
size_t size() const</div>
<div class="apient container">
const void * ptr() const</div>
<div class="apient container">
void getWriteSet(std::set&lt;RegisterAST::Ptr&gt; &amp; regsWritten) const</div>
<div class="apient container">
void getReadSet(std::set&lt;RegisterAST::Ptr&gt; &amp; regsRead) const</div>
<div class="apient container">
bool isRead(Expression::Ptr candidate) const</div>
<div class="apient container">
bool isWritten(Expression::Ptr candidate) const</div>
<div class="apient container">
bool readsMemory() const</div>
<div class="apient container">
bool writesMemory() const</div>
<div class="apient container">
void getMemoryReadOperands(std::set&lt;Expression::Ptr&gt; &amp; memAccessors)
const</div>
<div class="apient container">
void getMemoryWriteOperands(std::set&lt;Expression::Ptr&gt; &amp; memAccessors)
const</div>
<div class="apient container">
Expression::Ptr getControlFlowTarget() const</div>
<div class="apient container">
bool allowsFallThrough() const</div>
<div class="apient container">
std::string format(Address addr = 0)</div>
<div class="apient container">
bool isValid() const</div>
<div class="apient container">
bool isLegalInsn() const</div>
<div class="apient container">
Architecture getArch() const</div>
<div class="apient container">
InsnCategory getCategory() const</div>
<div class="apient container">
<p>struct CFT Expression::Ptr target; bool isCall; bool isIndirect; bool
isConditional; bool isFallthrough;</p>
<p>typedef … cftConstIter; cftConstIter cft_begin() const;
cftConstIter cft_end() const;</p>
</div>
</div>
<div class="section" id="operation-class">
<span id="sec-operation"></span><h2>Operation Class<a class="headerlink" href="#operation-class" title="Permalink to this headline"></a></h2>
<p>An Operation object represents a family of opcodes (operation encodings)
that perform the same task (e.g. the family). It includes information
about the number of operands, their read/write semantics, the implicit
register reads and writes, and the control flow behavior of a particular
assembly language operation. It additionally provides access to the
assembly mnemonic, which allows any semantic details that are not
encoded in the Instruction representation to be added by higher layers
of analysis.</p>
<p>As an example, the operation on IA32/AMD64 processors has the following
properties:</p>
<ul class="simple">
<li>Operand 1 is read, but not written</li>
<li>Operand 2 is read, but not written</li>
<li>The following flags are written:<ul>
<li>Overflow</li>
<li>Sign</li>
<li>Zero</li>
<li>Parity</li>
<li>Carry</li>
<li>Auxiliary</li>
</ul>
</li>
<li>No other registers are read, and no implicit memory operations are
performed</li>
</ul>
<p>Operations are constructed by the as part of the process of constructing
an Instruction.</p>
<div class="apient container">
const Operation::registerSet &amp; implicitReads () const</div>
<div class="apient container">
const Operation::registerSet &amp; implicitWrites () const</div>
<div class="apient container">
std::string format() const</div>
<div class="apient container">
entryID getID() const</div>
<div class="apient container">
prefixEntryID getPrefixID() const</div>
<div class="apient container">
bool isRead(Expression::Ptr candidate) const</div>
<div class="apient container">
bool isWritten(Expression::Ptr candidate) const</div>
<div class="apient container">
const Operation::VCSet &amp; getImplicitMemReads() const</div>
<div class="apient container">
const Operation::VCSet &amp; getImplicitMemWrites() const</div>
</div>
<div class="section" id="operand-class">
<span id="sec-operand"></span><h2>Operand Class<a class="headerlink" href="#operand-class" title="Permalink to this headline"></a></h2>
<p>An Operand object contains an AST built from RegisterAST and Immediate
leaves, and information about whether the Operand is read, written, or
both. This allows us to determine which of the registers that appear in
the Operand are read and which are written, as well as whether any
memory accesses are reads, writes, or both. An Operand, given full
knowledge of the values of the leaves of the AST, and knowledge of the
logic associated with the tree’s internal nodes, can determine the
result of any computations that are encoded in it. It will rarely be the
case that an Instruction is built with its Operands’ state fully
specified. This mechanism is instead intended to allow a user to fill in
knowledge about the state of the processor at the time the Instruction
is executed.</p>
<div class="apient container">
Operand(Expression::Ptr val, bool read, bool written)</div>
<div class="apient container">
void getReadSet(std::set&lt;RegisterAST::Ptr&gt; &amp; regsRead) const</div>
<div class="apient container">
void getWriteSet(std::set&lt;RegisterAST::Ptr&gt; &amp; regsWritten) const</div>
<div class="apient container">
bool isRead() const</div>
<div class="apient container">
bool isWritten() const</div>
<div class="apient container">
bool isRead(Expression::Ptr candidate) const</div>
<div class="apient container">
bool isWritten(Expression::Ptr candidate) const</div>
<div class="apient container">
bool readsMemory() const</div>
<div class="apient container">
bool writesMemory() const</div>
<div class="apient container">
void addEffectiveReadAddresses(std::set&lt;Expression::Ptr&gt; &amp;
memAccessors) const</div>
<div class="apient container">
void addEffectiveWriteAddresses(std::set&lt;Expression::Ptr&gt; &amp;
memAccessors) const</div>
<div class="apient container">
std::string format(Architecture arch, Address addr = 0) const</div>
<div class="apient container">
Expression::Ptr getValue() const</div>
</div>
<div class="section" id="instructionast-class">
<span id="sec-instructionast"></span><h2>InstructionAST Class<a class="headerlink" href="#instructionast-class" title="Permalink to this headline"></a></h2>
<p>The InstructionAST class is the base class for all nodes in the ASTs
used by the Operand class. It defines the necessary interfaces for
traversing and searching an abstract syntax tree representing an
operand. For the purposes of searching an InstructionAST, we provide two
related interfaces. The first, , will return the registers that appear
in a given tree. The second, , will take as input another tree and
return true if that tree is a (not necessarily proper) subtree of this
one. requires us to define an equality relation on these abstract syntax
trees, and the equality operator is provided by the InstructionAST, with
the details implemented by the classes derived from InstructionAST. Two
AST nodes are equal if the following conditions hold:</p>
<ul class="simple">
<li>They are of the same type</li>
<li>If leaf nodes, they represent the same immediate value or the same
register</li>
<li>If non-leaf nodes, they represent the same operation and their
corresponding children are equal</li>
</ul>
<div class="apient container">
typedef boost::shared_ptr&lt;InstructionAST&gt; Ptr</div>
<div class="apient container">
bool operator==(const InstructionAST &amp;rhs) const</div>
<div class="apient container">
virtual void getChildren(vector&lt;InstructionAPI::Ptr&gt; &amp; children)
const</div>
<div class="apient container">
virtual void getUses(set&lt;InstructionAPI::Ptr&gt; &amp; uses)</div>
<div class="apient container">
virtual bool isUsed(InstructionAPI::Ptr findMe) const</div>
<div class="apient container">
virtual std::string format(formatStyle how == defaultStyle) const</div>
</div>
<div class="section" id="expression-class">
<span id="sec-expression"></span><h2>Expression Class<a class="headerlink" href="#expression-class" title="Permalink to this headline"></a></h2>
<p>An is an AST representation of how the value of an operand is computed.</p>
<p>The class extends the class by adding the concept of evaluation to the
nodes of an . Evaluation attempts to determine the of the computation
that the AST being evaluated represents. It will fill in results of as
many of the nodes in the tree as possible, and if full evaluation is
possible, it will return the result of the computation performed by the
tree.</p>
<p>Permissible leaf nodes of an tree are RegisterAST and Immediate objects.
Permissible internal nodes are and Dereference objects. An may represent
an immediate value, the contents of a register, or the contents of
memory at a given address, interpreted as a particular type.</p>
<p>The s in an tree contain a type and a value. Their values may be an
undefined value or an instance of their associated type. When two s are
combined using a , the specifies the output type. Sign extension, type
promotion, truncation, and all other necessary conversions are handled
automatically based on the input types and the output type. If both of
the s that are combined have defined values, the combination will also
have a defined value; otherwise, the combination’s value will be
undefined. For more information, see Section&nbsp;<a class="reference external" href="#sec:result">1.7</a>,
Section&nbsp;<a class="reference external" href="#sec:binaryFunction">1.10</a>, and
Section&nbsp;<a class="reference external" href="#sec:dereference">1.11</a>.</p>
<p>A user may specify the result of evaluating a given . This mechanism is
designed to allow the user to provide a Dereference or RegisterAST with
information about the state of memory or registers. It may additionally
be used to change the value of an Immediate or to specify the result of
a . This mechanism may be used to support other advanced analyses.</p>
<p>In order to make it more convenient to specify the results of particular
subexpressions, the method is provided. allows the user to specify that
a given subexpression has a particular value everywhere that it appears
in an expression. For example, if the state of certain registers is
known at the time an instruction is executed, a user can those registers
to their known values throughout an .</p>
<p>The evaluation mechanism, as mentioned above, will evaluate as many
sub-expressions of an expression as possible. Any operand that is more
complicated than a single immediate value, however, will depend on
register or memory values. The s of evaluating each subexpression are
cached automatically using the mechanism. The then attempts to determine
its based on the s of its children. If this can be determined (most
likely because register contents have been filled in via or ), it will
be returned from ; if it can not be determined, a with an undefined
value will be returned. See Figure 6 for an illustration of this
concept; the operand represented is . The contents of and have been
determined through some outside mechanism, and have been defined with .
The mechanism proceeds to determine the address being read by the ,
since this information can be determined given the contents of the
registers. This address is available from the Dereference through its
child in the tree, even though calling on the Dereference returns a with
an undefined value.</p>
<div class="apient container">
typedef boost::shared_ptr&lt;Expression&gt; Ptr</div>
<div class="apient container">
const Result &amp; eval() const</div>
<div class="apient container">
const setValue(const Result &amp; knownValue)</div>
<div class="apient container">
void clearValue()</div>
<div class="apient container">
int size() const</div>
<div class="apient container">
bool bind(Expression * expr, const Result &amp; value)</div>
<div class="apient container">
virtual void apply(Visitor *)</div>
<div class="apient container">
virtual void getChildren(std::vector&lt;Expression::Ptr&gt; &amp; children)
const</div>
</div>
<div class="section" id="visitor-paradigm">
<span id="sec-visitor"></span><h2>Visitor Paradigm<a class="headerlink" href="#visitor-paradigm" title="Permalink to this headline"></a></h2>
<p>An alternative to the bind/eval mechanism is to use a <em>visitor</em>  <a class="footnote-reference" href="#id2" id="id1">[1]</a>
over an expression tree. The visitor concept applies a user-specified
visitor class to all nodes in an expression tree (in a post-order
traversal). The visitor paradigm can be used as a more efficient
replacement for bind/eval, to identify whether an expression has a
desired pattern, or to locate children of an expression tree.</p>
<p>A visitor is a user-defined class that inherits from the class defined
in . That class is repeated here for reference:</p>
<div class="apient container">
class Visitor public: Visitor() virtual &nbsp;Visitor() virtual void
visit(BinaryFunction* b) = 0; virtual void visit(Immediate* i) = 0;
virtual void visit(RegisterAST* r) = 0; virtual void
visit(Dereference* d) = 0;;</div>
<p>A user provides implementations of the four methods. When applied to an
(via the method) the InstructionAPI will perform a post-order traversal
of the tree, calling the appropriate method at each node.</p>
<p>As a simple example, the following code prints out the name of each
register used in an :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Instruction.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Operand.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Expression.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Register.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Visitor.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">InstructionAPI</span><span class="p">;</span><span class="w"></span>

<span class="n">class</span><span class="w"> </span><span class="n">PrintVisitor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Visitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">PrintVisitor</span><span class="p">()</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="o">~</span><span class="n">PrintVisitor</span><span class="p">()</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">BinaryFunction</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">Immediate</span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">RegisterAST</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Visiting register &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">().</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">Dereference</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">printRegisters</span><span class="p">(</span><span class="n">Instruction</span><span class="o">::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">insn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">PrintVisitor</span><span class="w"> </span><span class="n">pv</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Operand</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">getOperands</span><span class="p">(</span><span class="n">operands</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="c1">// c++11x allows auto to determine the type of a variable;</span>
<span class="w">   </span><span class="c1">// if not using c++11x, use &#39;std::vector&lt;Operand&gt;::iterator&#39; instead.</span>
<span class="w">   </span><span class="c1">// For gcc, use the -std=c++0x argument.</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">operands</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">operands</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Registers used for operand&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">).</span><span class="n">getValue</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pv</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Visitors may also set and use internal state. For example, the following
visitor (presented without surrounding use code) matches x86 and x86-64
instructions that add 0 to a register (effectively a noop).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">nopVisitor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Visitor</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="n">nopVisitor</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foundReg</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"> </span><span class="n">foundImm</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"> </span><span class="n">foundBin</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"> </span><span class="n">isNop</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">nopVisitor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">foundReg</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">foundImm</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">foundBin</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">isNop</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">BinaryFunction</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">foundBin</span><span class="p">)</span><span class="w"> </span><span class="n">isNop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">foundImm</span><span class="p">)</span><span class="w"> </span><span class="n">isNop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">foundReg</span><span class="p">)</span><span class="w"> </span><span class="n">isNop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">foundBin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">Immediate</span><span class="w"> </span><span class="o">*</span><span class="n">imm</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">imm</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">isNop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">foundImm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">RegisterAST</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">foundReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="n">Dereference</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">isNop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="result-class">
<span id="sec-result"></span><h2>Result Class<a class="headerlink" href="#result-class" title="Permalink to this headline"></a></h2>
<p>A object represents a value computed by an AST.</p>
<p>The class is a tagged-union representation of the results that
Expressions can produce. It includes 8, 16, 32, 48, and 64 bit integers
(signed and unsigned), bit values, and single and double precision
floating point values. For each of these types, the value of a Result
may be undefined, or it may be a value within the range of the type.</p>
<p>The field is an enum that may contain any of the following values:</p>
<ul class="simple">
<li>an unsigned 8-bit integer</li>
<li>a signed 8-bit integer</li>
<li>an unsigned 16-bit integer</li>
<li>a signed 16-bit integer</li>
<li>an unsigned 32-bit integer</li>
<li>a signed 32-bit integer</li>
<li>an unsigned 48-bit integer (IA32 pointers)</li>
<li>a signed 48-bit integer (IA32 pointers)</li>
<li>an unsigned 64-bit integer</li>
<li>a signed 64-bit integer</li>
<li>a single-precision float</li>
<li>a double-precision float</li>
<li>a single bit (individual flags)</li>
<li>a 512-bit memory value</li>
<li>a 128-bit integer, which often contains packed floating point values
- a 14 byte memory value</li>
</ul>
<div class="apient container">
Result (Result_Type t)</div>
<div class="apient container">
Result (Result_Type t, T v)</div>
<div class="apient container">
bool operator== (const Result &amp; o) const</div>
<div class="apient container">
std::string format () const</div>
<div class="apient container">
template &lt;typename to_type&gt; to_type convert() const</div>
<div class="apient container">
int size () const</div>
</div>
<div class="section" id="registerast-class">
<span id="sec-registerast"></span><h2>RegisterAST Class<a class="headerlink" href="#registerast-class" title="Permalink to this headline"></a></h2>
<p>A object represents a register contained in an operand. As a is an , it
may contain the physical register’s contents if they are known.</p>
<div class="apient container">
typedef dyn_detail::boost::shared_ptr&lt;RegisterAST&gt; Ptr</div>
<div class="apient container">
RegisterAST (MachRegister r)</div>
<div class="apient container">
void getChildren (vector&lt; InstructionAST::Ptr &gt; &amp; children) const</div>
<div class="apient container">
void getUses (set&lt; InstructionAST::Ptr &gt; &amp; uses)</div>
<div class="apient container">
bool isUsed (InstructionAST::Ptr findMe) const</div>
<div class="apient container">
std::string format (formatStyle how = defaultStyle) const</div>
<div class="apient container">
RegisterAST makePC (Dyninst::Architecture arch) [static]</div>
<div class="apient container">
bool operator&lt; (const RegisterAST &amp; rhs) const</div>
<div class="apient container">
MachRegister getID () const</div>
<div class="apient container">
RegisterAST::Ptr promote (const InstructionAST::Ptr reg) [static]</div>
</div>
<div class="section" id="immediate-class">
<span id="sec-immediate"></span><h2>Immediate Class<a class="headerlink" href="#immediate-class" title="Permalink to this headline"></a></h2>
<p>The Immediate class represents an immediate value in an operand.</p>
<p>Since an Immediate represents a constant value, the and interface are
disabled on Immediate objects. If an immediate value is being modified,
a new Immediate object should be created to represent the new value.</p>
<div class="apient container">
virtual bool isUsed(InstructionAST::Ptr findMe) const</div>
<div class="apient container">
void getChildren(vector&lt;InstructionAST::Ptr&gt; &amp;) const</div>
<div class="apient container">
void getUses(set&lt;InstructionAST::Ptr&gt; &amp;)</div>
<div class="apient container">
bool isUsed(InstructionAPI::Ptr findMe) const</div>
</div>
<div class="section" id="binaryfunction-class">
<span id="sec-binaryfunction"></span><h2>BinaryFunction Class<a class="headerlink" href="#binaryfunction-class" title="Permalink to this headline"></a></h2>
<p>A object represents a function that can combine two s and produce
another .</p>
<p>For the purposes of representing a single operand of an instruction, the
s of interest are addition and multiplication of integer values; this
allows an to represent all addressing modes on the architectures
currently supported by the Instruction API.</p>
<div class="apient container">
BinaryFunction(Expression::Ptr arg1, Expression::Ptr arg2,
Result_Type result_type, funcT:Ptr func)</div>
<div class="apient container">
const Result &amp; eval () const</div>
<div class="apient container">
void getChildren (vector&lt; InstructionAST::Ptr &gt; &amp; children) const</div>
<div class="apient container">
void getUses (set&lt; InstructionAST::Ptr &gt; &amp; uses)</div>
<div class="apient container">
bool isUsed (InstructionAST::Ptr findMe) const</div>
</div>
<div class="section" id="dereference-class">
<span id="sec-dereference"></span><h2>Dereference Class<a class="headerlink" href="#dereference-class" title="Permalink to this headline"></a></h2>
<p>A object is an that dereferences another .</p>
<p>A contains an representing an effective address computation. Its use set
is the same as the use set of the being dereferenced.</p>
<p>It is not possible, given the information in a single instruction, to
evaluate the result of a dereference. may still be called on an that
includes dereferences, but the expected use case is as follows:</p>
<ul class="simple">
<li>Determine the address being used in a dereference via the mechanism</li>
<li>Perform analysis to determine the contents of that address</li>
<li>If necessary, fill in the node with the contents of that addresss,
using</li>
</ul>
<p>The type associated with a node will be the type of the value <em>read</em>
<em>from</em> <em>memory</em>, not the type used for the address computation. Two s
that access the same address but interpret the contents of that memory
as different types will produce different values. The children of a at a
given address are identical, regardless of the type of dereference being
performed at that address. For example, the shown in Figure 6 could have
its root , which interprets the memory being dereferenced as a unsigned
16-bit integer, replaced with a that interprets the memory being
dereferenced as any other type. The remainder of the tree would,
however, remain unchanged.</p>
<div class="apient container">
Dereference (Expression::Ptr addr, Result_Type result_type)</div>
<div class="apient container">
virtual void getChildren (vector&lt; InstructionAST::Ptr &gt; &amp; children)
const</div>
<div class="apient container">
virtual void getUses (set&lt; InstructionAST::Ptr &gt; &amp; uses)</div>
<div class="apient container">
virtual bool isUsed (InstructionAST::Ptr findMe) const</div>
</div>
<div class="section" id="instructiondecoder-class">
<span id="sec-instructiondecoder"></span><h2>InstructionDecoder Class<a class="headerlink" href="#instructiondecoder-class" title="Permalink to this headline"></a></h2>
<p>The class decodes instructions, given a buffer of bytes and a length,
and constructs an Instruction.</p>
<div class="apient container">
InstructionDecoder(const unsigned char *buffer, size_t size,
Architecture arch) InstructionDecoder(const void *buffer, size_t
size, Architecture arch)</div>
<div class="apient container">
Instruction::Ptr decode();</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>From <em>Elements of Reusable Object-Oriented Software</em> by Gamma, Helm,
Johnson, and Vlissides</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>