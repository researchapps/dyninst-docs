<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="../stackwalk/index.html" />
    <link rel="prev" title="Introduction" href="../parseAPI/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#abstractions">Abstractions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#public-interface">Public Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plugin-interface">Plugin Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#using-the-public-interface">Using the public interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cfg-traversal">CFG Traversal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#point-finding">Point Finding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-patching">Code Patching</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-plugin-interface">Using the plugin interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#address-space">Address Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snippet-representation">Snippet Representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-parsing">Code Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#point-making">Point Making</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instrumentation-engine">Instrumentation Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plugin-registration">Plugin Registration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#public-api-reference">Public API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cfg-interface">CFG Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#patchobject">PatchObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patchfunction">PatchFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patchblock">PatchBlock</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patchedge">PatchEdge</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patchloop">PatchLoop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patchlooptreenode">PatchLoopTreeNode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#point-snippet-interface">Point/Snippet Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#patchmgr">PatchMgr</a></li>
<li class="toctree-l3"><a class="reference internal" href="#point">Point</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instance">Instance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#callback-interface">Callback Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#patchcallback">PatchCallback</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="#plugin-api-reference">Plugin API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#addrspace">AddrSpace</a></li>
<li class="toctree-l2"><a class="reference internal" href="#snippet">Snippet</a></li>
<li class="toctree-l2"><a class="reference internal" href="#command">Command</a></li>
<li class="toctree-l2"><a class="reference internal" href="#batchcommand">BatchCommand</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instrumenter">Instrumenter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#patcher">Patcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cfgmaker">CFGMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pointmaker">PointMaker</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-plugin">Default Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pushfrontcommand-and-pushbackcommand">PushFrontCommand and PushBackCommand</a></li>
<li class="toctree-l2"><a class="reference internal" href="#removesnippetcommand">RemoveSnippetCommand</a></li>
<li class="toctree-l2"><a class="reference internal" href="#removecallcommand">RemoveCallCommand</a></li>
<li class="toctree-l2"><a class="reference internal" href="#replacecallcommand">ReplaceCallCommand</a></li>
<li class="toctree-l2"><a class="reference internal" href="#replacefunccommand">ReplaceFuncCommand</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#differences-between-dyninstapi-and-patchapi">Differences Between DyninstAPI and PatchAPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#patchapi-accessor-methods-in-dyninst">PatchAPI accessor methods in Dyninst</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#building-symtabapi">Building SymtabAPI</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/patchAPI/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="introduction">
<span id="sec-intro"></span><h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h1>
<p>This manual describes PatchAPI, a programming interface and library for
binary code patching. A programmer uses PatchAPI to instrument (insert
code into) and modify a binary executable or library by manipulating the
binary’s control flow graph (CFG). We allow the user to instrument a
binary by annotating a CFG with <em>snippets</em>, or sequences of inserted
code, and to modify the binary by directly manipulating the CFG. The
PatchAPI interface, and thus tools written with PatchAPI, is designed to
be flexible and extensible. First, users may <em>inherit</em> from PatchAPI
abstractions in order to store their own data. Second, users may create
<em>plugins</em> to extend PatchAPI to handle new types of instrumentation,
different binary types, or different patching techniques.</p>
<p>PatchAPI represents the binary as an annotatable and modifiable CFG. The
CFG consists of abstractions for binary objects, functions, basic
blocks, edges connecting basic blocks, and loops representing code that
may execute repeatedly, which are similar to the CFG abstractions used
by the
<a class="reference external" href="ftp://ftp.cs.wisc.edu/paradyn/releases/release7.0/doc/parseapi.pdf">ParseAPI</a>
component.</p>
<p>Users instrument the binary by annotating this CFG using three
additional high-level abstractions: Point, Snippet, and Instance. A
Point supports instrumentation by representing a particular aspect of
program behavior (e.g., entering a function or traversing an edge) and
containing instances of Snippets. Point lookup is performed with a
single PatchAPI manager (PatchMgr) object by Scope (e.g., a CFG object)
and Type (e.g., function entry). In addition, a user may provide an
optional Filter that selects a subset of matching Points. A Snippet
represents a sequence of code to be inserted at certain points. To
maximize flexibility, PatchAPI does not prescribe a particular snippet
form; instead, users may provide their own (e.g., a binary buffer, a
<a class="reference external" href="ftp://ftp.cs.wisc.edu/paradyn/releases/release7.0/doc/dyninstProgGuide.pdf">Dyninst</a>
abstract syntax tree (AST), or code written in the <a class="reference external" href="ftp://ftp.cs.wisc.edu/paradyn/releases/release7.0/doc/dynC_API.pdf">DynC
language</a>).
Users instrument the binary by adding Snippets to the desired Points. An
Instance represents the insertion of a particular Snippet at a
particular Point.</p>
<p>The core PatchAPI representation of an annotatable and modifiable CFG
operates in several domains, including on a running process (dynamic
instrumentation) or a file on disk (binary rewriting). Furthermore,
PatchAPI may be used both in the same address space as the process
(1st-party instrumentation) or in a different address space via the
debug interface (3rd-party instrumentation). Similarly, developers may
define their own types of Snippets to encapsulate their own code
generation techniques. These capabilities are provided by a plugin
interface; by implementing a plugin a developer may extend PatchAPI’s
capabilities.</p>
<p>This manual is structured as follows. Section&nbsp;<a class="reference external" href="#sec-abs">2</a> presents
the core abstractions in the public and plugin interface of PatchAPI.
Section&nbsp;<a class="reference external" href="#sec-example">3</a> shows several examples in C++ to illustrate
the usage of PatchAPI. Detailed API reference can be found in
Section&nbsp;<a class="reference external" href="#sec-public-api">4</a> and Section&nbsp;<a class="reference external" href="#sec-plugin-api">6</a>.
Finally, Appendix&nbsp;<a class="reference external" href="#sec-dyn">7</a> provides a quick tutorial of PatchAPI
to those who are already familiar with DyninstAPI.</p>
</div>
<div class="section" id="abstractions">
<span id="sec-abs"></span><h1>Abstractions<a class="headerlink" href="#abstractions" title="Permalink to this headline"></a></h1>
<div class="figure align-default" id="fig-abs">
<a class="reference internal image-reference" href="patchAPI/figure/abstraction/img.pdf"><img alt="Object Ownership" src="patchAPI/figure/abstraction/img.pdf" style="width: 85.0%;" /></a>
<p class="caption"><span class="caption-text">Object Ownership</span><a class="headerlink" href="#fig-abs" title="Permalink to this image"></a></p>
</div>
<p>PatchAPI contains two interfaces: the public interface and the plugin
interface. The public interface is used to find instrumentation points,
insert or delete code snippets, and register plugins provided by
programmers. The plugin interface is used to customize different aspects
in the binary code patching. PatchAPI provides a set of default plugins
for first party code patching, which is easy to extend to meet different
requirements in practice.</p>
<p>Figure <a class="reference external" href="#fig:abs">1</a> shows the ownership hierarchy for PatchAPI’s
classes. Ownership is a “contains” relationship. If one class owns
another, then instances of the owner class maintain exactly one or
possibly more than one instances of the other, which depends on whether
the relationship is a “1:1” or a “1:n” relationship. In Figure
<a class="reference external" href="#fig:abs">1</a>, for example, each PatchMgr instance contains exactly
one instance of a AddrSpace object, while a PatchMgr instance may
contains more than one instances of a Point object.</p>
<p>The remainder of this section briefly describes the classes that make up
PatchAPI’s two interfaces. For more details, see the class descriptions
in Section&nbsp;<a class="reference external" href="#sec-public-api">4</a> and Section&nbsp;<a class="reference external" href="#sec-plugin-api">6</a>.</p>
<div class="section" id="public-interface">
<span id="sec-2-1"></span><h2>Public Interface<a class="headerlink" href="#public-interface" title="Permalink to this headline"></a></h2>
<p>PatchMgr, Point, and Snippet are used to perform the main process of
binary code patching: 1) find some <strong>Point</strong>; 2) insert or delete
<strong>Snippet</strong> at some <strong>Point</strong>.</p>
<ul class="simple">
<li><em>PatchMgr</em> - The PatchMgr class is the top-level class for finding
instrumentation <strong>Points</strong>, inserting or deleting <strong>Snippets</strong>, and
registering user-provided plugins.</li>
<li><em>Point</em> - The Point class represents a location on the CFG that acts
as a container of inserted snippet <strong>Instances</strong>. Points of different
types are distinct even the underlying code relocation and generation
engine happens to put instrumentation from them at the same place.</li>
<li><em>Instance</em> - The Instance class is a representation of a particular
snippet inserted at a particular point.</li>
<li><em>PatchObject</em> - The PatchObject class is a wrapper of ParseAPI’s
CodeObject class, which represents an individual binary code object,
such as an executable or a library.</li>
<li><em>PatchFunction</em> - The PatchFunction class is a wrapper of ParseAPI’s
Function class, which represents a function.</li>
<li><em>PatchBlock</em> - The PatchBlock class is a wrapper of ParseAPI’s Block
class, which represents a basic block.</li>
<li><em>PatchEdge</em> - The PatchEdge class is a wrapper of ParseAPI’s Edge
class, which join two basic blocks in the CFG, indicating the type of
control flow transfer instruction that joins the basic blocks to each
other.</li>
<li><em>PatchLoop</em> - The PatchLoop class is a wrapper of ParseAPI’s Loop
class, which repreents a piece of code that may execute repeatedly.</li>
<li><em>PatchLoopTreeNode</em> - The PatchLoopTreeNode class is a wrapper of
ParseAPI’s LoopTreeNode class, which provides a tree interface to a
collection of instances of class PatchLoop contained in a function.
The structure of the tree follows the nesting relationship of the
loops in a function.</li>
</ul>
</div>
<div class="section" id="plugin-interface">
<span id="sec-2-2"></span><h2>Plugin Interface<a class="headerlink" href="#plugin-interface" title="Permalink to this headline"></a></h2>
<p>The address space abstraction determines whether the code patching is
1st party, 3rd party or binary rewriting.</p>
<ul class="simple">
<li><em>AddrSpace</em> - The AddrSpace class represents the address space of a
<strong>Mutatee</strong> (a program that is instrumented), where it contains a
collection of <strong>PatchObjects</strong> that represent shared libraries or a
binary executable. In addition, programmers implement some memory
management interfaces in the AddrSpace class to determines the type
of the code patching - 1st party, 3rd party, or binary rewriting.</li>
</ul>
<p>Programmers can decide the representation of a <strong>Snippet</strong>, for example,
the representation can be in high level language (e.g., C or C++), or
can simply be in binary code (e.g., 0s and 1s).</p>
<ul class="simple">
<li><em>Snippet</em> - The Snippet class allows programmers to easily plug in
their own snippet representation and the corresponding mini-compiler
to translate the representation into the binary code.</li>
</ul>
<p>PatchAPI provides a thin layer on top of ParseAPI’s Control Flow Graph
(CFG) layer, which associates some useful information for the ease of
binary code patching, for example, a shared library’s load address. This
layer of CFG structures include PatchObject, PatchFunction, PatchBlock
and PatchEdge classes. Programmers can extend these four CFG classes,
and use the derived class of CFGMaker to build a CFG with the augmented
CFG structures.</p>
<ul class="simple">
<li><em>CFGMaker</em> - The CFGMaker class is a factory class that constructs
the above CFG structures. This class is used in CFG parsing.</li>
</ul>
<p>Similar to customizing the PatchAPI layer, programmers can also
customize the Point class by extending it.</p>
<ul class="simple">
<li><em>PointMaker</em> - The PointMaker class is a factory class that
constructs a subclass of the Point class.</li>
</ul>
<div class="figure align-default" id="fig-inh">
<a class="reference internal image-reference" href="patchAPI/figure/command/img.pdf"><img alt="Inheritance Hierarchy" src="patchAPI/figure/command/img.pdf" style="width: 85.0%;" /></a>
<p class="caption"><span class="caption-text">Inheritance Hierarchy</span><a class="headerlink" href="#fig-inh" title="Permalink to this image"></a></p>
</div>
<p>The implementation of an instrumentation engine may be very
sophisticated (e.g., relocating a function), or very simple (e.g.,
simply overwrite an instruction). Therefore, PatchAPI provides a
flexible framework for programmers to customize the instrumentation
engine. This framework is based on Command Pattern&nbsp; <a class="footnote-reference" href="#id5" id="id1">[1]</a>. The
instrumentation engine has transactional semantics, where all
instrumentation requests should succeed or all should fail. In our
framework, the <strong>Command</strong> abstraction represents an instrumentation
request or a logical step in the code patching process. We accumulate a
list of <strong>Commands</strong>, and execute them one by one. If one <strong>Command</strong>
fails, we undo all preceding finished <strong>Commands</strong>. Figure
<a class="reference external" href="#fig:inh">2</a> illustrates the inheritance hierarchy for related
classes. There is a default implementation of instrumentation engine in
PatchAPI for 1st party code patching.</p>
<ul class="simple">
<li><em>Command</em> - The Command class represents an instrumentation request
(e.g., snippet insertion or removal), or a logical step in the code
patching (e.g., install instrumentation). This class provides a run()
method and an undo() method, where run() will be called for normal
execution, and undo() will be called for undoing this Command.</li>
<li><em>BatchCommand</em> - The BatchCommand class is a subclass of Command, and
it is in fact a container of a list of Commands to be executed
atomically.</li>
<li><em>Instrumenter</em> - The Instrumenter class inherits BatchCommand to
encapsulate the core code patching logic, which includes binary code
generation. Instrumenter would contain several logical steps that are
individual Commands.</li>
<li><em>Patcher</em> - The Patcher class is also a subclass of BatchCommand. It
accepts instrumentation requests from users, where these
instrumentation requests are Commands (e.g., snippet insertion).
Furthermore, Patcher implicitly adds Instrumenter to the end of the
Command list to generate binary code and install the instrumentation.</li>
</ul>
</div>
</div>
<div class="section" id="examples">
<span id="sec-example"></span><h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h1>
<p>To illustrate the ideas of PatchAPI, we present some simple code
examples that demonstrate how the API can be used.</p>
<div class="section" id="using-the-public-interface">
<h2>Using the public interface<a class="headerlink" href="#using-the-public-interface" title="Permalink to this headline"></a></h2>
<p>The basic flow of doing code patching is to first find some points in a
program, and then to insert, delete or update a piece of code at these
points.</p>
<div class="section" id="cfg-traversal">
<h3>CFG Traversal<a class="headerlink" href="#cfg-traversal" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ParseAPI</span><span class="p">::</span><span class="n">CodeObject</span><span class="o">*</span> <span class="n">co</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">PatchObject</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">PatchObject</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">code_base</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Find</span> <span class="nb">all</span> <span class="n">functions</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">object</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PatchFunction</span><span class="o">*&gt;</span> <span class="nb">all</span><span class="p">;</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="p">(</span><span class="n">back_inserter</span><span class="p">(</span><span class="nb">all</span><span class="p">));</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PatchFunction</span><span class="o">*&gt;</span><span class="p">::</span><span class="n">iterator</span> <span class="n">fi</span> <span class="o">=</span> <span class="nb">all</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span>
     <span class="n">fi</span> <span class="o">!=</span> <span class="nb">all</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="n">fi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Print</span> <span class="n">out</span> <span class="n">each</span> <span class="n">function</span><span class="s1">&#39;s name</span>
  <span class="n">PatchFunction</span><span class="o">*</span> <span class="n">func</span> <span class="o">=</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">const</span> <span class="n">PatchFunction</span><span class="p">::</span><span class="n">Blockset</span><span class="o">&amp;</span> <span class="n">blks</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">PatchFunction</span><span class="p">::</span><span class="n">BlockSet</span><span class="p">::</span><span class="n">iterator</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">blks</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">bi</span> <span class="o">!=</span> <span class="n">blks</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="n">bi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Print</span> <span class="n">out</span> <span class="n">each</span> <span class="n">block</span><span class="s1">&#39;s size</span>
    <span class="n">PatchBlock</span><span class="o">*</span> <span class="n">blk</span> <span class="o">=</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Block size:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above code, we illustrate how to traverse CFG structures in
PatchAPI. First, we construct an instance of PatchObject using an
instance of ParseAPI’s CodeObject. Then, we traverse all functions in
that object, and print out each function’s name. For each function, we
also print out the size of each basic block.</p>
</div>
<div class="section" id="point-finding">
<span id="sec-example-pt"></span><h3>Point Finding<a class="headerlink" href="#point-finding" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PatchFunction</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="n">PatchBlock</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="n">PatchEdge</span> <span class="o">*</span><span class="n">edge</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="n">PatchMgr</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">*&gt;</span> <span class="n">pts</span><span class="p">;</span>
<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">findPoints</span><span class="p">(</span><span class="n">Scope</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                <span class="n">Point</span><span class="p">::</span><span class="n">FuncEntry</span> <span class="o">|</span>
                <span class="n">Point</span><span class="p">::</span><span class="n">PreCall</span> <span class="o">|</span>
                <span class="n">Point</span><span class="p">::</span><span class="n">FuncExit</span><span class="p">,</span>
                <span class="n">back_inserter</span><span class="p">(</span><span class="n">pts</span><span class="p">));</span>
<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">findPoints</span><span class="p">(</span><span class="n">Scope</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
                <span class="n">Point</span><span class="p">::</span><span class="n">BlockEntry</span><span class="p">,</span>
                <span class="n">back_inserter</span><span class="p">(</span><span class="n">pts</span><span class="p">));</span>
<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">findPoints</span><span class="p">(</span><span class="n">Scope</span><span class="p">(</span><span class="n">edge</span><span class="p">),</span>
                <span class="n">Point</span><span class="p">::</span><span class="n">EdgeDuring</span><span class="p">,</span>
                <span class="n">back_inserter</span><span class="p">(</span><span class="n">pts</span><span class="p">));</span>
</pre></div>
</div>
<p>The above code shows how to use the PatchMgr::findPoints method to find
some instrumentation points. There are three invocations of findPoints.
For the first invocation (Line 8), it finds points only within a
specific function <em>func</em>, and output the found points to a vector <em>pts</em>.
The result should include all points at this function’s entry, before
all function calls inside this function, and at the function’s exit.
Similarly, for the second invocation (Line 13), it finds points only
within a specific basic <em>block</em>, and the result should include the point
at the block entry. Finally, for the third invocation (Line 16), it
finds the point at a specific CFG <em>edge</em> that connects two basic blocks.</p>
</div>
<div class="section" id="code-patching">
<h3>Code Patching<a class="headerlink" href="#code-patching" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MySnippet</span><span class="p">::</span><span class="n">ptr</span> <span class="n">snippet</span> <span class="o">=</span> <span class="n">MySnippet</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">new</span> <span class="n">MySnippet</span><span class="p">);</span>

<span class="n">Patcher</span> <span class="n">patcher</span><span class="p">(</span><span class="n">mgr</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">*&gt;</span><span class="p">::</span><span class="n">iterator</span> <span class="nb">iter</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span>
     <span class="nb">iter</span> <span class="o">!=</span> <span class="n">pts</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="nb">iter</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Point</span><span class="o">*</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">*</span><span class="nb">iter</span><span class="p">;</span>
  <span class="n">patcher</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PushBackCommand</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">snippet</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">patcher</span><span class="o">.</span><span class="n">commit</span><span class="p">();</span>
</pre></div>
</div>
<p>The above code is to insert the same code <em>snippet</em> to all points <em>pts</em>
found in Section&nbsp;<a class="reference external" href="#sec-example-pt">3.1.2</a>. We’ll explain the snippet
(Line 1) in the example in Section&nbsp;<a class="reference external" href="#sec-example-snip">3.2.2</a>. Each
point maintains a list of snippet instances, and the PushBackCommand is
to push a snippet instance to the end of that list. An instance of
Patcher is to represent a transaction of code patching. In this example,
all snippet insertions (or all PushBackCommands) are performed
atomically when the Patcher::commit method is invoked. That is, all
snippet insertions would succeed or all would fail.</p>
</div>
</div>
<div class="section" id="using-the-plugin-interface">
<h2>Using the plugin interface<a class="headerlink" href="#using-the-plugin-interface" title="Permalink to this headline"></a></h2>
<div class="section" id="address-space">
<h3>Address Space<a class="headerlink" href="#address-space" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyAddrSpace</span> <span class="p">:</span> <span class="n">public</span> <span class="n">AddrSpace</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">virtual</span> <span class="n">Address</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PatchObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">Address</span> <span class="n">near</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Address</span> <span class="n">buffer</span> <span class="o">=</span> <span class="o">...</span>
      <span class="o">//</span> <span class="n">do</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">here</span>
      <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">write</span><span class="p">(</span><span class="n">PatchObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Address</span> <span class="n">to_addr</span><span class="p">,</span> <span class="n">Address</span> <span class="n">from_addr</span><span class="p">,</span>
                       <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">//</span> <span class="n">copy</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">address</span> <span class="n">from_addr</span> <span class="n">to</span> <span class="n">the</span> <span class="n">address</span> <span class="n">to_addr</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The above code is to implement the address space plugin, in which, a set
of memory management methods should be specified, including malloc,
free, realloc, write and so forth. The instrumentation engine will
utilize these memory management methods during the code patching
process. For example, the instrumentation engine needs to <em>malloc</em> a
buffer in Mutatee’s address space, and then <em>write</em> the code snippet
into this buffer.</p>
</div>
<div class="section" id="snippet-representation">
<span id="sec-example-snip"></span><h3>Snippet Representation<a class="headerlink" href="#snippet-representation" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySnippet</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Snippet</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">generate</span><span class="p">(</span><span class="n">Point</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">//</span> <span class="n">Generate</span> <span class="ow">and</span> <span class="n">store</span> <span class="n">binary</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">Buffer</span> <span class="n">buf</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">MySnippet</span><span class="p">::</span><span class="n">ptr</span> <span class="n">snippet</span> <span class="o">=</span> <span class="n">MySnippet</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">new</span> <span class="n">MySnippet</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code illustrates how to customize a user-defined snippet
<em>MySnippet</em> by implementing the “mini-compiler” in the <em>generate</em>
method, which will be used later in the instrumentation engine to
generate binary code.</p>
</div>
<div class="section" id="code-parsing">
<h3>Code Parsing<a class="headerlink" href="#code-parsing" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyFunction</span> <span class="p">:</span> <span class="n">public</span> <span class="n">PatchFunction</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">MyCFGMaker</span> <span class="p">:</span> <span class="n">public</span> <span class="n">CFGMaker</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">virtual</span> <span class="n">PatchFunction</span><span class="o">*</span> <span class="n">makeFunction</span><span class="p">(</span><span class="n">ParseAPI</span><span class="p">::</span><span class="n">Function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">PatchObject</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">new</span> <span class="n">MyFunction</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Programmers can augment PatchAPI’s CFG structures by annotating their
own data. In this case, a factory class should be built by inheriting
from the CFGMaker class, to create the augmented CFG structures. The
factory class will be used for CFG parsing.</p>
</div>
<div class="section" id="point-making">
<h3>Point Making<a class="headerlink" href="#point-making" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyPoint</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="n">MyPoint</span><span class="p">(</span><span class="n">Point</span><span class="p">::</span><span class="n">Type</span> <span class="n">t</span><span class="p">,</span> <span class="n">PatchMgrPtr</span> <span class="n">m</span><span class="p">,</span> <span class="n">PatchFunction</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
    <span class="o">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MyPointMaker</span><span class="p">:</span> <span class="n">public</span> <span class="n">PointMaker</span> <span class="p">{</span>
  <span class="n">protected</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">Point</span> <span class="o">*</span><span class="n">mkFuncPoint</span><span class="p">(</span><span class="n">Point</span><span class="p">::</span><span class="n">Type</span> <span class="n">t</span><span class="p">,</span> <span class="n">PatchMgrPtr</span> <span class="n">m</span><span class="p">,</span> <span class="n">PatchFunction</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">new</span> <span class="n">MyPoint</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the above example, the MyPoint class inherits from the Point class,
and the MyPointMaker class inherits from the PointMaker class. The
mkFuncPoint method in MyPointMaker simply returns a new instance of
MyPoint. The mkFuncPoint method will be invoked by
PatchMgr::findPoint(s).</p>
</div>
<div class="section" id="instrumentation-engine">
<h3>Instrumentation Engine<a class="headerlink" href="#instrumentation-engine" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyInstrumenter</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Instrumenter</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
      <span class="o">//</span> <span class="n">Specify</span> <span class="n">how</span> <span class="n">to</span> <span class="n">install</span> <span class="n">instrumentation</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Programmers can customize the instrumentation engine by extending the
Instrumenter class, and implement the installation of instrumentation
inside the method <em>run()</em>.</p>
</div>
<div class="section" id="plugin-registration">
<h3>Plugin Registration<a class="headerlink" href="#plugin-registration" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyCFGMakerPtr</span> <span class="n">cm</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">PatchObject</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">PatchObject</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">cm</span><span class="p">);</span>

<span class="n">MyAddrSpacePtr</span> <span class="k">as</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">as</span><span class="o">-&gt;</span><span class="n">loadObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="n">MyInstrumenter</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">PatchMgrPtr</span> <span class="n">mgr</span> <span class="o">=</span> <span class="n">PatchMgr</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="k">as</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>

<span class="n">MySnippet</span><span class="p">::</span><span class="n">ptr</span> <span class="n">snippet</span> <span class="o">=</span> <span class="n">MySnippet</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">new</span> <span class="n">MySnippet</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code shows how to register the above four types of plugins. An
instance of the factory class for creating CFG structures is registered
to an PatchObject (Line 1 and 2), which is in turn loaded into an
instance of AddrSpace (Line 4 and 5). The AddrSpace (or its subclass
implemented by programmers) instance is passed to PatchMgr::create (Line
7 and 8), together with an instance of Instrumenter (or its subclass).
Finally, a snippet of custom snippet representation MySnippet is created
(Line 10). Therefore, all plugins are glued together in PatchAPI.</p>
</div>
</div>
</div>
<div class="section" id="public-api-reference">
<span id="sec-public-api"></span><h1>Public API Reference<a class="headerlink" href="#public-api-reference" title="Permalink to this headline"></a></h1>
<p>This section describes public interfaces in PatchAPI. The API is
organized as a collection of C++ classes. The classes in PatchAPI fall
under the C++ namespace Dyninst::PatchAPI. To access them, programmers
should refer to them using the “Dyninst::PatchAPI::” prefix, e.g.,
Dyninst::PatchAPI::Point. Alternatively, programmers can add the C++
<em>using</em> keyword above any references to PatchAPI objects, e.g.,<em>using
namespace Dyninst::PatchAPI</em> or <em>using Dyninst::PatchAPI::Point</em>.</p>
<p>Classes in PatchAPI use either the C++ raw pointer or the boost shared
pointer (<em>boost::shared_ptr&lt;T&gt;</em>) for memory management. A class uses a
raw pointer whenever it is returning a handle to the user that is
controlled and destroyed by the PatchAPI runtime library. Classes that
use a raw pointer include the CFG objects, a Point, and various plugins,
e.g., AddrSpace, CFGMaker, PointMaker, and Instrumenter. A class uses a
shared_pointer whenever it is handing something to the user that the
PatchAPI runtime library is not controlling and destroying. Classes that
use a boost shared pointer include a Snippet, PatchMgr, and Instance,
where we typedef a class’s shared pointer by appending the Ptr to the
class name, e.g., PatchMgrPtr for PatchMgr.</p>
<div class="section" id="cfg-interface">
<h2>CFG Interface<a class="headerlink" href="#cfg-interface" title="Permalink to this headline"></a></h2>
<div class="section" id="patchobject">
<span id="sec-3-2-8"></span><h3>PatchObject<a class="headerlink" href="#patchobject" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchObject.h</p>
<p>The PatchObject class is a wrapper of ParseAPI’s CodeObject class
(has-a), which represents an individual binary code object, such as an
executable or a library.</p>
<p>static PatchObject* create(ParseAPI::CodeObject* co, Address base,
CFGMaker* cm = NULL, PatchCallback *cb = NULL);</p>
<p>Creates an instance of PatchObject, which has <em>co</em> as its on-disk
representation (ParseAPI::CodeObject), and <em>base</em> as the base address
where this object is loaded in the memory. For binary rewriting, base
should be 0. The <em>cm</em> and <em>cb</em> parameters are for registering plugins.
If <em>cm</em> or <em>cb</em> is NULL, then we use the default implementation of
CFGMaker or PatchCallback.</p>
<p>static PatchObject* clone(PatchObject* par_obj, Address base,
CFGMaker* cm = NULL, PatchCallback *cb = NULL);</p>
<p>Returns a new object that is copied from the specified object <em>par_obj</em>
at the loaded address <em>base</em> in the memory. For binary rewriting, base
should be 0. The <em>cm</em> and <em>cb</em> parameters are for registering plugins.
If <em>cm</em> or <em>cb</em> is NULL, then we use the default implementation of
CFGMaker or PatchCallback.</p>
<p>Address codeBase();</p>
<p>Returns the base address where this object is loaded in memory.</p>
<p>PatchFunction *getFunc(ParseAPI::Function *func, bool create = true);</p>
<p>Returns an instance of PatchFunction in this object, based on the <em>func</em>
parameter. PatchAPI creates a PatchFunction on-demand, so if there is
not any PatchFunction created for the ParseAPI function <em>func</em>, and the
<em>create</em> parameter is false, then no any instance of PatchFunction will
be created.</p>
<p>It returns NULL in two cases. First, the function <em>func</em> is not in this
PatchObject. Second, the PatchFunction is not yet created and the
<em>create</em> is false. Otherwise, it returns a PatchFunction.</p>
<p>template &lt;class Iter&gt; void funcs(Iter iter);</p>
<p>Outputs all instances of PatchFunction in this PatchObject to the STL
inserter <em>iter</em>.</p>
<p>PatchBlock *getBlock(ParseAPI::Block* blk, bool create = true);</p>
<p>Returns an instance of PatchBlock in this object, based on the <em>blk</em>
parameter. PatchAPI creates a PatchBlock on-demand, so if there is not
any PatchBlock created for the ParseAPI block <em>blk</em>, and the <em>create</em>
parameter is false, then no any instance of PatchBlock will be created.</p>
<p>It returns NULL in two cases. First, the ParseAPI block <em>blk</em> is not in
this PatchObject. Second, the PatchBlock is not yet created and the
<em>create</em> is false. Otherwise, it returns a PatchBlock.</p>
<p>template &lt;class Iter&gt; void blocks(Iter iter);</p>
<p>Outputs all instances of PatchBlock in this object to the STL inserter
<em>iter</em>.</p>
<p>PatchEdge *getEdge(ParseAPI::Edge* edge, PatchBlock* src,
PatchBlock* trg, bool create = true);</p>
<p>Returns an instance of PatchEdge in this object, according to the
parameters ParseAPI::Edge <em>edge</em>, source PatchBlock <em>src</em>, and target
PatchBlock <em>trg</em>. PatchAPI creates a PatchEdge on-demand, so if there is
not any PatchEdge created for the ParseAPI <em>edge</em>, and the <em>create</em>
parameter is false, then no any instance of PatchEdge will be created.</p>
<p>It returns NULL in two cases. First, the ParseAPI <em>edge</em> is not in this
PatchObject. Second, the PatchEdge is not yet created and the <em>create</em>
is false. Otherwise, it returns a PatchEdge.</p>
<p>template &lt;class Iter&gt; void edges(Iter iter);</p>
<p>Outputs all instances of PatchEdge in this object to the STL inserter
<em>iter</em>.</p>
<p>PatchCallback *cb() const;</p>
<p>Returns the PatchCallback object associated with this PatchObject.</p>
</div>
<div class="section" id="patchfunction">
<span id="sec-3-2-9"></span><h3>PatchFunction<a class="headerlink" href="#patchfunction" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCFG.h</p>
<p>The PatchFunction class is a wrapper of ParseAPI’s Function class
(has-a), which represents a function.</p>
<p>const string &amp;name();</p>
<p>Returns the function’s mangled name.</p>
<p>Address addr() const;</p>
<p>Returns the address of the first instruction in this function.</p>
<p>ParseAPI::Function *function();</p>
<p>Returns the ParseAPI::Function associated with this PatchFunction.</p>
<p>PatchObject* obj();</p>
<p>Returns the PatchObject associated with this PatchFunction.</p>
<p>typedef std::set&lt;PatchBlock *&gt; PatchFunction::Blockset;</p>
<p>const Blockset &amp;blocks();</p>
<p>Returns a set of all PatchBlocks in this PatchFunction.</p>
<p>PatchBlock *entry();</p>
<p>Returns the entry block of this PatchFunction.</p>
<p>const Blockset &amp;exitBlocks();</p>
<p>Returns a set of exit blocks of this PatchFunction.</p>
<p>const Blockset &amp;callBlocks();</p>
<p>Returns a set of all call blocks of this PatchFunction.</p>
<p>PatchCallback *cb() const;</p>
<p>Returns the PatchCallback object associated with this PatchFunction.</p>
<p>PatchLoopTreeNode* getLoopTree()</p>
<p>Return the nesting tree of the loops in the function. See class
<code class="docutils literal notranslate"><span class="pre">PatchLoopTreeNode</span></code> for more details</p>
<p>PatchLoop* findLoop(const char *name)</p>
<p>Return the loop with the given nesting name. See class
<code class="docutils literal notranslate"><span class="pre">PatchLoopTreeNode</span></code> for more details about how loop nesting names are
assigned.</p>
<p>bool getLoops(vector&lt;PatchLoop*&gt; &amp;loops);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">loops</span></code> with all the loops in the function</p>
<p>bool getOuterLoops(vector&lt;PatchLoop*&gt; &amp;loops);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">loops</span></code> with all the outermost loops in the function</p>
<p>bool dominates(PatchBlock* A, PatchBlock *B);</p>
<p>Return true if block <code class="docutils literal notranslate"><span class="pre">A</span></code> dominates block <code class="docutils literal notranslate"><span class="pre">B</span></code></p>
<p>PatchBlock* getImmediateDominator(PatchBlock *A);</p>
<p>Return the immediate dominator of block <code class="docutils literal notranslate"><span class="pre">A</span></code>，<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the block
<code class="docutils literal notranslate"><span class="pre">A</span></code> does not have an immediate dominator.</p>
<p>void getImmediateDominates(PatchBlock *A, set&lt;PatchBlock*&gt; &amp;imm);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">imm</span></code> with all the blocks immediate dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>void getAllDominates(PatchBlock *A, set&lt;PatchBlock*&gt; &amp;dom);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">dom</span></code> with all the blocks dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>bool postDominates(PatchBlock* A, PatchBlock *B);</p>
<p>Return true if block <code class="docutils literal notranslate"><span class="pre">A</span></code> post-dominates block <code class="docutils literal notranslate"><span class="pre">B</span></code></p>
<p>PatchBlock* getImmediatePostDominator(PatchBlock *A);</p>
<p>Return the immediate post-dominator of block <code class="docutils literal notranslate"><span class="pre">A</span></code>，<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the
block <code class="docutils literal notranslate"><span class="pre">A</span></code> does not have an immediate post-dominator.</p>
<p>void getImmediatePostDominates(PatchBlock *A, set&lt;PatchBlock*&gt; &amp;imm);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">imm</span></code> with all the blocks immediate post-dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>void getAllPostDominates(PatchBlock *A, set&lt;PatchBlock*&gt; &amp;dom);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">dom</span></code> with all the blocks post-dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
</div>
<div class="section" id="patchblock">
<span id="sec-3-2-10"></span><h3>PatchBlock<a class="headerlink" href="#patchblock" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCFG.h</p>
<p>The PatchBlock class is a wrapper of ParseAPI’s Block class (has-a),
which represents a basic block.</p>
<p>Address start() const;</p>
<p>Returns the lower bound of this block (the address of the first
instruction).</p>
<p>Address end() const;</p>
<p>Returns the upper bound (open) of this block (the address immediately
following the last byte in the last instruction).</p>
<p>Address last() const;</p>
<p>Returns the address of the last instruction in this block.</p>
<p>Address size() const;</p>
<p>Returns end() - start().</p>
<p>bool isShared();</p>
<p>Indicates whether this block is contained by multiple functions.</p>
<p>int containingFuncs() const;</p>
<p>Returns the number of functions that contain this block.</p>
<p>typedef std::map&lt;Address, InstructionAPI::Instruction::Ptr&gt; Insns; void
getInsns(Insns &amp;insns) const;</p>
<p>This function outputs Instructions that are in this block to <em>insns</em>.</p>
<p>InstructionAPI::Instruction::Ptr getInsn(Address a) const;</p>
<p>Returns an Instruction that has the address <em>a</em> as its starting address.
If no any instruction can be found in this block with the starting
address <em>a</em>, it returns InstructionAPI::Instruction::Ptr().</p>
<p>std::string disassemble() const;</p>
<p>Returns a string containing the disassembled code for this block. This
is mainly for debugging purpose.</p>
<p>bool containsCall();</p>
<p>Indicates whether this PatchBlock contains a function call instruction.</p>
<p>bool containsDynamicCall();</p>
<p>Indicates whether this PatchBlock contains any indirect function call,
e.g., via function pointer.</p>
<p>PatchFunction* getCallee();</p>
<p>Returns the callee function, if this PatchBlock contains a function
call; otherwise, NULL is returned.</p>
<p>PatchFunction *function() const;</p>
<p>Returns a PatchFunction that contains this PatchBlock. If there are
multiple PatchFunctions containing this PatchBlock, then a random one of
them is returned.</p>
<p>ParseAPI::Block *block() const;</p>
<p>Returns the ParseAPI::Block associated with this PatchBlock.</p>
<p>PatchObject* obj() const;</p>
<p>Returns the PatchObject that contains this block.</p>
<p>typedef std::vector&lt;PatchEdge*&gt; PatchBlock::edgelist;</p>
<p>const edgelist &amp;sources();</p>
<p>Returns a list of the source PatchEdges. This PatchBlock is the target
block of the returned edges.</p>
<p>const edgelist &amp;targets();</p>
<p>Returns a list of the target PatchEdges. This PatchBlock is the source
block of the returned edges.</p>
<p>template &lt;class OutputIterator&gt; void getFuncs(OutputIterator result);</p>
<p>Outputs all functions containing this PatchBlock to the STL inserter
<em>result</em>.</p>
<p>PatchCallback *cb() const;</p>
<p>Returns the PatchCallback object associated with this PatchBlock.</p>
</div>
<div class="section" id="patchedge">
<span id="sec-3-2-11"></span><h3>PatchEdge<a class="headerlink" href="#patchedge" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCFG.h</p>
<p>The PatchEdge class is a wrapper of ParseAPI’s Edge class (has-a), which
joins two PatchBlocks in the CFG, indicating the type of control flow
transfer instruction that joins the basic blocks to each other.</p>
<p>ParseAPI::Edge *edge() const;</p>
<p>Returns a ParseAPI::Edge associated with this PatchEdge.</p>
<p>PatchBlock *src();</p>
<p>Returns the source PatchBlock.</p>
<p>PatchBlock *trg();</p>
<p>Returns the target PatchBlock.</p>
<p>ParseAPI::EdgeTypeEnum type() const;</p>
<p>Returns the edge type (ParseAPI::EdgeTypeEnum, please see <a class="reference external" href="ftp://ftp.cs.wisc.edu/paradyn/releases/release7.0/doc/parseapi.pdf">ParseAPI
Manual</a>).</p>
<p>bool sinkEdge() const;</p>
<p>Indicates whether this edge targets the special sink block, where a sink
block is a block to which all unresolvable control flow instructions
will be linked.</p>
<p>bool interproc() const;</p>
<p>Indicates whether the edge should be interpreted as interprocedural
(e.g., calls, returns, direct branches under certain circumstances).</p>
<p>PatchCallback *cb() const;</p>
<p>Returns a Patchcallback object associated with this PatchEdge.</p>
</div>
<div class="section" id="patchloop">
<span id="sec-3-2-12"></span><h3>PatchLoop<a class="headerlink" href="#patchloop" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCFG.h</p>
<p>The PatchLoop class is a wrapper of ParseAPI’s Loop class (has-a). It
represents code structure that may execute repeatedly.</p>
<p>PatchLoop* parent</p>
<p>Returns the loop which directly encloses this loop. NULL if no such
loop.</p>
<p>bool containsAddress(Address addr)</p>
<p>Returns true if the given address is within the range of this loop’s
basic blocks.</p>
<p>bool containsAddressInclusive(Address addr)</p>
<p>Returns true if the given address is within the range of this loop’s
basic blocks or its children.</p>
<p>int getLoopEntries(vector&lt;PatchBlock*&gt;&amp; entries);</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">entries</span></code> with the set of entry basic blocks of the loop. Return
the number of the entries that this loop has</p>
<p>int getBackEdges(vector&lt;PatchEdge*&gt; &amp;edges)</p>
<p>Sets <code class="docutils literal notranslate"><span class="pre">edges</span></code> to the set of back edges in this loop. It returns the
number of back edges that are in this loop.</p>
<p>bool getContainedLoops(vector&lt;PatchLoop*&gt; &amp;loops)</p>
<p>Returns a vector of loops that are nested under this loop.</p>
<p>bool getOuterLoops(vector&lt;PatchLoop*&gt; &amp;loops)</p>
<p>Returns a vector of loops that are directly nested under this loop.</p>
<p>bool getLoopBasicBlocks(vector&lt;PatchBlock*&gt; &amp;blocks)</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">blocks</span></code> with all basic blocks in the loop</p>
<p>bool getLoopBasicBlocksExclusive(vector&lt;PatchBlock*&gt; &amp;blocks)</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">blocks</span></code> with all basic blocks in this loop, excluding the
blocks of its sub loops.</p>
<p>bool hasBlock(PatchBlock *b);</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this loop contains basic block <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>bool hasBlockExclusive(PatchBlock *b);</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this loop contains basic block <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> is
not in its sub loops.</p>
<p>bool hasAncestor(PatchLoop *loop)</p>
<p>Returns true if this loop is a descendant of the given loop.</p>
<p>PatchFunction * getFunction();</p>
<p>Returns the function that this loop is in.</p>
</div>
<div class="section" id="patchlooptreenode">
<span id="sec-3-2-13"></span><h3>PatchLoopTreeNode<a class="headerlink" href="#patchlooptreenode" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCFG.h</p>
<p>The PatchLoopTreeNode class provides a tree interface to a collection of
instances of class PatchLoop contained in a function. The structure of
the tree follows the nesting relationship of the loops in a function.
Each PatchLoopTreeNode contains a pointer to a loop (represented by
PatchLoop), and a set of sub-loops (represented by other
PatchLoopTreeNode objects). The <code class="docutils literal notranslate"><span class="pre">loop</span></code> field at the root node is
always <code class="docutils literal notranslate"><span class="pre">NULL</span></code> since a function may contain multiple outer loops. The
<code class="docutils literal notranslate"><span class="pre">loop</span></code> field is never <code class="docutils literal notranslate"><span class="pre">NULL</span></code> at any other node since it always
corresponds to a real loop. Therefore, the outer most loops in the
function are contained in the vector of <code class="docutils literal notranslate"><span class="pre">children</span></code> of the root.</p>
<p>Each instance of PatchLoopTreeNode is given a name that indicates its
position in the hierarchy of loops. The name of each outermost loop
takes the form of <code class="docutils literal notranslate"><span class="pre">loop_x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer from 1 to n,
where n is the number of outer loops in the function. Each sub-loop has
the name of its parent, followed by a <code class="docutils literal notranslate"><span class="pre">.y</span></code>, where <code class="docutils literal notranslate"><span class="pre">y</span></code> is 1 to m,
where m is the number of sub-loops under the outer loop. For example,
consider the following C function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">foo</span></code> function will have a root PatchLoopTreeNode, containing a
NULL loop entry and two PatchLoopTreeNode children representing the
functions outermost loops. These children would have names <code class="docutils literal notranslate"><span class="pre">loop_1</span></code>
and <code class="docutils literal notranslate"><span class="pre">loop_2</span></code>, respectively representing the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> loops.
<code class="docutils literal notranslate"><span class="pre">loop_2</span></code> has no children. <code class="docutils literal notranslate"><span class="pre">loop_1</span></code> has two child PatchLoopTreeNode
objects, named <code class="docutils literal notranslate"><span class="pre">loop_1.1</span></code> and <code class="docutils literal notranslate"><span class="pre">loop_1.2</span></code>, respectively representing
the <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> loops.</p>
<p>PatchLoop *loop;</p>
<p>The PatchLoop instance it points to.</p>
<p>std::vector&lt;PatchLoopTreeNode *&gt; children;</p>
<p>The PatchLoopTreeNode instances nested within this loop.</p>
<p>const char * name();</p>
<p>Returns the hierarchical name of this loop.</p>
<p>const char * getCalleeName(unsigned int i)</p>
<p>Returns the function name of the ith callee.</p>
<p>unsigned int numCallees()</p>
<p>Returns the number of callees contained in this loop’s body.</p>
<p>bool getCallees(vector&lt;PatchFunction *&gt; &amp;v);</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">v</span></code> with a vector of the functions called inside this loop.</p>
<p>PatchLoop * findLoop(const char *name);</p>
<p>Looks up a loop by the hierarchical name</p>
</div>
</div>
<div class="section" id="point-snippet-interface">
<span id="sec-3-1"></span><h2>Point/Snippet Interface<a class="headerlink" href="#point-snippet-interface" title="Permalink to this headline"></a></h2>
<div class="section" id="patchmgr">
<span id="sec-3-1-1"></span><h3>PatchMgr<a class="headerlink" href="#patchmgr" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchMgr.h</p>
<p>The PatchMgr class is the top-level class for finding instrumentation
<strong>Points</strong>, inserting or deleting <strong>Snippets</strong>, and registering
user-provided plugins.</p>
<p>static PatchMgrPtr create(AddrSpace* as, Instrumenter* inst = NULL,
PointMaker* pm = NULL);</p>
<p>This factory method creates a new PatchMgr object that performs binary
code patching. It takes input three plugins, including AddrSpace <em>as</em>,
Instrumenter <em>inst</em>, and PointMaker <em>pm</em>. PatchAPI uses default plugins
for PointMaker and Instrumenter, if <em>pm</em> and <em>inst</em> are not specified
(NULL by default).</p>
<p>This method returns PatchMgrPtr() if it was unable to create a new
PatchMgr object.</p>
<p>Point *findPoint(Location loc, Point::Type type, bool create = true);</p>
<p>This method returns a unique Point according to a Location <em>loc</em> and a
Type <em>type</em>. The Location structure is to specify a physical location of
a Point (e.g., at function entry, at block entry, etc.), details of
Location will be covered in Section&nbsp;<a class="reference external" href="#sec-3.1.2">4.2.2</a>. PatchAPI
creates Points on demand, so if a Point is not yet created, the <em>create</em>
parameter is to indicate whether to create this Point. If the Point we
want to find is already created, this method simply returns a pointer to
this Point from a buffer, no matter whether <em>create</em> is true or false.
If the Point we want to find is not yet created, and <em>create</em> is true,
then this method constructs this Point and put it in a buffer, and
finally returns a Pointer to this Point. If the Point creation fails,
this method also returns false. If the Point we want to find is not yet
created, and <em>create</em> is false, this method returns NULL. The basic
logic of finding a point can be found in the
Listing&nbsp;<a class="reference external" href="#findpt">[findpt]</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">point</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">point</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">create</span> <span class="n">point</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">point</span> <span class="n">creation</span> <span class="n">fails</span><span class="p">)</span> <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="n">put</span> <span class="n">the</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">buffer</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>template &lt;class OutputIterator&gt; bool findPoint(Location loc, Point::Type
type, OutputIterator outputIter, bool create = true);</p>
<p>This method finds a Point at a physical Location <em>loc</em> with a <em>type</em>. It
adds the found Point to <em>outputIter</em> that is a STL inserter. The point
is created on demand. If the Point is already created, then this method
outputs a pointer to this Point from a buffer. Otherwise, the <em>create</em>
parameter indicates whether to create this Point.</p>
<p>This method returns true if a point is found, or the <em>create</em> parameter
is false; otherwise, it returns false.</p>
<p>template &lt;class OutputIterator&gt; bool findPoints(Location loc,
Point::Type types, OutputIterator outputIter, bool create = true);</p>
<p>This method finds Points at a physical Location <em>loc</em> with composite
<em>types</em> that are combined using the overloaded operator “|”. This
function outputs Points to the STL inserter <em>outputIter</em>. The point is
created on demand. If the Point is already created, then this method
outputs a pointer to this Point from a buffer. Otherwise, the <em>create</em>
parameter indicates whether to create this Point.</p>
<p>This method returns true if a point is found, or the <em>create</em> parameter
is false; otherwise, it returns false.</p>
<p>template &lt;class FilterFunc, class FilterArgument, class OutputIterator&gt;
bool findPoints(Location loc, Point::Type types, FilterFunc filter_func,
FilterArgument filter_arg, OutputIterator outputIter, bool create =
true);</p>
<p>This method finds Points at a physical Location <em>loc</em> with composite
<em>types</em> that are combined using the overloaded operator “|”. Then, this
method applies a filter functor <em>filter_func</em> with an argument
<em>filter_arg</em> on each found Point. The method outputs Points to the
inserter <em>outputIter</em>. The point is created on demand. If the Point is
already created, then this method returns a pointer to this Point from a
buffer. Otherwise, the <em>create</em> parameter indicates whether to create
this Point.</p>
<p>If no any Point is created, then this method returns false; otherwise,
true is returned. The code below shows the prototype of an example
functor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FilterFunc</span> <span class="p">{</span>
  <span class="n">public</span><span class="p">:</span>
    <span class="nb">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="n">Point</span><span class="p">::</span><span class="n">Type</span> <span class="nb">type</span><span class="p">,</span> <span class="n">Location</span> <span class="n">loc</span><span class="p">,</span> <span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">//</span> <span class="n">The</span> <span class="n">logic</span> <span class="n">to</span> <span class="n">check</span> <span class="n">whether</span> <span class="n">this</span> <span class="n">point</span> <span class="ow">is</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the functor FilterFunc above, programmers check each candidate Point
by looking at the Point::Type, Location, and the user-specified
parameter <em>arg</em>. If the return value is true, then the Point being
checked will be put in the STL inserter <em>outputIter</em>; otherwise, this
Point will be discarded.</p>
<p>struct Scope Scope(PatchBlock *b); Scope(PatchFunction *f, PatchBlock
*b); Scope(PatchFunction *f);;</p>
<p>The Scope structure specifies the scope to find points, where a scope
could be a function, or a basic block. This is quite useful if
programmers don’t know the exact Location, then they can use Scope as a
wildcard. A basic block can be contained in multiple functions. The
second constructor only specifies the block <em>b</em> in a particular function
<em>f</em>.</p>
<p>template &lt;class FilterFunc, class FilterArgument, class OutputIterator&gt;
bool findPoints(Scope scope, Point::Type types, FilterFunc filter_func,
FilterArgument filter_arg, OutputIterator output_iter, bool create =
true);</p>
<p>This method finds points in a <em>scope</em> with certain <em>types</em> that are
combined together by using the overloaded operator “|”. Then, this
method applies the filter functor <em>filter_func</em> on each found Point. It
outputs Points where <em>filter_func</em> returns true to the STL inserter
<em>output_iter</em>. Points are created on demand. If some points are already
created, then this method outputs pointers to them from a buffer.
Otherwise, the <em>create</em> parameter indicates whether to create Points.</p>
<p>If no any Point is created, then this function returns false; otherwise,
true is returned.</p>
<p>template &lt;class OutputIterator&gt; bool findPoints(Scope scope, Point::Type
types, OutputIterator output_iter, bool create = true);</p>
<p>This method finds points in a <em>scope</em> with certain <em>types</em> that are
combined together by using the overloaded operator “|”. It outputs the
found points to the STL inserter <em>output_iter</em>. If some points are
already created, then this method outputs pointers to them from a
buffer. Otherwise, the <em>create</em> parameter indicates whether to create
Points.</p>
<p>If no any Point is created, then this method returns false; otherwise,
true is returned.</p>
<p>bool removeSnippet(InstancePtr);</p>
<p>This method removes a snippet Instance.</p>
<p>It returns false if the point associated with this Instance cannot be
found; otherwise, true is returned.</p>
<p>template &lt;class FilterFunc, class FilterArgument&gt; bool
removeSnippets(Scope scope, Point::Type types, FilterFunc filter_func,
FilterArgument filter_arg);</p>
<p>This method deletes ALL snippet instances at certain points in certain
<em>scope</em> with certain <em>types</em>, and those points pass the test of
<em>filter_func</em>.</p>
<p>If no any point can be found, this method returns false; otherwise, true
is returned.</p>
<p>bool removeSnippets(Scope scope, Point::Type types);</p>
<p>This method deletes ALL snippet instances at certain points in certain
<em>scope</em> with certain <em>types</em>.</p>
<p>If no any point can be found, this method returns false; otherwise, true
is returned.</p>
<p>void destroy(Point *point);</p>
<p>This method is to destroy the specified <em>Point</em>.</p>
<p>AddrSpace* as() const; PointMaker* pointMaker() const; Instrumenter*
instrumenter() const;</p>
<p>The above three functions return the corresponding plugin: AddrSpace,
PointMaker, Instrumenter.</p>
</div>
<div class="section" id="point">
<span id="sec-3-1-2"></span><h3>Point<a class="headerlink" href="#point" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: Point.h</p>
<p>The Point class is in essence a container of a list of snippet
instances. Therefore, the Point class has methods similar to those in
STL.</p>
<p>struct Location static Location Function(PatchFunction *f); static
Location Block(PatchBlock *b); static Location
BlockInstance(PatchFunction *f, PatchBlock *b, bool trusted = false);
static Location Edge(PatchEdge *e); static Location
EdgeInstance(PatchFunction *f, PatchEdge *e); static Location
Instruction(PatchBlock *b, Address a); static Location
InstructionInstance(PatchFunction *f, PatchBlock *b, Address a);
static Location InstructionInstance(PatchFunction *f, PatchBlock *b,
Address a, InstructionAPI::Instruction::Ptr i, bool trusted = false);
static Location EntrySite(PatchFunction *f, PatchBlock *b, bool
trusted = false); static Location CallSite(PatchFunction *f, PatchBlock
*b); static Location ExitSite(PatchFunction *f, PatchBlock *b);;</p>
<p>The Location structure uniquely identifies the physical location of a
point. A Location object plus a Point::Type value uniquely identifies a
point, because multiple Points with different types can exist at the
same physical location. The Location structure provides a set of static
functions to create an object of Location, where each function takes the
corresponding CFG structures to identify a physical location. In
addition, some functions above (e.g., InstructionInstance) takes input
the <em>trusted</em> parameter that is to indicate PatchAPI whether the CFG
structures passed in is trusted. If the <em>trusted</em> parameter is false,
then PatchAPI would have additional checking to verify the CFG
structures passed by users, which causes nontrivial overhead.</p>
<p>enum Point::Type PreInsn, PostInsn, BlockEntry, BlockExit, BlockDuring,
FuncEntry, FuncExit, FuncDuring, EdgeDuring, PreCall, PostCall,
OtherPoint, None, InsnTypes = PreInsn | PostInsn, BlockTypes =
BlockEntry | BlockExit | BlockDuring, FuncTypes = FuncEntry |
FuncExit | FuncDuring, EdgeTypes = EdgeDuring, CallTypes = PreCall |
PostCall;</p>
<p>The enum Point::Type specifies the logical point type. Multiple enum
values can be OR-ed to form a composite type. For example, the composite
type of “PreCall | BlockEntry | FuncExit” is to specify a set of
points with the type PreCall, or BlockEntry, or FuncExit.</p>
<p>typedef std::list&lt;InstancePtr&gt;::iterator instance_iter; instance_iter
begin(); instance_iter end();</p>
<p>The method begin() returns an iterator pointing to the beginning of the
container storing snippet Instances, while the method end() returns an
iterator pointing to the end of the container (past the last element).</p>
<p>InstancePtr pushBack(SnippetPtr); InstancePtr pushFront(SnippetPtr);</p>
<p>Multiple instances can be inserted at the same Point. We maintain the
instances in an ordered list. The pushBack method is to push the
specified Snippet to the end of the list, while the pushFront method is
to push to the front of the list.</p>
<p>Both methods return the Instance that uniquely identifies the inserted
snippet.</p>
<p>bool remove(InstancePtr instance);</p>
<p>This method removes the given snippet <em>instance</em> from this Point.</p>
<p>void clear();</p>
<p>This method removes all snippet instances inserted to this Point.</p>
<p>size_t size();</p>
<p>Returns the number of snippet instances inserted at this Point.</p>
<p>Address addr() const;</p>
<p>Returns the address associated with this point, if it has one;
otherwise, it returns 0.</p>
<p>Type type() const;</p>
<p>Returns the Point type of this point.</p>
<p>bool empty() const;</p>
<p>Indicates whether the container of instances at this Point is empty or
not.</p>
<p>PatchFunction* getCallee();</p>
<p>Returns the function that is invoked at this Point, which should have
Point::Type of Point::PreCall or Point::PostCall. It there is not a
function invoked at this point, it returns NULL.</p>
<p>const PatchObject* obj() const;</p>
<p>Returns the PatchObject where the Point resides.</p>
<p>const InstructionAPI::Instruction::Ptr insn() const;</p>
<p>Returns the Instruction where the Point resides.</p>
<p>PatchFunction* func() const;</p>
<p>Returns the function where the Point resides.</p>
<p>PatchBlock* block() const;</p>
<p>Returns the PatchBlock where the Point resides.</p>
<p>PatchEdge* edge() const;</p>
<p>Returns the Edge where the Point resides.</p>
<p>PatchCallback *cb() const;</p>
<p>Returns the PatchCallback object that is associated with this Point.</p>
<p>static bool TestType(Point::Type types, Point::Type type);</p>
<p>This static method tests whether a set of <em>types</em> contains a specific
<em>type</em>.</p>
<p>static void AddType(Point::Type&amp; types, Point::Type type);</p>
<p>This static method adds a specific <em>type</em> to a set of <em>types</em>.</p>
<p>static void RemoveType(Point::Type&amp; types, Point::Type trg);</p>
<p>This static method removes a specific <em>type</em> from a set of <em>types</em>.</p>
</div>
<div class="section" id="instance">
<span id="sec-3-1-3"></span><h3>Instance<a class="headerlink" href="#instance" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: Point.h</p>
<p>The Instance class is a representation of a particular snippet inserted
at a particular point. If a Snippet is inserted to N points or to the
same point for N times (N <span class="math notranslate nohighlight">\(&gt;\)</span> 1), then there will be N Instances.</p>
<p>bool destroy();</p>
<p>This method destroys the snippet Instance itself.</p>
<p>Point* point() const;</p>
<p>Returns the Point where the Instance is inserted.</p>
<p>SnippetPtr snippet() const;</p>
<p>Returns the Snippet. Please note that, the same Snippet may have
multiple instances inserted at different Points or the same Point.</p>
</div>
</div>
<div class="section" id="callback-interface">
<span id="id2"></span><h2>Callback Interface<a class="headerlink" href="#callback-interface" title="Permalink to this headline"></a></h2>
<div class="section" id="patchcallback">
<span id="sec-3-2-7"></span><h3>PatchCallback<a class="headerlink" href="#patchcallback" title="Permalink to this headline"></a></h3>
<p><strong>Declared in</strong>: PatchCallback.h</p>
<p>The PatchAPI CFG layer may change at runtime due to program events
(e.g., a program loading additional code or overwriting its own code
with new code). The <code class="docutils literal notranslate"><span class="pre">PatchCallback</span></code> interface allows users to specify
callbacks they wish to occur whenever the PatchAPI CFG changes.</p>
<p>virtual void destroy_cb(PatchBlock *); virtual void
destroy_cb(PatchEdge *); virtual void destroy_cb(PatchFunction *);
virtual void destroy_cb(PatchObject *);</p>
<p>Programmers implement the above virtual methods to handle the event of
destroying a PatchBlock, a PatchEdge, a PatchFunction, or a PatchObject
respectively. All the above methods will be called before corresponding
object destructors are called.</p>
<p>virtual void create_cb(PatchBlock *); virtual void create_cb(PatchEdge
*); virtual void create_cb(PatchFunction *); virtual void
create_cb(PatchObject *);</p>
<p>Programmers implement the above virtual methods to handle the event of
creating a PatchBlock, a PatchEdge, a PatchFunction, or a PatchObject
respectively. All the above methods will be called after the objects are
created.</p>
<p>virtual void split_block_cb(PatchBlock *first, PatchBlock *second);</p>
<p>Programmers implement the above virtual method to handle the event of
splitting a PatchBlock as a result of a new edge being discovered. The
above method will be called after the block is split.</p>
<p>virtual void remove_edge_cb(PatchBlock *, PatchEdge *, edge_type_t);
virtual void add_edge_cb(PatchBlock *, PatchEdge *, edge_type_t);</p>
<p>Programmers implement the above virtual methods to handle the events of
removing or adding an PatchEdge respectively. The method remove_edge_cb
will be called before the event triggers, while the method add_edge_cb
will be called after the event triggers.</p>
<p>virtual void remove_block_cb(PatchFunction *, PatchBlock *); virtual
void add_block_cb(PatchFunction *, PatchBlock *);</p>
<p>Programmers implement the above virtual methods to handle the events of
removing or adding a PatchBlock respectively. The method remove_block_cb
will be called before the event triggers, while the method add_block_cb
will be called after the event triggers.</p>
<p>virtual void create_cb(Point *pt); virtual void destroy_cb(Point *pt);</p>
<p>Programmers implement the create_cb method above, which will be called
after the Point <em>pt</em> is created. And, programmers implement the
destroy_cb method, which will be called before the point <em>pt</em> is
deleted.</p>
<p>virtual void change_cb(Point *pt, PatchBlock *first, PatchBlock
*second);</p>
<p>Programmers implement this method, which is to be invoked after a block
is split. The provided Point belonged to the first block and is being
moved to the second.</p>
</div>
</div>
</div>
<div class="section" id="modification-api-reference">
<span id="sec-modification-api"></span><h1>Modification API Reference<a class="headerlink" href="#modification-api-reference" title="Permalink to this headline"></a></h1>
<p>This section describes the modification interface of PatchAPI. While
PatchAPI’s main goal is to allow users to insert new code into a
program, a secondary goal is to allow safe modification of the original
program code as well.</p>
<p>To modify the binary, a user interacts with the <code class="docutils literal notranslate"><span class="pre">PatchModifier</span></code> class
to manipulate a PatchAPI CFG. CFG modifications are then instantiated as
new code by the PatchAPI. For example, if PatchAPI is being used as part
of Dyninst, executing a <code class="docutils literal notranslate"><span class="pre">finalizeInsertionSet</span></code> will generate modified
code.</p>
<p>The three key benefits of the PatchAPI modification interface are
abstraction, safety, and interactivity. We use the CFG as a mechanism
for transforming binaries in a platform-independent way that requires no
instruction-level knowledge by the user. These transformations are
limited to ensure that the CFG can always be used to instantiate code,
and thus the user can avoid unintended side-effects of modification.
Finally, modifications to the CFG are represented in that CFG, allowing
users to iteratively combine multiple CFG transformations to achieve
their goals.</p>
<p>Since modification can modify the CFG, it may invalidate any analyses
the user has performed over the CFG. We suggest that users take
advantage of the callback interface described in Section
<a class="reference external" href="#sec-3.2.7">4.3.1</a> to update any such analysis information.</p>
<p>The PatchAPI modification capabilities are currently in beta; if you
experience any problems or bugs, please contact <code class="docutils literal notranslate"><span class="pre">bugs&#64;dyninst.org</span></code>.</p>
<p>Many of these methods return a boolean type; true indicates a successful
operation, and false indicates a failure. For methods that return a
pointer, a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> return value indicates a failure.</p>
<p>bool redirect(PatchEdge *edge, PatchBlock *target);</p>
<p>Redirects the edge specified by <code class="docutils literal notranslate"><span class="pre">edge</span></code> to a new target specified by
<code class="docutils literal notranslate"><span class="pre">target</span></code>. In the current implementation, the edge may not be indirect.</p>
<p>PatchBlock *split(PatchBlock *orig, Address addr, bool trust = false,
Address newlast = (Address) -1);</p>
<p>Splits the block specified by <code class="docutils literal notranslate"><span class="pre">orig</span></code>, creating a new block starting at
<code class="docutils literal notranslate"><span class="pre">addr</span></code>. If <code class="docutils literal notranslate"><span class="pre">trust</span></code> is true, we do not verify that <code class="docutils literal notranslate"><span class="pre">addr</span></code> is a
valid instruction address; this may be useful to reduce overhead. If
<code class="docutils literal notranslate"><span class="pre">newlast</span></code> is not -1, we use it as the last instruction address of the
first block. All Points are updated to belong to the appropriate block.
The second block is returned.</p>
<p>bool remove(std::vector&lt;PatchBlock *&gt; &amp;blocks, bool force = true)</p>
<p>Removes the blocks specified by <code class="docutils literal notranslate"><span class="pre">blocks</span></code> from the CFG. If <code class="docutils literal notranslate"><span class="pre">force</span></code> is
true, blocks are removed even if they have incoming edges; this may
leave the CFG in an unsafe state but may be useful for reducing
overhead.</p>
<p>bool remove(PatchFunction *func)</p>
<p>Removes <code class="docutils literal notranslate"><span class="pre">func</span></code> and all of its non-shared blocks from the CFG; any
shared blocks remain.</p>
<p>class InsertedCode typedef boost::shared_ptr&lt;…&gt; Ptr; PatchBlock
*entry(); const std::vector&lt;PatchEdge *&gt; &amp;exits(); const
std::set&lt;PatchBlock *&gt; &amp;blocks();</p>
<p>InsertedCode::Ptr insert(PatchObject *obj, SnippetPtr snip, Point
*point); InsertedCode::Ptr insert(PatchObject *obj, void *start,
unsigned size);</p>
<p>Methods for inserting new code into a CFG. The <code class="docutils literal notranslate"><span class="pre">InsertedCode</span></code>
structure represents a CFG subgraph generated by inserting new code; the
graph has a single entry point and multiple exits, represented by edges
to the sink node. The first <code class="docutils literal notranslate"><span class="pre">insert</span></code> call takes a PatchAPI Snippet
structure and a Point that is used to generate that Snippet; the point
is only passed through to the snippet code generator and thus may be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the snippet does not use Point information. The second
<code class="docutils literal notranslate"><span class="pre">insert</span></code> call takes a raw code buffer.</p>
</div>
<div class="section" id="plugin-api-reference">
<span id="sec-plugin-api"></span><h1>Plugin API Reference<a class="headerlink" href="#plugin-api-reference" title="Permalink to this headline"></a></h1>
<p>This section describes the various plugin interfaces for extending
PatchAPI. We expect that most users should not have to ever explicitly
use an interface from this section; instead, they will use plugins
previously implemented by PatchAPI developers.</p>
<p>As with the public interface, all objects and methods in this section
are in the “Dyninst::PatchAPI” namespace.</p>
<div class="section" id="addrspace">
<span id="sec-3-2-1"></span><h2>AddrSpace<a class="headerlink" href="#addrspace" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: AddrSpace.h</p>
<p>The AddrSpace class represents the address space of a <strong>Mutatee</strong>, where
it contains a collection of <strong>PatchObjects</strong> that represent shared
libraries or a binary executable. In addition, programmers implement
some memory management interfaces in the AddrSpace class to determine
the type of the code patching - 1st party, 3rd party, or binary
rewriting.</p>
<p>virtual bool write(PatchObject* obj, Address to, Address from, size_t
size);</p>
<p>This method copies <em>size</em>-byte data stored at the address <em>from</em> on the
<strong>Mutator</strong> side to the address <em>to</em> on the <strong>Mutatee</strong> side. The
parameter <em>to</em> is the relative offset for the PatchObject <em>obj</em>, if the
instrumentation is for binary rewriting; otherwise <em>to</em> is an absolute
address.</p>
<p>If the write operation succeeds, this method returns true; otherwise,
false.</p>
<p>virtual Address malloc(PatchObject* obj, size_t size, Address near);</p>
<p>This method allocates a buffer of <em>size</em> bytes on the <strong>Mutatee</strong> side.
The address <em>near</em> is a relative address in the object <em>obj</em>, if the
instrumentation is for binary rewriting; otherwise, <em>near</em> is an
absolute address, where this method tries to allocate a buffer near the
address <em>near</em>.</p>
<p>If this method succeeds, it returns a non-zero address; otherwise, it
returns 0.</p>
<p>virtual Address realloc(PatchObject* obj, Address orig, size_t size);</p>
<p>This method reallocates a buffer of <em>size</em> bytes on the <strong>Mutatee</strong>
side. The original buffer is at the address <em>orig</em>. This method tries to
reallocate the buffer near the address <em>orig</em>, where <em>orig</em> is a
relative address in the PatchObject <em>obj</em> if the instrumentation is for
binary rewriting; otherwise, <em>orig</em> is an absolute address.</p>
<p>If this method succeeds, it returns a non-zero address; otherwise, it
returns 0.</p>
<p>virtual bool free(PatchObject* obj, Address orig);</p>
<p>This method deallocates a buffer on the <strong>Mutatee</strong> side at the address
<em>orig</em>. If the instrumentation is for binary rewriting, then the
parameter <em>orig</em> is a relative address in the object <em>obj</em>; otherwise,
<em>orig</em> is an absolute address.</p>
<p>If this method succeeds, it returns true; otherwise, it returns false.</p>
<p>virtual bool loadObject(PatchObject* obj);</p>
<p>This method loads a PatchObject into the address space. If this method
succeeds, it returns true; otherwise, it returns false.</p>
<p>typedef std::map&lt;const ParseAPI::CodeObject*, PatchObject*&gt;
AddrSpace::ObjMap;</p>
<p>ObjMap&amp; objMap();</p>
<p>Returns a set of mappings from ParseAPI::CodeObjects to PatchObjects,
where PatchObjects in all mappings represent all binary objects (either
executable or libraries loaded) in this address space.</p>
<p>PatchObject* executable();</p>
<p>Returns the PatchObject of the executable of the <strong>Mutatee</strong>.</p>
<p>PatchMgrPtr mgr();</p>
<p>Returns the PatchMgr’s pointer, where the PatchMgr contains this address
space.</p>
</div>
<div class="section" id="snippet">
<span id="sec-3-2-2"></span><h2>Snippet<a class="headerlink" href="#snippet" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Snippet.h</p>
<p>The Snippet class allows programmers to customize their own snippet
representation and the corresponding mini-compiler to translate the
representation into the binary code.</p>
<p>static Ptr create(Snippet* a);</p>
<p>Creates an object of the Snippet.</p>
<p>virtual bool generate(Point *pt, Buffer &amp;buf);</p>
<p>Users should implement this virtual function for generating binary code
for the snippet.</p>
<p>Returns false if code generation failed catastrophically. Point <em>pt</em> is
an in-param that identifies where the snippet is being generated. Buffer
<em>buf</em> is an out-param that holds the generated code.</p>
</div>
<div class="section" id="command">
<span id="sec-3-2-3"></span><h2>Command<a class="headerlink" href="#command" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The Command class represents an instrumentation request (e.g., snippet
insertion or removal), or an internal logical step in the code patching
(e.g., install instrumentation).</p>
<p>virtual bool run() = 0;</p>
<p>Executes the normal operation of this Command.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>virtual bool undo() = 0;</p>
<p>Undoes the operation of this Command.</p>
<p>virtual bool commit();</p>
<p>Implements the transactional semantics: all succeed, or all fail.
Basically, it performs such logic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">run</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">undo</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="batchcommand">
<span id="sec-3-2-4"></span><h2>BatchCommand<a class="headerlink" href="#batchcommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The BatchCommand class inherits from the Command class. It is actually a
container of a list of Commands that will be executed in a transaction:
all Commands will succeed, or all will fail.</p>
<p>typedef std::list&lt;CommandPtr&gt; CommandList;</p>
<p>CommandList <a href="#id6"><span class="problematic" id="id7">to_do_</span></a>; CommandList <a href="#id8"><span class="problematic" id="id9">done_</span></a>;</p>
<p>This class has two protected members <em>to_do_</em> and <em>done_</em>, where
<em>to_do_</em> is a list of Commands to execute, and <em>done_</em> is a list of
Commands that are executed.</p>
<p>virtual bool run(); virtual bool undo();</p>
<p>The method run() of BatchCommand invokes the run() method of each
Command in <em>to_do_</em> in order, and puts the finished Commands in
<em>done_</em>. The method undo() of BatchCommand invokes the undo() method of
each Command in <em>done _</em> in order.</p>
<p>void add(CommandPtr command);</p>
<p>This method adds a Command into <em>to_do_</em>.</p>
<p>void remove(CommandList::iterator iter);</p>
<p>This method removes a Command from <em>to_do_</em>.</p>
</div>
<div class="section" id="instrumenter">
<span id="sec-3-2-5"></span><h2>Instrumenter<a class="headerlink" href="#instrumenter" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The Instrumenter class inherits BatchCommand to encapsulate the core
code patching logic, which includes binary code generation. Instrumenter
would contain several logical steps that are individual Commands.</p>
<p>CommandList <a href="#id10"><span class="problematic" id="id11">user_commands_</span></a>;</p>
<p>This class has a protected data member <em>user_commands_</em> that contains
all Commands issued by users, e.g., snippet insertion. This is to
facilitate the implementation of the instrumentation engine.</p>
<p>static InstrumenterPtr create(AddrSpacePtr as);</p>
<p>Returns an instance of Instrumenter, and it takes input the address
space <em>as</em> that is going to be instrumented.</p>
<p>virtual bool replaceFunction(PatchFunction* oldfunc, PatchFunction*
newfunc);</p>
<p>Replaces a function <em>oldfunc</em> with a new function <em>newfunc</em>.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>virtual bool revertReplacedFunction(PatchFunction* oldfunc);</p>
<p>Undoes the function replacement for <em>oldfunc</em>.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>typedef std::map&lt;PatchFunction*, PatchFunction*&gt; FuncModMap;</p>
<p>The type FuncModMap contains mappings from an PatchFunction to another
PatchFunction.</p>
<p>virtual FuncModMap&amp; funcRepMap();</p>
<p>Returns the FuncModMap that contains a set of mappings from an old
function to a new function, where the old function is replaced by the
new function.</p>
<p>virtual bool wrapFunction(PatchFunction* oldfunc, PatchFunction*
newfunc, string name);</p>
<p>Replaces all calls to <em>oldfunc</em> with calls to wrapper <em>newfunc</em> (similar
to function replacement). However, we create a copy of original using
the <em>name</em> that can be used to call the original. The wrapper code would
look like follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span><span class="n">malloc_wrapper</span><span class="p">(</span><span class="nb">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">do</span> <span class="n">stuff</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">malloc_clone</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="o">//</span> <span class="n">do</span> <span class="n">more</span> <span class="n">stuff</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This interface requires the user to give us a name (as represented by
clone) for the original function. This matches current techniques and
allows users to use indirect calls (function pointers).</p>
<p>virtual bool revertWrappedFunction(PatchFunction* oldfunc);</p>
<p>Undoes the function wrapping for <em>oldfunc</em>.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>virtual FuncModMap&amp; funcWrapMap();</p>
<p>The type FuncModMap contains mappings from the original PatchFunction to
the wrapper PatchFunction.</p>
<p>bool modifyCall(PatchBlock *callBlock, PatchFunction *newCallee,
PatchFunction *context = NULL);</p>
<p>Replaces the function that is invoked in the basic block <em>callBlock</em>
with the function <em>newCallee</em>. There may be multiple functions
containing the same <em>callBlock</em>, so the <em>context</em> parameter specifies in
which function the <em>callBlock</em> should be modified. If <em>context</em> is NULL,
then the <em>callBlock</em> would be modified in all PatchFunctions that
contain it. If the <em>newCallee</em> is NULL, then the <em>callBlock</em> is removed.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>bool revertModifiedCall(PatchBlock *callBlock, PatchFunction *context
= NULL);</p>
<p>Undoes the function call modification for <em>oldfunc</em>. There may be
multiple functions containing the same <em>callBlock</em>, so the <em>context</em>
parameter specifies in which function the <em>callBlock</em> should be
modified. If <em>context</em> is NULL, then the <em>callBlock</em> would be modified
in all PatchFunctions that contain it.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>bool removeCall(PatchBlock *callBlock, PatchFunction *context = NULL);</p>
<p>Removes the <em>callBlock</em>, where a function is invoked. There may be
multiple functions containing the same <em>callBlock</em>, so the <em>context</em>
parameter specifies in which function the <em>callBlock</em> should be
modified. If <em>context</em> is NULL, then the <em>callBlock</em> would be modified
in all PatchFunctions that contain it.</p>
<p>It returns true on success; otherwise, it returns false.</p>
<p>typedef map&lt;PatchBlock*, // B : A call block map&lt;PatchFunction*, // F_c:
Function context PatchFunction*&gt; // F : The function to be replaced &gt;
CallModMap;</p>
<p>The type CallModMap maps from B -&gt; F<span class="math notranslate nohighlight">\(_c\)</span> -&gt; F, where B
identifies a call block, and F<span class="math notranslate nohighlight">\(_c\)</span> identifies an (optional)
function context for the replacement. If F<span class="math notranslate nohighlight">\(_c\)</span> is not specified,
we use NULL. F specifies the replacement callee; if we want to remove
the call entirely, we use NULL.</p>
<p>CallModMap&amp; callModMap();</p>
<p>Returns the CallModMap for function call replacement / removal.</p>
<p>AddrSpacePtr as() const;</p>
<p>Returns the address space associated with this Instrumenter.</p>
</div>
<div class="section" id="patcher">
<span id="sec-3-2-6"></span><h2>Patcher<a class="headerlink" href="#patcher" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class Patcher inherits from the class BatchCommand. It accepts
instrumentation requests from users, where these instrumentation
requests are Commands (e.g., snippet insertion). Furthermore, Patcher
implicitly adds an instance of Instrumenter to the end of the Command
list to generate binary code and install the instrumentation.</p>
<p>Patcher(PatchMgrPtr mgr)</p>
<p>The constructor of Patcher takes input the relevant PatchMgr <em>mgr</em>.</p>
<p>virtual bool run();</p>
<p>Performs the same logic as BatchCommand::run(), except that this
function implicitly adds an internal Command – Instrumenter, which is
executed after all other Commands in the <em>to_do_</em>.</p>
</div>
<div class="section" id="cfgmaker">
<span id="id3"></span><h2>CFGMaker<a class="headerlink" href="#cfgmaker" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: CFGMaker.h</p>
<p>The CFGMaker class is a factory class that constructs the above CFG
structures (PatchFunction, PatchBlock, and PatchEdge). The methods in
this class are used by PatchObject. Programmers can extend
PatchFunction, PatchBlock and PatchEdge by annotating their own data,
and then use this class to instantiate these CFG structures.</p>
<p>virtual PatchFunction* makeFunction(ParseAPI::Function* func,
PatchObject* obj); virtual PatchFunction* copyFunction(PatchFunction*
func, PatchObject* obj);</p>
<p>virtual PatchBlock* makeBlock(ParseAPI::Block* blk, PatchObject*
obj); virtual PatchBlock* copyBlock(PatchBlock* blk, PatchObject*
obj);</p>
<p>virtual PatchEdge* makeEdge(ParseAPI::Edge* edge, PatchBlock* src,
PatchBlock* trg, PatchObject* obj); virtual PatchEdge*
copyEdge(PatchEdge* edge, PatchObject* obj);</p>
<p>Programmers implement the above virtual methods to instantiate a CFG
structure (either a PatchFunction, a PatchBlock, or a PatchEdge) or to
copy (e.g., when forking a new process).</p>
</div>
<div class="section" id="pointmaker">
<span id="id4"></span><h2>PointMaker<a class="headerlink" href="#pointmaker" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Point.h</p>
<p>The PointMaker class is a factory class that constructs instances of the
Point class. The methods of the PointMaker class are invoked by
PatchMgr’s findPoint methods. Programmers can extend the Point class,
and then implement a set of virtual methods in this class to instantiate
the subclasses of Point.</p>
<p>PointMaker(PatchMgrPtr mgr);</p>
<p>The constructor takes input the relevant PatchMgr <em>mgr</em>.</p>
<p>virtual Point *mkFuncPoint(Point::Type t, PatchMgrPtr m, PatchFunction
*f); virtual Point *mkFuncSitePoint(Point::Type t, PatchMgrPtr m,
PatchFunction *f, PatchBlock *b); virtual Point
*mkBlockPoint(Point::Type t, PatchMgrPtr m, PatchBlock *b,
PatchFunction *context); virtual Point *mkInsnPoint(Point::Type t,
PatchMgrPtr m, PatchBlock *, Address a,
InstructionAPI::Instruction::Ptr i, PatchFunction *context); virtual
Point *mkEdgePoint(Point::Type t, PatchMgrPtr m, PatchEdge *e,
PatchFunction *context);</p>
<p>Programmers implement the above virtual methods to instantiate the
subclasses of Point.</p>
</div>
<div class="section" id="default-plugin">
<span id="sec-3-3"></span><h2>Default Plugin<a class="headerlink" href="#default-plugin" title="Permalink to this headline"></a></h2>
</div>
<div class="section" id="pushfrontcommand-and-pushbackcommand">
<span id="sec-3-3-1"></span><h2>PushFrontCommand and PushBackCommand<a class="headerlink" href="#pushfrontcommand-and-pushbackcommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class PushFrontCommand and the class PushBackCommand inherit from
the Command class. They are to insert a snippet to a point. A point
maintains a list of snippet instances. PushFrontCommand would add the
new snippet instance to the front of the list, while PushBackCommand
would add to the end of the list.</p>
<p>static Ptr create(Point* pt, SnippetPtr snip);</p>
<p>This static method creates an object of PushFrontCommand or
PushBackCommand.</p>
<p>InstancePtr instance();</p>
<p>Returns a snippet instance that is inserted at the point.</p>
</div>
<div class="section" id="removesnippetcommand">
<span id="sec-3-3-2"></span><h2>RemoveSnippetCommand<a class="headerlink" href="#removesnippetcommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class RemoveSnippetCommand inherits from the Command class. It is to
delete a snippet Instance.</p>
<p>static Ptr create(InstancePtr instance);</p>
<p>This static function creates an instance of RemoveSnippetCommand.</p>
</div>
<div class="section" id="removecallcommand">
<span id="sec-3-3-3"></span><h2>RemoveCallCommand<a class="headerlink" href="#removecallcommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class RemoveCallCommand inherits from the class Command. It is to
remove a function call.</p>
<p>static Ptr create(PatchMgrPtr mgr, PatchBlock* call_block,
PatchFunction* context = NULL);</p>
<p>This static method takes input the relevant PatchMgr <em>mgr</em>, the
<em>call_block</em> that contains the function call to be removed, and the
PatchFunction <em>context</em>. There may be multiple PatchFunctions containing
the same <em>call_block</em>. If the <em>context</em> is NULL, then the <em>call_block</em>
would be deleted from all PatchFunctions that contains it; otherwise,
the <em>call_block</em> would be deleted only from the PatchFuncton <em>context</em>.</p>
</div>
<div class="section" id="replacecallcommand">
<span id="sec-3-3-4"></span><h2>ReplaceCallCommand<a class="headerlink" href="#replacecallcommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class ReplaceCallCommand inherits from the class Command. It is to
replace a function call with another function.</p>
<p>static Ptr create(PatchMgrPtr mgr, PatchBlock* call_block,
PatchFunction* new_callee, PatchFunction* context);</p>
<p>This Command replaces the <em>call_block</em> with the new PatchFunction
<em>new_callee</em>. There may be multiple functions containing the same
<em>call_block</em>, so the <em>context</em> parameter specifies in which function the
<em>call_block</em> should be replaced. If <em>context</em> is NULL, then the
<em>call_block</em> would be replaced in all PatchFunctions that contains it.</p>
</div>
<div class="section" id="replacefunccommand">
<span id="sec-3-3-5"></span><h2>ReplaceFuncCommand<a class="headerlink" href="#replacefunccommand" title="Permalink to this headline"></a></h2>
<p><strong>Declared in</strong>: Command.h</p>
<p>The class ReplaceFuncCommand inherits from the class Command. It is to
replace an old function with the new one.</p>
<p>static Ptr create(PatchMgrPtr mgr, PatchFunction* old_func,
PatchFunction* new_func);</p>
<p>This Command replaces the old PatchFunction <em>old_func</em> with the new
PatchFunction <em>new_func</em>.</p>
</div>
</div>
<div class="section" id="patchapi-for-dyninst-programmers">
<span id="sec-dyn"></span><h1>PatchAPI for Dyninst Programmers<a class="headerlink" href="#patchapi-for-dyninst-programmers" title="Permalink to this headline"></a></h1>
<p>The PatchAPI is a Dyninst component and as such is accessible through
the main Dyninst interface (BPatch objects). However, the PatchAPI
instrumentation and CFG models differ from the Dyninst models in several
critical ways that should be accounted for by users. This section
summarizes those differences and describes how to access PatchAPI
abstractions from the DyninstAPI interface.</p>
<div class="section" id="differences-between-dyninstapi-and-patchapi">
<h2>Differences Between DyninstAPI and PatchAPI<a class="headerlink" href="#differences-between-dyninstapi-and-patchapi" title="Permalink to this headline"></a></h2>
<p>The DyninstAPI and PatchAPI differ primarily in their CFG
representations and instrumentation point abstractions. In general,
PatchAPI is more powerful and can better represent complex binaries
(e.g., highly optimized code or malware). In order to maintain backwards
compatibility, the DyninstAPI interface has not been extended to match
the PatchAPI. As a result, there are some caveats.</p>
<p>The PatchAPI uses the same CFG model as the ParseAPI. The primary
representation is an interprocedural graph of basic blocks and edges.
Functions are defined on top of this graph as collections of blocks. <strong>A
block may be contained by more than one function;</strong> we call this the
<em>shared block</em> model. Functions are defined to have a single entry
block, and functions may overlap if they contain the same blocks. Call
and return edges exist in the graph, and therefore traversing the graph
may enter different functions. PatchAPI users may specify instrumenting
a particular block within a particular function (a <em>block instance</em>) by
specifying both the block and the function.</p>
<p>The DyninstAPI uses a historic CFG model. The primary representation is
the function. Functions contain a intraprocedural graph of blocks and
edges. As a result, a basic block belongs to only one function, but two
blocks from different functions may be <em>clones</em> of each other. No
interprocedural edges are represented in the graph, and thus traversing
the CFG from a particular function is guaranteed to remain inside that
function.</p>
<p>As a result, multiple DyninstAPI blocks may map to the same PatchAPI
block. If instrumenting a particular block instance is desired, the user
should provide both the DyninstAPI basic block and function.</p>
<p>In addition, DyninstAPI uses a <em>module</em> abstraction, where a
<code class="docutils literal notranslate"><span class="pre">BPatch_module</span></code> represents a collection of functions from a particular
source file (for the executable) or from an entire library (for all
libraries). PatchAPI, like ParseAPI, instead uses an <em>object</em>
representation, where a <code class="docutils literal notranslate"><span class="pre">PatchObject</span></code> object represents a collection
of functions from a file on disk (executable or libraries).</p>
<p>The instrumentation point (<em>instPoint</em>) models also differ between
DyninstAPI and PatchAPI. We classify an instPoint either as a <em>behavior</em>
point (e.g., function entry) or <em>location</em> point (e.g., a particular
instruction). PatchAPI fully supports both of these models, with the
added extension that a location point explicitly specifies whether
instrumentation will execute before or after the corresponding location.
Dyninst does not support the behavior model, instead mapping behavior
instPoints to a corresponding instruction. For example, if a user
requests a function entry instPoint they instead receive an instPoint
for the first instruction in the function. These may not always be the
same (see
<a class="reference external" href="ftp://ftp.cs.wisc.edu/paradyn/papers/Bernat11AWAT.pdf">Bernat_AWAT</a>).
In addition, location instPoints represent an instruction, and the user
must later specify whether they wish to instrument before or after that
instruction.</p>
<p>As a result, there are complications for using both DyninstAPI and
PatchAPI. We cannot emphasize enough, though, that users <em>can combine
DyninstAPI and PatchAPI</em> with some care. Doing so offers several
benefits:</p>
<ul class="simple">
<li>The ability to extend legacy code that is written for DyninstAPI.</li>
<li>The ability to use the DyninstAPI extensions and plugins for
PatchAPI, including snippet-based or dynC-based code generation and
our instrumentation optimizer.</li>
</ul>
<p>We suggest the following best practices to be followed when coding for
PatchAPI via Dyninst:</p>
<ul class="simple">
<li>For legacy code, do not attempt to map between DyninstAPI instPoints
and PatchAPI instPoints. Instead, use DyninstAPI CFG objects to
acquire PatchAPI CFG objects, and use a <code class="docutils literal notranslate"><span class="pre">PatchMgr</span></code> (acquired
through a <code class="docutils literal notranslate"><span class="pre">BPatch_addressSpace</span></code>) to look up PatchAPI instPoints.</li>
<li>For new code, acquire a <code class="docutils literal notranslate"><span class="pre">PatchMgr</span></code> directly from a
<code class="docutils literal notranslate"><span class="pre">BPatch_addressSpace</span></code> and use its methods to look up both CFG
objects and instPoints.</li>
</ul>
</div>
<div class="section" id="patchapi-accessor-methods-in-dyninst">
<h2>PatchAPI accessor methods in Dyninst<a class="headerlink" href="#patchapi-accessor-methods-in-dyninst" title="Permalink to this headline"></a></h2>
<p>To access a PatchAPI class from a Dyninst class, use the
<code class="docutils literal notranslate"><span class="pre">PatchAPI::convert</span></code> function, as in the following example:</p>
<p>BPatch_basicBlock *bp_block = …; PatchAPI::PatchBlock *block =
PatchAPI::convert(bp_block);</p>
<p>We support the following mappings, where all PatchAPI objects are within
the <code class="docutils literal notranslate"><span class="pre">Dyninst::PatchAPI</span></code> namespace:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">From</th>
<th class="head">To</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">BPatch_function</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchFunction</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">BPatch_basicBlock</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchBlock</span></code></td>
<td>See above.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">BPatch_edge</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchEdge</span></code></td>
<td>See above.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">BPatch_module</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchObject</span></code></td>
<td>See above.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">BPatch_image</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchMgr</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">BPatch_addressSpace</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">PatchMgr</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">BPatch_snippet</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">Snippet</span></code></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>We do not support a direct mapping between <code class="docutils literal notranslate"><span class="pre">BPatch_point</span></code>s and
<code class="docutils literal notranslate"><span class="pre">Point</span></code>s, as the failure of Dyninst to properly represent behavior
instPoints leads to confusing results. Instead, use the PatchAPI point
lookup methods.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Command_pattern">http://en.wikipedia.org/wiki/Command_pattern</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../parseAPI/index.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../stackwalk/index.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>