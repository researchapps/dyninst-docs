<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/stackwalk/3-API.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="api-reference">
<span id="sec-api"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline"></a></h1>
<p>This section describes the StackwalkerAPI interface. It is divided into
three sub-sections: a description of the definitions and basic types
used by this API, a description of the interface for collecting
stackwalks, and a description of the callback interface.</p>
<div class="section" id="definitions-and-basic-types">
<h2>Definitions and Basic Types<a class="headerlink" href="#definitions-and-basic-types" title="Permalink to this headline"></a></h2>
<p>The following definitions and basic types are referenced throughout the
rest of this manual.</p>
<div class="section" id="definitions">
<span id="subsec-definitions"></span><h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline"></a></h3>
<dl class="docutils">
<dt>Stack Frame</dt><dd>A stack frame is a record of a function (or function-like object)
invocation. When a function is executed, it may create a frame on the
call stack. StackwalkerAPI finds stack frames and returns a
description of them when it walks a call stack. The following three
definitions deal with stack frames.</dd>
<dt>Bottom of the Stack</dt><dd>The bottom of the stack is the earliest stack frame in a call stack,
usually a thread’s initial function. The stack grows from bottom to
the top.</dd>
<dt>Top of the Stack</dt><dd>The top of the stack is the most recent stack frame in a call stack.
The stack frame at the top of the stack is for the currently
executing function.</dd>
<dt>Frame Object</dt><dd>A Frame object is StackwalkerAPI’s representation of a stack frame. A
Frame object is a snapshot of a stack frame at a specific point in
time. Even if a stack frame changes as a process executes, a Frame
object will remain the same. Each Frame object is represented by an
instance of the Frame class.</dd>
</dl>
<p>The following three definitions deal with fields in a Frame object.</p>
<dl class="docutils">
<dt>SP (Stack Pointer)</dt><dd>A Frame object’s SP member points to the top of its stack frame (a
stack frame grows from bottom to top, similar to a call stack). The
Frame object for the top of the stack has a SP that is equal to the
value in the stack pointer register at the time the Frame object was
created. The Frame object for any other stack frame has a SP that is
equal to the top address in the stack frame.</dd>
<dt>FP (Frame Pointer)</dt><dd>A Frame object’s FP member points to the beginning (or bottom) of its
stack frame. The Frame object for the top of the stack has a FP that
is equal to the value in the frame pointer register at the time the
Frame object was created. The Frame object for any other stack frame
has a FP that is equal to the beginning of the stack frame.</dd>
<dt>RA (Return Address)</dt><dd>A Frame object’s RA member points to the location in the code space
where control will resume when the function that created the stack
frame resumes. The Frame object for the top of the stack has a RA
that is equal to the value in the program counter register at the
time the Frame object was created. The Frame object for any other
stack frame has a RA that is found when walking a call stack.</dd>
</dl>
<p>= [rectangle, draw, minimum width=3cm, minimum height=1.5em, font=, node
distance=1.5em] = [rectangle, minimum width=3cm, draw, minimum
height=1.5em, fill=white, draw=white] = [rectangle] = [rectangle, font=]
= [draw, -latex’]</p>
<p>= [rectangle, draw, minimum width=4cm, minimum height=1.5em, font=, node
distance=1.5em] = [rectangle, minimum width=4cm, draw, minimum
height=1.5em, fill=white, draw=white] = [rectangle] = [rectangle, font=]
= [draw, -latex’]</p>
<p>Figure&nbsp;<a class="reference external" href="#fig:layout">[fig:layout]</a> shows the relationship between
application code, stack frames, and Frame objects. In the figure, the
source code on the left has run through the main and foo functions, and
into the bar function. It has created the call stack in the center,
which is shown as a sequence of words growing down. The current values
of the processor registers, while executing in bar, are shown below the
call stack. When StackwalkerAPI walks the call stack, it creates the
Frame objects shown on the right. Each Frame object corresponds to one
of the stack frames found in the call stack or application registers.</p>
<p>The call stack in Figure&nbsp;<a class="reference external" href="#fig:layout">[fig:layout]</a> is similar to
one that would be found on the x86 architecture. Details about how the
call stack is laid out may be different on other architectures, but the
meanings of the FP, SP, and RA fields in the Frame objects will remain
the same. The layout of the ARM64 stack may be found in
Figure&nbsp;<a class="reference external" href="#fig:layout-armv8">[fig:layout-armv8]</a> as an example of the
scope of architectural variations.</p>
<p>The following four definitions deal with processes involved in
StackwalkerAPI.</p>
<dl class="docutils">
<dt>Target Process</dt><dd>The process from which StackwalkerAPI is collecting stackwalks.</dd>
<dt>Host Process</dt><dd>The process in which StackwalkerAPI code is currently running.</dd>
<dt>First Party Stackwalk</dt><dd>StackwalkerAPI collects first party stackwalk when it walks a call
stack in the same address space it is running in, i.e. the target
process is the same as the host process.</dd>
<dt>Third Party Stackwalk</dt><dd>StackwalkerAPI collects third party stackwalk when it walks the call
stack in a different address space from the one it is running in,
i.e. the target process is different from the host process. A third
party stackwalk is usually done through a debugger interface.</dd>
</dl>
</div>
<div class="section" id="basic-types">
<h3>Basic Types<a class="headerlink" href="#basic-types" title="Permalink to this headline"></a></h3>
<div class="apient container">
typedef unsigned long Address</div>
<div class="apient container">
typedef … Dyninst::PID</div>
<div class="apient container">
typedef … Dyninst::THR_ID</div>
<div class="apient container">
class Dyninst::MachRegister</div>
<div class="apient container">
typedef unsigned long Dyninst::MachRegisterVal</div>
</div>
</div>
<div class="section" id="namespace-stackwalkerapi">
<h2>Namespace StackwalkerAPI<a class="headerlink" href="#namespace-stackwalkerapi" title="Permalink to this headline"></a></h2>
<p>The classes in Section&nbsp;<a class="reference external" href="#sec:stackwalking-interface">1.3</a> and
Section&nbsp;<a class="reference external" href="#sec:callback-interface">1.6</a> fall under the C++ namespace
Dyninst::Stackwalker. To access them, a user should refer to them using
the Dyninst::Stackwalker:: prefix, e.g. Dyninst::Stackwalker::Walker.
Alternatively, a user can add the C++ using keyword above any references
to StackwalkerAPI objects, e.g, using namespace Dyninst and using
namespace Stackwalker.</p>
</div>
<div class="section" id="stackwalking-interface">
<span id="sec-stackwalking-interface"></span><h2>Stackwalking Interface<a class="headerlink" href="#stackwalking-interface" title="Permalink to this headline"></a></h2>
<p>This section describes StackwalkerAPI’s interface for walking a call
stack. This interface is sufficient for walking call stacks on all the
systems and variations covered by our default callbacks.</p>
<p>To collect a stackwalk, first create new Walker object associated with
the target process via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Walker</span><span class="p">::</span><span class="n">newWalker</span><span class="p">()</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Walker</span><span class="p">::</span><span class="n">newWalker</span><span class="p">(</span><span class="n">Dyninst</span><span class="p">::</span><span class="n">PID</span> <span class="n">pid</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a Walker object has been created, a call stack can be walked with
the</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Walker</span><span class="p">::</span><span class="n">walkStack</span>
</pre></div>
</div>
<p>method. The new stack walk is returned as a vector of Frame objects.</p>
<div class="section" id="class-walker">
<span id="subsec-walker"></span><h3>Class Walker<a class="headerlink" href="#class-walker" title="Permalink to this headline"></a></h3>
<p>The class allows users to walk call stacks and query basic information
about threads in a target process. The user should create a object for
each process from which they are walking call stacks. Each object is
associated with one process, but may walk call stacks on multiple
threads within that process. The class allows users to query for the
threads available for walking, and it allows you to specify a particular
thread whose call stack should be walked. Stackwalks are returned as a
vector of Frame objects.</p>
<p>Each Walker object contains three objects:</p>
<ul class="simple">
<li>ProcessState</li>
<li>StepperGroup</li>
<li>SymbolLookup</li>
</ul>
<p>These objects are part of the Callback Interface and can be used to
customize StackwalkerAPI. The object tells how to access data in the
target process, and it determines whether this collects first party or
third party stackwalks. will pick an appropriate default object based on
which factory method the users calls. The object is used to customize
how the steps through stack frames. The object is used to customize how
StackwalkerAPI looks up symbolic names of the function or object that
created a stack frame.</p>
<div class="apient container">
static Walker *newWalker() static Walker *newWalker(Dyninst::PID
pid) static Walker *newWalker(Dyninst::PID pid, std::string
executable) static Walker
*newWalker(Dyninst::ProcControlAPI::Process::ptr proc); static
Walker *newWalker(std::string executable, const
std::vector&lt;std::string&gt; &amp;argv) static Walker
*newWalker(ProcessState *proc, StepperGroup *steppergroup = NULL ,
SymbolLookup *lookup = NULL)</div>
<div class="apient container">
static bool newWalker(const std::vector&lt;Dyninst::PID&gt; &amp;pids,
std::vector&lt;Walker *&gt; &amp;walkers_out) static bool newWalker(const
std::vector&lt;Dyninst::PID&gt; &amp;pids, std::vector&lt;Walker *&gt; &amp;walkers_out,
std::string executable)</div>
<div class="apient container">
bool walkStack(std::vector&lt;Frame&gt; &amp;stackwalk, Dyninst::THR_ID thread
= NULL_THR_ID)</div>
<div class="apient container">
bool walkStackFromFrame(std::vector&lt;Frame&gt; &amp;stackwalk, const Frame
&amp;frame)</div>
<div class="apient container">
bool walkSingleFrame(const Frame &amp;in, Frame &amp;out)</div>
<div class="apient container">
bool getInitialFrame(Frame &amp;frame, Dyninst::THR_ID thread =
NULL_THR_ID)</div>
<div class="apient container">
bool getAvailableThreads(std::vector&lt;Dyninst::THR_ID&gt; &amp;threads)</div>
<div class="apient container">
ProcessState *getProcessState() const</div>
<div class="apient container">
StepperGroup *getStepperGroup() const</div>
<div class="apient container">
SymbolLookup *getSymbolLookup() const</div>
<div class="apient container">
bool addStepper(FrameStepper *stepper)</div>
<div class="apient container">
static SymbolReaderFactory *getSymbolReader()</div>
<div class="apient container">
static void setSymbolReader(SymbolReaderFactory *);</div>
<div class="apient container">
static void version(int &amp;major, int &amp;minor, int &amp;maintenance)</div>
</div>
<div class="section" id="class-frame">
<span id="subsec-frame"></span><h3>Class Frame<a class="headerlink" href="#class-frame" title="Permalink to this headline"></a></h3>
<p>The class returns a call stack as a vector of objects. As described in
Section&nbsp;<a class="reference external" href="#subsec:definitions">1.1.1</a>, each Frame object represents a
stack frame, and contains a return address (RA), stack pointer (SP) and
frame pointer (FP). For each of these values, optionally, it stores the
location where the values were found. Each Frame object may also be
augmented with symbol information giving a function name (or a symbolic
name, in the case of non-functions) for the object that created the
stack frame.</p>
<p>The Frame class provides a set of functions (getRALocation,
getSPLocation and getFPLocation) that return the location in the target
process’ memory or registers where the RA, SP, or FP were found. These
functions may be used to modify the stack. For example, the DyninstAPI
uses these functions to change return addresses on the stack when it
relocates code. The RA, SP, and FP may be found in a register or in a
memory address on a call stack.</p>
<div class="apient container">
static Frame *newFrame(Dyninst::MachRegisterVal ra,
Dyninst::MachRegisterVal sp, Dyninst::MachRegisterVal fp, Walker
*walker)</div>
<div class="apient container">
bool operator==(const Frame &amp;)</div>
<div class="apient container">
Dyninst::MachRegisterVal getRA() const</div>
<div class="apient container">
void setRA(Dyninst::MachRegisterVal val)</div>
<div class="apient container">
Dyninst::MachRegisterVal getSP() const</div>
<div class="apient container">
void setSP(Dyninst::MachRegisterVal val)</div>
<div class="apient container">
Dyninst::MachRegisterVal getFP() const</div>
<div class="apient container">
void setFP(Dyninst::MachRegisterVal val)</div>
<div class="apient container">
bool isTopFrame() const; bool isBottomFrame() const;</div>
<div class="apient container">
typedef enum loc_address, loc_register, loc_unknown storage_t;</div>
<div class="apient container">
typedef struct union Dyninst::Address addr; Dyninst::MachRegister
reg; val; storage_t location; location_t;</div>
<div class="apient container">
location_t getRALocation() const</div>
<div class="apient container">
void setRALocation(location_t newval)</div>
<div class="apient container">
location_t getSPLocation() const</div>
<div class="apient container">
void setSPLocation(location_t newval)</div>
<div class="apient container">
location_t getFPLocation() const</div>
<div class="apient container">
void setFPLocation(location_t newval)</div>
<div class="apient container">
bool getName(std::string &amp;str) const</div>
<div class="apient container">
bool getObject(void* &amp;obj) const</div>
<div class="apient container">
Walker *getWalker() const;</div>
<div class="apient container">
THR_ID getThread() const;</div>
<div class="apient container">
FrameStepper* getStepper() const</div>
<div class="apient container">
bool getLibOffset(std::string &amp;lib, Dyninst::Offset &amp;offset, void*
&amp;symtab) const</div>
<div class="apient container">
bool nonCall() const</div>
</div>
</div>
<div class="section" id="mapping-addresses-to-libraries">
<h2>Mapping Addresses to Libraries<a class="headerlink" href="#mapping-addresses-to-libraries" title="Permalink to this headline"></a></h2>
<p>StackwalkerAPI provides an interface to access the addresses where
libraries are mapped in the target process.</p>
<div class="apient container">
typedef std::pair&lt;std::string, Address&gt; LibAddrPair;</div>
<div class="apient container">
class LibraryState</div>
<div class="apient container">
virtual bool getLibraryAtAddr(Address addr, LibAddrPair &amp;lib) = 0;</div>
<div class="apient container">
virtual bool getLibraries(std::vector&lt;LibAddrPair&gt; &amp;libs, bool
allow_refresh = true) = 0;</div>
<div class="apient container">
virtual bool getLibc(LibAddrPair &amp;lc);</div>
<div class="apient container">
virtual bool getLibthread(LibAddrPair &amp;lt);</div>
<div class="apient container">
virtual bool getAOut(LibAddrPair &amp;ao) = 0;</div>
</div>
<div class="section" id="accessing-local-variables">
<h2>Accessing Local Variables<a class="headerlink" href="#accessing-local-variables" title="Permalink to this headline"></a></h2>
<p>StackwalkerAPI can be used to access local variables found in the frames
of a call stack. The StackwalkerAPI interface for accessing the values
of local variables is closely tied to the SymtabAPI interface for
collecting information about local variables–SymtabAPI handles for
functions, local variables, and types are part of this interface.</p>
<p>Given an initial handle to a SymtabAPI Function object, SymtabAPI can
look up local variables contained in that function and the types of
those local variables. See the SymtabAPI Programmer’s Guide for more
information.</p>
<div class="apient container">
static Dyninst::SymtabAPI::Function *getFunctionForFrame(Frame f)</div>
<div class="apient container">
static int glvv_Success = 0; static int glvv_EParam = -1; static int
glvv_EOutOfScope = -2; static int glvv_EBufferSize = -3; static int
glvv_EUnknown = -4;</div>
<div class="apient container">
static int getLocalVariableValue(Dyninst::SymtabAPI::localVar *var,
std::vector&lt;Frame&gt; &amp;swalk, unsigned frame, void *out_buffer,
unsigned out_buffer_size)</div>
</div>
<div class="section" id="callback-interface">
<span id="sec-callback-interface"></span><h2>Callback Interface<a class="headerlink" href="#callback-interface" title="Permalink to this headline"></a></h2>
<p>This subsection describes the Callback Interface for StackwalkerAPI. The
Callback Interface is primarily used to port StackwalkerAPI to new
platforms, extend support for new types of stack frames, or integrate
StackwalkerAPI into existing tools.</p>
<p>The classes in this subsection are interfaces, they cannot be
instantiated. To create a new implementation of one of these interfaces,
create a new class that inherits from the callback class and implement
the necessary methods. To use a new ProcessState, StepperGroup, or
SymbolLookup class with StackwalkerAPI, create a new instance of the
class and register it with a new Walker object using the</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Walker</span><span class="p">::</span><span class="n">newWalker</span><span class="p">(</span><span class="n">ProcessState</span> <span class="o">*</span><span class="p">,</span> <span class="n">StepperGroup</span> <span class="o">*</span><span class="p">,</span> <span class="n">SymbolLookup</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>factory method (see Section&nbsp;<a class="reference external" href="#subsec:walker">1.3.1</a>). To use a new
FrameStepper class with StackwalkerAPI, create a new instance of the
class and register it with a StepperGroup using the</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">StepperGroup</span><span class="p">::</span><span class="n">addStepper</span><span class="p">(</span><span class="n">FrameStepper</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>method (see Section&nbsp;<a class="reference external" href="#subsec:steppergroup">1.6.3</a>).</p>
<p>Some of the classes in the Callback Interface have methods with default
implementations. A new class that inherits from a Callback Interface can
optionally implement these methods, but it is not required. If a method
requires implementation, it is written as a C++ pure virtual method ().
A method with a default implementation is written as a C++ virtual
method ().</p>
<div class="section" id="default-implementations">
<span id="subsec-defaults"></span><h3>Default Implementations<a class="headerlink" href="#default-implementations" title="Permalink to this headline"></a></h3>
<p>The classes described in the Callback Interface are C++ abstract
classes, or interfaces. They cannot be instantiated. For each of these
classes StackwalkerAPI provides one or more default implementations on
each platform. These default implementations are classes that inherit
from the abstract classes described in the Callback Interface. If a user
creates a Walker object without providing their own , , and objects,
then StackwalkerAPI will use the default implementations listed in
Table&nbsp;<a class="reference external" href="#table:defaults">1</a>. These implementations are described in
Section <a class="reference external" href="#sec:framesteppers">[sec:framesteppers]</a>.</p>
<div class="container" id="table-defaults">
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">Callback Interface Defaults</span><a class="headerlink" href="#id1" title="Permalink to this table"></a></caption>
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">StepperGroup</th>
<th class="head">ProcessState</th>
<th class="head">SymbolLookup</th>
<th class="head">FrameStepper</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Linux/x86</td>
<td><ol class="first last arabic simple">
<li>AddrRange</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>ProcSelf</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>SwkSymtab</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>FrameFuncStepper</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>Linux/x86-64</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>ProcDebug</li>
</ol>
</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>SigHandlerStepper</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="3">
<li>DebugStepper</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="4">
<li>AnalysisStepper</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="5">
<li>StepperWanderer</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="6">
<li>BottomOfStackStepper</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>Linux/PPC</td>
<td><ol class="first last arabic simple">
<li>AddrRange</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>ProcSelf</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>SwkSymtab</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>FrameFuncStepper</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>Linux/PPC-64</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>ProcDebug</li>
</ol>
</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>SigHandlerStepper</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="3">
<li>AnalysisStepper</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>Windows/x86</td>
<td><ol class="first last arabic simple">
<li>AddrRange</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>ProcSelf</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>SwkSymtab</li>
</ol>
</td>
<td><ol class="first last arabic simple">
<li>FrameFuncStepper</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>ProcDebug</li>
</ol>
</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="2">
<li>AnalysisStepper</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="3">
<li>StepperWanderer</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><ol class="first last arabic simple" start="4">
<li>BottomOfStackStepper</li>
</ol>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="class-framestepper">
<span id="subsec-framestepper"></span><h3>Class FrameStepper<a class="headerlink" href="#class-framestepper" title="Permalink to this headline"></a></h3>
<p>The class is an interface that tells StackwalkerAPI how to walk through
a specific type of stack frame. There may be many different ways of
walking through a stack frame on a platform, e.g, on Linux/x86 there are
different mechanisms for walking through system calls, signal handlers,
regular functions, and frameless functions. A single describes how to
walk through one of these types of stack frames.</p>
<p>A user can create their own classes that tell StackwalkerAPI how to walk
through new types of stack frames. A new object must be added to a
before it can be used.</p>
<p>In addition to walking through individual stack frames, a tells its when
it can be used. The registers address ranges that cover objects in the
target process’ code space (such as functions). These address ranges
should contain the objects that will create stack frames through which
the can walk. If multiple objects have overlapping address ranges, then
a priority value is used to determine which should be attempted first.</p>
<p>is an interface class; it cannot be instantiated. Users who want to
develop new objects should inherit from this class and implement the the
desired virtual functions. The , and functions must be implemented; all
others may be overridden if desired.</p>
<div class="apient container">
typedef enum gcf_success, gcf_stackbottom, gcf_not_me, gcf_error
gcframe_ret_t</div>
<div class="apient container">
virtual gcframe_ret_t getCallerFrame(const Frame &amp;in, Frame &amp;out) = 0</div>
<div class="apient container">
virtual void registerStepperGroup(StepperGroup *steppergroup)</div>
<div class="apient container">
virtual unsigned getPriority() const = 0</div>
<div class="apient container">
FrameStepper(Walker *w);</div>
<div class="apient container">
virtual ProcessState *getProcessState();</div>
<div class="apient container">
virtual Walker *getWalker();</div>
<div class="apient container">
typedef std::pair&lt;std::string, Address&gt; LibAddrPair; typedef enum
library_load, library_unload lib_change_t; virtual void
newLibraryNotification(LibAddrPair *libAddr, lib_change_t change);</div>
<div class="apient container">
virtual const char *getName() const = 0;</div>
</div>
<div class="section" id="class-steppergroup">
<span id="subsec-steppergroup"></span><h3>Class StepperGroup<a class="headerlink" href="#class-steppergroup" title="Permalink to this headline"></a></h3>
<p>The class contains a collection of objects. The ’s primary job is to
decide which should be used to walk through a stack frame given a return
address. The default keeps a set of address ranges for each . If
multiple objects overlap an address, then the default will use a
priority system to decide.</p>
<p>provides both an interface and a default implementation of that
interface. Users who want to customize the should inherit from this
class and re-implement any of the below virtual functions.</p>
<div class="apient container">
StepperGroup(Walker *walker)</div>
<div class="apient container">
virtual bool addStepper(FrameStepper *stepper)</div>
<div class="apient container">
virtual bool addStepper(FrameStepper *stepper, Address start,
Address end) = 0;</div>
<div class="apient container">
virtual void registerStepper(FrameStepper *stepper);</div>
<div class="apient container">
virtual bool findStepperForAddr(Address addr, FrameStepper* &amp;out,
const FrameStepper *last_tried = NULL) = 0</div>
<div class="apient container">
typedef std::pair&lt;std::string, Address&gt; LibAddrPair; typedef enum
library_load, library_unload lib_change_t; virtual void
newLibraryNotification(LibAddrPair *libaddr, lib_change_t change);</div>
<div class="apient container">
Walker *getWalker() const</div>
<div class="apient container">
void getSteppers(std::set&lt;FrameStepper *&gt; &amp;);</div>
</div>
<div class="section" id="class-processstate">
<span id="subsec-processstate"></span><h3>Class ProcessState<a class="headerlink" href="#class-processstate" title="Permalink to this headline"></a></h3>
<p>The ProcessState class is a virtual class that defines an interface
through which StackwalkerAPI can access the target process. It allows
access to registers and memory, and provides basic information about the
threads in the target process. StackwalkerAPI provides two default types
of objects: does a first party stackwalk, and does a third party
stackwalk.</p>
<p>A new class can be created by inheriting from this class and
implementing the necessary methods.</p>
<div class="apient container">
static ProcessState *getProcessStateByPid(Dyninst::PID pid)</div>
<div class="apient container">
virtual unsigned getAddressWidth() = 0;</div>
<div class="apient container">
typedef enum Arch_x86, Arch_x86_64, Arch_ppc32, Arch_ppc64
Architecture; virtual Dyninst::Architecture getArchitecture() = 0;</div>
<div class="apient container">
virtual bool getRegValue(Dyninst::MachRegister reg, Dyninst::THR_ID
thread, Dyninst::MachRegisterVal &amp;val) = 0</div>
<div class="apient container">
virtual bool readMem(void *dest, Address source, size_t size) = 0</div>
<div class="apient container">
virtual bool getThreadIds(std::vector&lt;Dyninst::THR_ID&gt; &amp;threads) = 0</div>
<div class="apient container">
virtual bool getDefaultThread(Dyninst::THR_ID &amp;default_tid) = 0</div>
<div class="apient container">
virtual Dyninst::PID getProcessId()</div>
<div class="apient container">
Walker *getWalker() const;</div>
<div class="apient container">
std::string getExecutablePath();</div>
<div class="section" id="class-librarystate">
<h4>Class LibraryState<a class="headerlink" href="#class-librarystate" title="Permalink to this headline"></a></h4>
<p>is a helper class for that provides information about the current DSOs
(libraries and executables) that are loaded into a process’ address
space. FrameSteppers frequently use the LibraryState to get the DSO
through which they are attempting to stack walk.</p>
<p>Each is represented using a object, which is defined as follows:</p>
<div class="apient container">
typedef std::pair&lt;std::string, Dyninst::Address&gt; LibAddrPair</div>
<div class="apient container">
virtual bool getLibraryAtAddr(Address addr, LibAddrPair &amp;lib) = 0</div>
<div class="apient container">
virtual bool getLibraries(std::vector&lt;LibAddrPair&gt; &amp;libs) = 0</div>
<div class="apient container">
virtual void notifyOfUpdate() = 0</div>
<div class="apient container">
virtual Address getLibTrapAddress() = 0</div>
</div>
</div>
<div class="section" id="class-symbollookup">
<h3>Class SymbolLookup<a class="headerlink" href="#class-symbollookup" title="Permalink to this headline"></a></h3>
<p>The virtual class is an interface for associating a symbolic name with a
stack frame. Each object contains an address (the RA) pointing into the
function (or function-like object) that created its stack frame.
However, users do not always want to deal with addresses when symbolic
names are more convenient. This class is an interface for mapping a
object’s RA into a name.</p>
<p>In addition to getting a name, this class can also associate an opaque
object (via a ) with a Frame object. It is up to the implementation what
to return in this opaque object.</p>
<p>The default implementation of provided by StackwalkerAPI uses the tool
to lookup symbol names. It returns a Symbol object in the anonymous .</p>
<div class="apient container">
SymbolLookup(std::string exec_path = “”);</div>
<div class="apient container">
virtual bool lookupAtAddr(Address addr, string &amp;out_name, void*
&amp;out_value) = 0</div>
<div class="apient container">
virtual Walker *getWalker()</div>
<div class="apient container">
virtual ProcessState *getProcessSate()</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>