<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Parsing API &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>The Parsing API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/parseAPI/4-ParseAPI.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="the-parsing-api">
<span id="sec-api"></span><h1>The Parsing API<a class="headerlink" href="#the-parsing-api" title="Permalink to this headline"></a></h1>
<div class="section" id="class-codeobject">
<h2>Class CodeObject<a class="headerlink" href="#class-codeobject" title="Permalink to this headline"></a></h2>
<p>The CodeObject class describes an individual binary code object, such as
an executable or library. It is the top-level container for parsing the
object as well as accessing that parse data. The following API routines
and data types are provided to support parsing and retrieving parsing
products.</p>
<div class="apient container">
typedef std::set&lt;Function *, Function::less&gt; funclist</div>
<div class="apient container">
CodeObject(CodeSource * cs, CFGFactory * fact = NULL, ParseCallback
* cb = NULL, bool defensiveMode = false)</div>
<div class="apient container">
void parse()</div>
<div class="apient container">
void parse(Address target, bool recursive)</div>
<div class="apient container">
void parse(CodeRegion * cr, Address target, bool recursive)</div>
<div class="apient container">
struct NewEdgeToParse Block *source; Address target; EdgeTypeEnum
type; bool parseNewEdges( vector&lt;NewEdgeToParse&gt; &amp; worklist )</div>
<p>ParseAPI is able to speculatively parse gaps (regions of binary that has
not been identified as code or data yet) to identify function entry
points and perform control flow traversal.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">GapParsingType</th>
<th class="head">Technique description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PreambleMatching</td>
<td>If instruction patterns are matched at an
adderss, the address is a function entry point</td>
</tr>
<tr class="row-odd"><td>IdiomMatching</td>
<td>Based on a pre-trained model, this technique
calculates the probability of an address to be a
function entry point and predicts whether which
addresses are function entry points</td>
</tr>
</tbody>
</table>
</div>
<div class="apient container">
void parseGaps(CodeRegion *cr, GapParsingType type=IdiomMatching)</div>
<div class="apient container">
Function * findFuncByEntry(CodeRegion * cr, Address entry)</div>
<div class="apient container">
int findFuncs(CodeRegion * cr, Address addr, std::set&lt;Function*&gt; &amp;
funcs)</div>
<div class="apient container">
int findFuncs(CodeRegion * cr, Address start, Address end,
std::set&lt;Function*&gt; &amp; funcs)</div>
<div class="apient container">
const funclist &amp; funcs()</div>
<div class="apient container">
Block * findBlockByEntry(CodeRegion * cr, Address entry)</div>
<div class="apient container">
int findBlocks(CodeRegion * cr, Address addr, std::set&lt;Block*&gt; &amp;
blocks)</div>
<div class="apient container">
Block * findNextBlock(CodeRegion * cr, Address addr)</div>
<div class="apient container">
CodeSource * cs()</div>
<div class="apient container">
CFGFactory * fact()</div>
<div class="apient container">
bool defensiveMode()</div>
<div class="apient container">
bool isIATcall(Address insn, std::string &amp;calleeName)</div>
<div class="apient container">
void startCallbackBatch()</div>
<div class="apient container">
void finishCallbackBatch()</div>
<div class="apient container">
void registerCallback(ParseCallback *cb);</div>
<div class="apient container">
void unregisterCallback(ParseCallback *cb);</div>
<div class="apient container">
void finalize()</div>
<div class="apient container">
void destroy(Edge *)</div>
<div class="apient container">
void destroy(Block *)</div>
<div class="apient container">
void destroy(Function *)</div>
</div>
<div class="section" id="class-coderegion">
<h2>Class CodeRegion<a class="headerlink" href="#class-coderegion" title="Permalink to this headline"></a></h2>
<p>The CodeRegion interface is an accounting structure used to divide
CodeSources into distinct regions. This interface is mostly of interest
to CodeSource implementors.</p>
<div class="apient container">
void names(Address addr, vector&lt;std::string&gt; &amp; names)</div>
<div class="apient container">
virtual bool findCatchBlock(Address addr, Address &amp; catchStart)</div>
<div class="apient container">
Address low()</div>
<div class="apient container">
Address high()</div>
<div class="apient container">
bool contains(Address addr)</div>
<div class="apient container">
virtual bool wasUserAdded() const</div>
</div>
<div class="section" id="class-function">
<h2>Class Function<a class="headerlink" href="#class-function" title="Permalink to this headline"></a></h2>
<p>The Function class represents the portion of the program CFG that is
reachable through intraprocedural control flow transfers from the
function’s entry block. Functions in the ParseAPI have only a single
entry point; multiple-entry functions such as those found in Fortran
programs are represented as several functions that “share” a subset of
the CFG. Functions may be non-contiguous and may share blocks with other
functions.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FuncSource</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT</td>
<td>recursive traversal (default)</td>
</tr>
<tr class="row-odd"><td>HINT</td>
<td>specified in CodeSource hints</td>
</tr>
<tr class="row-even"><td>GAP</td>
<td>speculative parsing heuristics</td>
</tr>
<tr class="row-odd"><td>GAPRT</td>
<td>recursive traversal from speculative parse</td>
</tr>
<tr class="row-even"><td>ONDEMAND</td>
<td>dynamically discovered at runtime</td>
</tr>
<tr class="row-odd"><td>MODIFICATION</td>
<td>Added via user modification</td>
</tr>
</tbody>
</table>
</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FuncReturnStatus</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNSET</td>
<td>unparsed function (default)</td>
</tr>
<tr class="row-odd"><td>NORETURN</td>
<td>will not return</td>
</tr>
<tr class="row-even"><td>UNKNOWN</td>
<td>cannot be determined statically</td>
</tr>
<tr class="row-odd"><td>RETURN</td>
<td>may return</td>
</tr>
</tbody>
</table>
</div>
<div class="apient container">
typedef boost::transform_iterator&lt;selector, blockmap::iterator&gt;
bmap_iterator typedef boost::transform_iterator&lt;selector,
blockmap::const_iterator&gt; bmap_const_iterator typedef
boost::iterator_range&lt;bmap_iterator&gt; blocklist typedef
boost::iterator_range&lt;bmap_const_iterator&gt; const_blocklist typedef
std::set&lt;Edge*&gt; edgelist</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>name</td>
<td>string</td>
<td>Name of the function.</td>
</tr>
<tr class="row-odd"><td>addr</td>
<td>Address</td>
<td>Entry address of the
function.</td>
</tr>
<tr class="row-even"><td>entry</td>
<td>Block *</td>
<td>Entry block of the
function.</td>
</tr>
<tr class="row-odd"><td>parsed</td>
<td>bool</td>
<td>Whether the function
has been parsed.</td>
</tr>
<tr class="row-even"><td>blocks</td>
<td>blocklist &amp;</td>
<td>List of blocks
contained by this
function sorted by
entry address.</td>
</tr>
<tr class="row-odd"><td>callEdges</td>
<td>const edgelist &amp;</td>
<td>List of outgoing call
edges from this
function.</td>
</tr>
<tr class="row-even"><td>returnBlocks</td>
<td>const_blocklist &amp;</td>
<td>List of all blocks
ending in return
edges.</td>
</tr>
<tr class="row-odd"><td>exitBlocks</td>
<td>const_blocklist &amp;</td>
<td>List of all blocks
that end the
function, including
blocks with no
out-edges.</td>
</tr>
<tr class="row-even"><td>hasNoStackFrame</td>
<td>bool</td>
<td>True if the function
does not create a
stack frame.</td>
</tr>
<tr class="row-odd"><td>savesFramePointer</td>
<td>bool</td>
<td>True if the function
saves a frame pointer
(e.g. %ebp).</td>
</tr>
<tr class="row-even"><td>cleansOwnStack</td>
<td>bool</td>
<td>True if the function
tears down
stack-passed
arguments upon
return.</td>
</tr>
<tr class="row-odd"><td>region</td>
<td>CodeRegion *</td>
<td>Code region that
contains the
function.</td>
</tr>
<tr class="row-even"><td>isrc</td>
<td>InstructionSource *</td>
<td>The InstructionSource
for this function.</td>
</tr>
<tr class="row-odd"><td>obj</td>
<td>CodeObject *</td>
<td>CodeObject that
contains this
function.</td>
</tr>
<tr class="row-even"><td>src</td>
<td>FuncSrc</td>
<td>The type of hint that
identified this
function’s entry
point.</td>
</tr>
<tr class="row-odd"><td>restatus</td>
<td>FuncReturnStatus *</td>
<td>Returns the
best-effort
determination of
whether this function
may return or not.
Return status cannot
always be statically
determined, and at
most can guarantee
that a function <em>may</em>
return, not that it
<em>will</em> return.</td>
</tr>
<tr class="row-even"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing the
return type of the
function.</td>
</tr>
</tbody>
</table>
<div class="apient container">
Function(Address addr, string name, CodeObject * obj, CodeRegion *
region, InstructionSource * isource)</div>
<div class="apient container">
LoopTreeNode* getLoopTree()</div>
<div class="apient container">
Loop* findLoop(const char *name)</div>
<div class="apient container">
bool getLoops(vector&lt;Loop*&gt; &amp;loops);</div>
<div class="apient container">
bool getOuterLoops(vector&lt;Loop*&gt; &amp;loops);</div>
<div class="apient container">
bool dominates(Block* A, Block *B);</div>
<div class="apient container">
Block* getImmediateDominator(Block *A);</div>
<div class="apient container">
void getImmediateDominates(Block *A, set&lt;Block*&gt; &amp;imm);</div>
<div class="apient container">
void getAllDominates(Block *A, set&lt;Block*&gt; &amp;dom);</div>
<div class="apient container">
bool postDominates(Block* A, Block *B);</div>
<div class="apient container">
Block* getImmediatePostDominator(Block *A);</div>
<div class="apient container">
void getImmediatePostDominates(Block *A, set&lt;Block*&gt; &amp;imm);</div>
<div class="apient container">
void getAllPostDominates(Block *A, set&lt;Block*&gt; &amp;dom);</div>
<div class="apient container">
std::vector&lt;FuncExtent *&gt; const&amp; extents()</div>
<div class="apient container">
void setEntryBlock(block * new_entry)</div>
<div class="apient container">
void set_retstatus(FuncReturnStatus rs)</div>
<div class="apient container">
bool contains(Block *b)</div>
<div class="apient container">
void removeBlock(Block *)</div>
</div>
<div class="section" id="class-block">
<h2>Class Block<a class="headerlink" href="#class-block" title="Permalink to this headline"></a></h2>
<p>A Block represents a basic block as defined in Section
<a class="reference external" href="#sec:abstractions">[sec:abstractions]</a>, and is the lowest level
representation of code in the CFG.</p>
<div class="apient container">
typedef std::vector&lt;Edge *&gt; edgelist</div>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="27%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>start</td>
<td>Address</td>
<td>Address of the first
instruction in the block.</td>
</tr>
<tr class="row-odd"><td>end</td>
<td>Address</td>
<td>Address immediately following
the last instruction in the
block.</td>
</tr>
<tr class="row-even"><td>last</td>
<td>Address</td>
<td>Address of the last
instruction in the block.</td>
</tr>
<tr class="row-odd"><td>lastInsnAddr</td>
<td>Address</td>
<td>Alias of .</td>
</tr>
<tr class="row-even"><td>size</td>
<td>Address</td>
<td>Size of the block; - .</td>
</tr>
<tr class="row-odd"><td>parsed</td>
<td>bool</td>
<td>Whether the block has been
parsed.</td>
</tr>
<tr class="row-even"><td>obj</td>
<td>CodeObject *</td>
<td>CodeObject containing this
block.</td>
</tr>
<tr class="row-odd"><td>region</td>
<td>CodeRegion *</td>
<td>CodeRegion containing this
block.</td>
</tr>
<tr class="row-even"><td>sources</td>
<td>const edgelist &amp;</td>
<td>List of all in-edges to the
block.</td>
</tr>
<tr class="row-odd"><td>targets</td>
<td>const edgelist &amp;</td>
<td>List of all out-edges from
the block.</td>
</tr>
<tr class="row-even"><td>containingFuncs</td>
<td>int</td>
<td>Number of Functions that
contain this block.</td>
</tr>
</tbody>
</table>
<div class="apient container">
Block(CodeObject * o, CodeRegion * r, Address start, Function* f =
NULL)</div>
<div class="apient container">
Block(CodeObject * o, CodeRegion * r, Address start, Address end,
Address last, Function* f = NULL)</div>
<div class="apient container">
bool consistent(Address addr, Address &amp; prev_insn)</div>
<div class="apient container">
void getFuncs(std::vector&lt;Function *&gt; &amp; funcs)</div>
<div class="apient container">
template &lt;class OutputIterator&gt; void getFuncs(OutputIterator result)</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="nb">set</span><span class="o">&lt;</span><span class="n">Function</span> <span class="o">*&gt;</span> <span class="n">funcs</span><span class="p">;</span>
<span class="n">block</span><span class="o">-&gt;</span><span class="n">getFuncs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">inserter</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">funcs</span><span class="o">.</span><span class="n">begin</span><span class="p">()));</span>
</pre></div>
</div>
<div class="apient container">
typedef std::map&lt;Offset, InstructionAPI::Instruction::Ptr&gt; Insns void
getInsns(Insns &amp;insns) const</div>
<div class="apient container">
InstructionAPI::Instruction::Ptr getInsn(Offset o) const</div>
</div>
<div class="section" id="class-edge">
<h2>Class Edge<a class="headerlink" href="#class-edge" title="Permalink to this headline"></a></h2>
<p>Typed Edges join two blocks in the CFG, indicating the type of control
flow transfer instruction that joins the blocks to each other. Edges may
not correspond to a control flow transfer instruction at all, as in the
case of the fallthrough edge that indicates where straight-line control
flow is split by incoming transfers from another location, such as a
branch. While not all blocks end in a control transfer instruction, all
control transfer instructions end basic blocks and have outgoing edges;
in the case of unresolvable control flow, the edge will target a special
“sink” block (see , below).</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EdgeTypeEnum</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CALL</td>
<td>call edge</td>
</tr>
<tr class="row-odd"><td>COND_TAKEN</td>
<td>conditional branch–taken</td>
</tr>
<tr class="row-even"><td>COND_NOT_TAKEN</td>
<td>conditional branch–not taken</td>
</tr>
<tr class="row-odd"><td>INDIRECT</td>
<td>branch indirect</td>
</tr>
<tr class="row-even"><td>DIRECT</td>
<td>branch direct</td>
</tr>
<tr class="row-odd"><td>FALLTHROUGH</td>
<td>direct fallthrough (no branch)</td>
</tr>
<tr class="row-even"><td>CATCH</td>
<td>exception handler</td>
</tr>
<tr class="row-odd"><td>CALL_FT</td>
<td>post-call fallthrough</td>
</tr>
<tr class="row-even"><td>RET</td>
<td>return</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>src</td>
<td>Block *</td>
<td>Source of the edge.</td>
</tr>
<tr class="row-odd"><td>trg</td>
<td>Block *</td>
<td>Target of the edge.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>EdgeTypeEnum</td>
<td>Type of the edge.</td>
</tr>
<tr class="row-odd"><td>sinkEdge</td>
<td>bool</td>
<td>True if the target is the sink block.</td>
</tr>
<tr class="row-even"><td>interproc</td>
<td>bool</td>
<td>True if the edge should be
interpreted as interprocedural (e.g.
calls, returns, unconditional or
conditional tail calls).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="class-loop">
<h2>Class Loop<a class="headerlink" href="#class-loop" title="Permalink to this headline"></a></h2>
<p>The Loop class represents code that may execute repeatedly. We detect
both natural loops (loops that have a single entry block) and
irreducible loops (loops that have multiple entry blocks). A back edge
is defined as an edge that has its source in the loop and has its target
being an entry block of the loop. It represents the end of an iteration
of the loop. For all the loops detected in a function, we also build a
loop nesting tree to represent the nesting relations between the loops.
See class for more details.</p>
<div class="apient container">
Loop* parent</div>
<div class="apient container">
bool containsAddress(Address addr)</div>
<div class="apient container">
bool containsAddressInclusive(Address addr)</div>
<div class="apient container">
int getLoopEntries(vector&lt;Block*&gt;&amp; entries);</div>
<div class="apient container">
int getBackEdges(vector&lt;Edge*&gt; &amp;edges)</div>
<div class="apient container">
bool getContainedLoops(vector&lt;Loop*&gt; &amp;loops)</div>
<div class="apient container">
bool getOuterLoops(vector&lt;Loop*&gt; &amp;loops)</div>
<div class="apient container">
bool getLoopBasicBlocks(vector&lt;Block*&gt; &amp;blocks)</div>
<div class="apient container">
bool getLoopBasicBlocksExclusive(vector&lt;Block*&gt; &amp;blocks)</div>
<div class="apient container">
bool hasBlock(Block *b);</div>
<div class="apient container">
bool hasBlockExclusive(Block *b);</div>
<div class="apient container">
bool hasAncestor(Loop *loop)</div>
<div class="apient container">
Function * getFunction();</div>
</div>
<div class="section" id="class-looptreenode">
<h2>Class LoopTreeNode<a class="headerlink" href="#class-looptreenode" title="Permalink to this headline"></a></h2>
<p>The LoopTreeNode class provides a tree interface to a collection of
instances of class Loop contained in a function. The structure of the
tree follows the nesting relationship of the loops in a function. Each
LoopTreeNode contains a pointer to a loop (represented by Loop), and a
set of sub-loops (represented by other LoopTreeNode objects). The field
at the root node is always since a function may contain multiple outer
loops. The field is never at any other node since it always corresponds
to a real loop. Therefore, the outer most loops in the function are
contained in the vector of of the root.</p>
<p>Each instance of LoopTreeNode is given a name that indicates its
position in the hierarchy of loops. The name of each outermost loop
takes the form of , where is an integer from 1 to n, where n is the
number of outer loops in the function. Each sub-loop has the name of its
parent, followed by a , where is 1 to m, where m is the number of
sub-loops under the outer loop. For example, consider the following C
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function will have a root LoopTreeNode, containing a NULL loop entry
and two LoopTreeNode children representing the functions outermost
loops. These children would have names and , respectively representing
the and loops. has no children. has two child LoopTreeNode objects,
named and , respectively representing the and loops.</p>
<div class="apient container">
Loop *loop;</div>
<div class="apient container">
std::vector&lt;LoopTreeNode *&gt; children;</div>
<div class="apient container">
const char * name();</div>
<div class="apient container">
const char * getCalleeName(unsigned int i)</div>
<div class="apient container">
unsigned int numCallees()</div>
<div class="apient container">
bool getCallees(vector&lt;Function *&gt; &amp;v);</div>
<div class="apient container">
Loop * findLoop(const char *name);</div>
</div>
<div class="section" id="class-codesource">
<span id="sec-codesource"></span><h2>Class CodeSource<a class="headerlink" href="#class-codesource" title="Permalink to this headline"></a></h2>
<p>The CodeSource interface is used by the ParseAPI to retrieve binary code
from an executable, library, or other binary code object; it also can
provide hints of function entry points (such as those derived from
debugging symbols) to seed the parser. The ParseAPI provides a default
implementation based on the SymtabAPI that supports many common binary
formats. For details on implementing a custom CodeSource, see Appendix
<a class="reference external" href="#sec:extend">[sec:extend]</a>.</p>
<div class="apient container">
virtual bool nonReturning(Address func_entry) virtual bool
nonReturning(std::string func_name)</div>
<div class="apient container">
virtual bool nonReturningSyscall(int /<em>number</em>/)</div>
<div class="apient container">
virtual Address baseAddress() virtual Address loadAddress()</div>
<div class="apient container">
std::map&lt; Address, std::string &gt; &amp; linkage()</div>
<div class="apient container">
struct Hint Address _addr; CodeRegion *_region; std::string _name;
Hint(Addr, CodeRegion *, std::string); std::vector&lt; Hint &gt; const&amp;
hints()</div>
<div class="apient container">
std::vector&lt;CodeRegion *&gt; const&amp; regions()</div>
<div class="apient container">
int findRegions(Address addr, set&lt;CodeRegion *&gt; &amp; ret)</div>
<div class="apient container">
bool regionsOverlap()</div>
</div>
<div class="section" id="class-parsecallback">
<h2>Class ParseCallback<a class="headerlink" href="#class-parsecallback" title="Permalink to this headline"></a></h2>
<p>The ParseCallback class allows ParseAPI users to be notified of various
events during parsing. For most users this notification is unnecessary,
and an instantiation of the default ParseCallback can be passed to the
CodeObject during initialization. Users who wish to be notified must
implement a class that inherits from ParseCallback, and implement one or
more of the methods described below to receive notification of those
events.</p>
<div class="apient container">
struct default_details default_details(unsigned char * b,size_t s,
bool ib); unsigned char * ibuf; size_t isize; bool isbranch;</div>
<div class="apient container">
virtual void instruction_cb(Function *, Block *, Address,
insn_details *)</div>
<div class="apient container">
struct insn_details InsnAdapter::InstructionAdapter * insn;</div>
<div class="apient container">
void interproc_cf(Function *, Address, interproc_details *)</div>
<div class="apient container">
struct interproc_details typedef enum ret, call, branch_interproc, //
tail calls, branches to plts syscall type_t; unsigned char * ibuf;
size_t isize; type_t type; union struct Address target; bool
absolute_address; bool dynamic_call; call; data;</div>
<div class="apient container">
void overlapping_blocks(Block *, Block *)</div>
</div>
<div class="section" id="class-funcextent">
<h2>Class FuncExtent<a class="headerlink" href="#class-funcextent" title="Permalink to this headline"></a></h2>
<p>Function Extents are used internally for accounting and lookup purposes.
They may be useful for users who wish to precisely identify the ranges
of the address space spanned by functions (functions are often
discontiguous, particularly on architectures with variable length
instruction sets).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="21%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>func</td>
<td>Function *</td>
<td>Function linked to this extent.</td>
</tr>
<tr class="row-odd"><td>start</td>
<td>Address</td>
<td>Start of the extent.</td>
</tr>
<tr class="row-even"><td>end</td>
<td>Address</td>
<td>End of the extent (exclusive).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="edge-predicates">
<span id="sec-pred"></span><h2>Edge Predicates<a class="headerlink" href="#edge-predicates" title="Permalink to this headline"></a></h2>
<p>Edge predicates control iteration over edges. For example, the provided
edge predicate can be used with filter iterators and standard
algorithms, ensuring that only intraprocedural edges are visited during
iteration. Two other examples of edge predicates are provided: only
visits edges that stay in a single function context, and does not visit
edges to the <em>sink</em> block. The following code traverses all of the basic
blocks within a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;boost/filter_iterator.hpp&gt;
using boost::make_filter_iterator;
struct target_block
{
  Block* operator()(Edge* e) { return e-&gt;trg(); }
};


vector&lt;Block*&gt; work;
Intraproc epred; // ignore calls, returns

work.push_back(func-&gt;entry()); // assuming `func&#39; is a Function*

// do_stuff is a functor taking a Block* as its argument
while(!work.empty()) {
    Block * b = work.back();
    work.pop_back();

    Block::edgelist &amp; targets = block-&gt;targets();
    // Do stuff for each out edge
    std::for_each(make_filter_iterator(targets.begin(), epred),
                  make_filter_iterator(targets.end(), epred),
                  do_stuff());
    std::transform(make_filter_iterator(targets.begin(), epred),
                   make_filter_iterator(targets.end(), epred),
                   std::back_inserter(work),
                   std::mem_fun(Edge::trg));
    Block::edgelist::const_iterator found_interproc =
            std::find_if(targets.begin(), targets.end(), Interproc());
    if(interproc != targets.end()) {
            // do something with the interprocedural edge you found
    }
}
</pre></div>
</div>
<p>Anything that can be treated as a function from to a can be used in this
manner. This replaces the beta interface where all s needed to descend
from a common parent class. Code that previously constructed iterators
from an edge predicate should be replaced with equivalent code using
filter iterators as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">OLD</span>
<span class="k">for</span><span class="p">(</span><span class="n">Block</span><span class="p">::</span><span class="n">edgelist</span><span class="p">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">epred</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">epred</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">NEW</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">()),</span>
         <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">targets</span><span class="p">,</span><span class="n">end</span><span class="p">()),</span>
         <span class="n">loop_body_as_function</span><span class="p">);</span>
<span class="o">//</span> <span class="n">NEW</span> <span class="p">(</span><span class="n">C</span><span class="o">++</span><span class="mi">11</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="n">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="containers">
<span id="sec-containers"></span><h2>Containers<a class="headerlink" href="#containers" title="Permalink to this headline"></a></h2>
<p>Several of the ParseAPI data structures export containers of CFG
objects; the CodeObject provides a list of functions in the binary, for
example, while functions provide lists of blocks and so on. To avoid
tying the internal storage for these structures to any particular
container type, ParseAPI objects export a ContainerWrapper that provides
an iterator interface to the internal containers. These wrappers and
predicate interfaces are designed to add minimal overhead while
protecting ParseAPI users from exposure to internal container storage
details. Users <em>must not</em> rely on properties of the underlying container
type (e.g. storage order) unless that property is explicity stated in
this manual.</p>
<p>ContainerWrapper containers export the following interface ( types vary
depending on the template parameters of the ContainerWrapper, but are
always instantiations of the PredicateIterator described below):</p>
<div class="apient container">
iterator begin() iterator begin(predicate *)</div>
<div class="apient container">
iterator const&amp; end()</div>
<div class="apient container">
size_t size()</div>
<div class="apient container">
bool empty()</div>
<p>The elements in ParseAPI containers can be accessed by iteration using
an instantiation of the PredicateIterator. These iterators can
optionally act as filters, evaluating a boolean predicate for each
element and only returning those elements for which the predicate
returns true. <em>Iterators with non-null predicates may return fewer
elements during iteration than their method indicates.</em> Currently
PredicateIterators only support forward iteration. The operators (prefix
and postfix), , , and (dereference) are supported.</p>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>