<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="../patchAPI/index.html" />
    <link rel="prev" title="Introduction" href="../instructionAPI/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#function-disassembly">Function Disassembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="#control-flow-graph-traversal">Control flow graph traversal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#loop-analysis">Loop analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#the-parsing-api">The Parsing API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class-codeobject">Class CodeObject</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-coderegion">Class CodeRegion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-function">Class Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-block">Class Block</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-edge">Class Edge</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-loop">Class Loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-looptreenode">Class LoopTreeNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-codesource">Class CodeSource</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-parsecallback">Class ParseCallback</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-funcextent">Class FuncExtent</a></li>
<li class="toctree-l2"><a class="reference internal" href="#edge-predicates">Edge Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containers">Containers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#extending-parseapi">Extending ParseAPI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#instruction-and-code-sources">Instruction and Code Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cfg-object-factories">CFG Object Factories</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symtabAPI/index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/parseAPI/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="introduction">
<span id="sec-intro"></span><h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h1>
<p>A binary code parser converts the machine code representation of a
program, library, or code snippet to abstractions such as the
instructions, basic blocks, functions, and loops that the binary code
represents. The ParseAPI is a multi-platform library for creating such
abstractions from binary code sources. The current incarnation uses the
Dyninst SymtabAPI as the default binary code source; all platforms and
architectures handled by the SymtabAPI are supported. The ParseAPI has
cross-architecture binary analysis capabilities in analyzing ELF
binaries (parsing of ARM binaries on x86 and vice versa, for example).
The ParseAPI is designed to be easily extensible to other binary code
sources. Support for parsing binary code in memory dumps or other
formats requires only implementation of a small interface as described
in this document.</p>
<p>This API provides the user with a control flow-oriented view of a binary
code source. Each code object such as a program binary or library is
represented as a top-level collection containing the loops, functions,
basic blocks, and edges that represent the control flow graph. A simple
query interface is provided for retrieving lower level objects like
functions and basic blocks through address or other attribute lookups.
These objects can be used to navigate the program structure as described
below.</p>
<p>Since Dyninst 10.0, ParseAPI is officially supporting parallel binary
code analysis and parallel queries. We typically observe 4X speedup when
analyzing binaries with 8 threads. To control the number of threads used
during parallel parsing, please set environment variable
<code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code>.</p>
</div>
<div class="section" id="abstractions">
<span id="sec-abstractions"></span><h1>Abstractions<a class="headerlink" href="#abstractions" title="Permalink to this headline"></a></h1>
<p>The basic representation of code in this API is the control flow graph
(CFG). Binary code objects are represented as regions of contiguous
bytes that, when parsed, form the nodes and edges of this graph. The
following abstractions make up this CFG-oriented representation of
binary code:</p>
<div class="itemize container">
<p>block: Nodes in the CFG represent <em>basic blocks</em>: straight line
sequences of instructions <span class="math notranslate nohighlight">\(I_i \ldots I_j\)</span> where for each
<span class="math notranslate nohighlight">\(i &lt; k
\le j\)</span>, <span class="math notranslate nohighlight">\(I_k\)</span> postdominates <span class="math notranslate nohighlight">\(I_{k-1}\)</span>. Importantly, on
some instruction set architectures basic blocks can <em>overlap</em> on the
same address range—variable length instruction sets allow for
multiple interpretations of the bytes making up the basic block.</p>
<p>edge: Typed edges between the nodes in the CFG represent execution
control flow, such as conditional and unconditional branches,
fallthrough edges, and calls and returns. The graph therefore
represents both <em>inter-</em> and <em>intraprocedural</em> control flow:
traversal of nodes and edges can cross the boundaries of the higher
level abstractions like <em>functions</em>.</p>
<p>function: The <em>function</em> is the primary semantic grouping of code in
the binary, mirroring the familiar abstraction of procedural
languages like C. Functions represent the set of all basic blocks
reachable from a <em>function entry point</em> through intraprocedural
control flow only (that is, no calls or returns). Function entry
points are determined in a variety of ways, such as hints from
debugging symbols, recursive traversal along call edges and a machine
learning based function entry point identification process.</p>
<p>loop: The <em>loop</em> represents code in the binary that may execute
repeatedly, corresponding to source language constructs like <em>for</em>
loop or <em>while</em> loop. We use a formal definition of loops from
“Nesting of Reducible and Irreducible Loops” by Paul Havlak. We
support identifying both natural loops (single-entry loops) and
irreducible loops (multi-entry loops).</p>
</div>
<div class="itemize container">
<p>code object: A collection of distinct code regions are represented as
a single code object, such as an executable or library. Code objects
can normally be thought of as a single, discontiguous unique address
space. However, the ParseAPI supports code objects in which the
different regions have overlapping address spaces, such as UNIX
archive files containing unlinked code.</p>
<p>instruction source: An instruction source describes a backing store
containing binary code. A binary file, a library, a memory dump, or a
process’s executing memory image can all be described as an
instruction source, allowing parsing of a variety of binary code
objects.</p>
<p>code source: The code source implements the instruction source
interface, exporting methods that can access the underlying bytes of
the binary code for parsing. It also exports a number of additional
helper methods that do things such as returning the location of
structured exception handling routines and function symbols. Code
sources are tailored to particular binary types; the ParseAPI
provides a SymtabAPI-based code source that understands ELF, COFF and
PE file formats.</p>
</div>
</div>
<div class="section" id="examples">
<span id="sec-example"></span><h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h1>
<div class="section" id="function-disassembly">
<h2>Function Disassembly<a class="headerlink" href="#function-disassembly" title="Permalink to this headline"></a></h2>
<p>The following example uses ParseAPI and InstructionAPI to disassemble
the basic blocks in a function. As an example, it can be built with G++
as follows:
<code class="docutils literal notranslate"><span class="pre">g++</span> <span class="pre">-std=c++0x</span> <span class="pre">-o</span> <span class="pre">code_sample</span> <span class="pre">code_sample.cc</span> <span class="pre">-L&lt;library</span> <span class="pre">install</span> <span class="pre">path&gt;</span> <span class="pre">-I&lt;headers</span> <span class="pre">install</span> <span class="pre">path&gt;</span> <span class="pre">-lparseAPI</span> <span class="pre">-linstructionAPI</span> <span class="pre">-lsymtabAPI</span> <span class="pre">-lsymLite</span> <span class="pre">-ldynDwarf</span> <span class="pre">-ldynElf</span> <span class="pre">-lcommon</span> <span class="pre">-L&lt;libelf</span> <span class="pre">path&gt;</span> <span class="pre">-lelf</span> <span class="pre">-L&lt;libdwarf</span> <span class="pre">path&gt;</span> <span class="pre">-ldwarf</span></code>.
Note: this example must be compiled with C++11x support; for G++ this is
enabled with <code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code>, and it is on by default for Visual Studio.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">   Copyright (C) 2015 Alin Mindroc</span>
<span class="cm">   (mindroc dot alin at gmail dot com)</span>

<span class="cm">   This is a sample program that shows how to use InstructionAPI in order to</span>
<span class="cm">   6  print the assembly code and functions in a provided binary.</span>


<span class="cm">   This program is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Lesser General Public</span>
<span class="cm">   11  License as published by the Free Software Foundation; either</span>
<span class="cm">   version 2.1 of the License, or (at your option) any later version.</span>
<span class="cm">   */</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CodeObject.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;InstructionDecoder.h&quot;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ParseAPI</span><span class="p">;</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">InstructionAPI</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"></span>
<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s &lt;binary path&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">binaryPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">SymtabCodeSource</span><span class="w"> </span><span class="o">*</span><span class="n">sts</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CodeObject</span><span class="w"> </span><span class="o">*</span><span class="n">co</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Instruction</span><span class="o">::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">instr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">SymtabAPI</span><span class="o">::</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">symTab</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">binaryPathStr</span><span class="p">(</span><span class="n">binaryPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isParsable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SymtabAPI</span><span class="o">::</span><span class="n">Symtab</span><span class="o">::</span><span class="n">openFile</span><span class="p">(</span><span class="n">symTab</span><span class="p">,</span><span class="w"> </span><span class="n">binaryPathStr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">isParsable</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">){</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;error: file can not be parsed&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">sts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SymtabCodeSource</span><span class="p">(</span><span class="n">binaryPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">co</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CodeObject</span><span class="p">(</span><span class="n">sts</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">//parse the binary given as a command line arg</span>
<span class="w">    </span><span class="n">co</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">//get list of all functions in the binary</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CodeObject</span><span class="o">::</span><span class="n">funclist</span><span class="w"> </span><span class="o">&amp;</span><span class="n">all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">co</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">all</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;error: no functions in file&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">fit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">fit</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//create an Instruction decoder which will convert the binary opcodes to strings</span>
<span class="w">    </span><span class="n">InstructionDecoder</span><span class="w"> </span><span class="n">decoder</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">isrc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPtrToInstruction</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">()),</span><span class="w"></span>
<span class="w">         </span><span class="n">InstructionDecoder</span><span class="o">::</span><span class="n">maxInstructionLength</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getArch</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(;</span><span class="n">fit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">all</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">fit</span><span class="p">){</span><span class="w"></span>
<span class="w">     </span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">fit</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="c1">//get address of entry point for current function</span>

<span class="w">     </span><span class="n">Address</span><span class="w"> </span><span class="n">crtAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">();</span><span class="w"></span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">instr_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">instr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder</span><span class="p">.</span><span class="n">decode</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">isrc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPtrToInstruction</span><span class="p">(</span><span class="n">crtAddr</span><span class="p">));</span><span class="w"></span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">fbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">().</span><span class="n">end</span><span class="p">();</span><span class="w"></span>
<span class="w">     </span><span class="n">fbl</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">Block</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">fbl</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">Address</span><span class="w"> </span><span class="n">lastAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">();</span><span class="w"></span>
<span class="w">     </span><span class="c1">//if current function has zero instructions, don’t output it</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="n">crtAddr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">lastAddr</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n\n\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> :&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">while</span><span class="p">(</span><span class="n">crtAddr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lastAddr</span><span class="p">){</span><span class="w"></span>
<span class="w">         </span><span class="c1">//decode current instruction</span>
<span class="w">         </span><span class="n">instr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decoder</span><span class="p">.</span><span class="n">decode</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">isrc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPtrToInstruction</span><span class="p">(</span><span class="n">crtAddr</span><span class="p">));</span><span class="w"></span>
<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">crtAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="c1">//go to the address of the next instruction</span>
<span class="w">         </span><span class="n">crtAddr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">         </span><span class="n">instr_count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="control-flow-graph-traversal">
<h2>Control flow graph traversal<a class="headerlink" href="#control-flow-graph-traversal" title="Permalink to this headline"></a></h2>
<p>The following complete example uses the ParseAPI to parse a binary and
dump its control flow graph in the Graphviz file format. As an example,
it can be built with G++ as follows:
<code class="docutils literal notranslate"><span class="pre">g++</span> <span class="pre">-std=c++0x</span> <span class="pre">-o</span> <span class="pre">example</span> <span class="pre">example.cc</span> <span class="pre">-L&lt;library</span> <span class="pre">install</span> <span class="pre">path&gt;</span> <span class="pre">-I&lt;headers</span> <span class="pre">install</span> <span class="pre">path&gt;</span> <span class="pre">-lparseAPI</span> <span class="pre">-linstructionAPI</span> <span class="pre">-lsymtabAPI</span> <span class="pre">-lsymLite</span> <span class="pre">-ldynDwarf</span> <span class="pre">-ldynElf</span> <span class="pre">-lcommon</span> <span class="pre">-L&lt;libelf</span> <span class="pre">path&gt;</span> <span class="pre">-lelf</span> <span class="pre">-L&lt;libdwarf</span> <span class="pre">path&gt;</span> <span class="pre">-ldwarf</span></code>.
Note: this example must be compiled with C++11x support; for G++ this is
enabled with <code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code>, and it is on by default for Visual Studio.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example ParseAPI program; produces a graph (in DOT format) of the</span>
<span class="c1">// control flow graph of the provided binary.</span>
<span class="c1">//</span>
<span class="c1">// Improvements by E. Robbins (er209 at kent dot ac dot uk)</span>
<span class="c1">//</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CodeObject.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CFG.h&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ParseAPI</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">map</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">seen</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">funcs</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">SymtabCodeSource</span><span class="w"> </span><span class="o">*</span><span class="n">sts</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CodeObject</span><span class="w"> </span><span class="o">*</span><span class="n">co</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Create a new binary code object from the filename argument</span>
<span class="w">   </span><span class="n">sts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SymtabCodeSource</span><span class="p">(</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">co</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CodeObject</span><span class="p">(</span><span class="w"> </span><span class="n">sts</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Parse the binary</span>
<span class="w">   </span><span class="n">co</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;digraph G {&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Print the control flow graph</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">CodeObject</span><span class="o">::</span><span class="n">funclist</span><span class="o">&amp;</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">co</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">fit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">fit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">all</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">fit</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// i is index for clusters</span>
<span class="w">      </span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">fit</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Make a cluster for nodes of this function</span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> subgraph cluster_&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; { </span><span class="se">\n\t\t</span><span class="s"> label=</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">; </span><span class="se">\n\t\t</span><span class="s"> color=blue;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t\t\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dec</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> [shape=box&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">retstatus</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NORETURN</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,color=red&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Label functions by name</span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t\t\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dec</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> [label = </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\\</span><span class="s">n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dec</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">];&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">stringstream</span><span class="w"> </span><span class="n">edgeoutput</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">().</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">Block</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">bit</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="c1">// Don&#39;t revisit blocks in shared code</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">seen</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">         </span><span class="n">seen</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t\t\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dec</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">         </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">().</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!*</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CALL</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; [color=blue]&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RET</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; [color=green]&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Store the edges somewhere to be printed outside of the cluster</span>
<span class="w">            </span><span class="n">edgeoutput</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t\&quot;</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> -&gt; </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">trg</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// End cluster</span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">}&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Print edges</span>
<span class="w">      </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">edgeoutput</span><span class="p">.</span><span class="n">str</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="loop-analysis">
<h2>Loop analysis<a class="headerlink" href="#loop-analysis" title="Permalink to this headline"></a></h2>
<p>The following code example shows how to get loop information using
ParseAPI once we have an parsed Function object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">GetLoopInFunc</span><span class="p">(</span><span class="n">Function</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Get</span> <span class="nb">all</span> <span class="n">loops</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">function</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Loop</span><span class="o">*&gt;</span> <span class="n">loops</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">getLoops</span><span class="p">(</span><span class="n">loops</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Iterate</span> <span class="n">over</span> <span class="nb">all</span> <span class="n">loops</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">lit</span> <span class="o">=</span> <span class="n">loops</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">lit</span> <span class="o">!=</span> <span class="n">loops</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">lit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Loop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="o">*</span><span class="n">lit</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Get</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">entry</span> <span class="n">blocks</span> <span class="n">of</span> <span class="n">the</span> <span class="n">loop</span>
     <span class="n">vector</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*&gt;</span> <span class="n">entries</span><span class="p">;</span>
     <span class="n">loop</span><span class="o">-&gt;</span><span class="n">getLoopEntries</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Get</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">loop</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*&gt;</span> <span class="n">blocks</span><span class="p">;</span>
     <span class="n">loop</span><span class="o">-&gt;</span><span class="n">getLoopBasicBlocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">);</span>

     <span class="o">//</span> <span class="n">Get</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">back</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">loop</span>
     <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">*&gt;</span> <span class="n">backEdges</span><span class="p">;</span>
     <span class="n">loop</span><span class="o">-&gt;</span><span class="n">getBackEdges</span><span class="p">(</span><span class="n">backEdges</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-parsing-api">
<span id="sec-api"></span><h1>The Parsing API<a class="headerlink" href="#the-parsing-api" title="Permalink to this headline"></a></h1>
<div class="section" id="class-codeobject">
<h2>Class CodeObject<a class="headerlink" href="#class-codeobject" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CodeObject.h</span></code></p>
<p>The CodeObject class describes an individual binary code object, such as
an executable or library. It is the top-level container for parsing the
object as well as accessing that parse data. The following API routines
and data types are provided to support parsing and retrieving parsing
products.</p>
<p>typedef std::set&lt;Function *, Function::less&gt; funclist</p>
<p>Container for access to functions. Refer to Section
<a class="reference external" href="#sec:containers">4.12</a> for details. Library users <em>must not</em> rely on
the underlying container type of std::set, as it is subject to change.</p>
<p>CodeObject(CodeSource * cs, CFGFactory * fact = NULL, ParseCallback *
cb = NULL, bool defensiveMode = false)</p>
<p>Constructs a new CodeObject from the provided CodeSource and optional
object factory and callback handlers. Any parsing hints provided by the
CodeSource are processed, but the binary is not parsed when this
constructor returns. The passed CodeSource is <strong>not</strong> owned by this
object. However, it must have the same lifetime as the CodeObject.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">defensiveMode</span></code> parameter optionally trades off coverage for
safety; this mode is not recommended for most applications as it makes
very conservative assumptions about control flow transfer instructions
(see Section <a class="reference external" href="#sec:defmode">6</a>).</p>
<p>void parse()</p>
<p>Recursively parses the binary represented by this CodeObject from all
known function entry points (i.e., the hints provided by the
CodeSource). This method and the following parsing methods may safely be
invoked repeatedly if new information about function locations is
provided through the CodeSource. Note that these parsing methods do not
automatically perform speculative gap parsing. parseGaps should be used
for this purpose.</p>
<p>void parse(Address target, bool recursive)</p>
<p>Parses the binary starting with the instruction at the provided target
address. If <code class="docutils literal notranslate"><span class="pre">recursive</span></code> is true, recursive traversal parsing is used
as in the default <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method; otherwise only instructions
reachable through intraprocedural control flow are visited.</p>
<p>void parse(CodeRegion * cr, Address target, bool recursive)</p>
<p>Parses the specified core region of the binary starting with the
instruction at the provided target address. If <code class="docutils literal notranslate"><span class="pre">recursive</span></code> is true,
recursive traversal parsing is used as in the default <code class="docutils literal notranslate"><span class="pre">parse()</span></code>
method; otherwise only instructions reachable through intraprocedural
control flow are visited.</p>
<p>struct NewEdgeToParse Block *source; Address target; EdgeTypeEnum type;
bool parseNewEdges( vector&lt;NewEdgeToParse&gt; &amp; worklist )</p>
<p>Parses a set of newly created edges specified in the worklist supplied
that were not included when the function was originally parsed.</p>
<p>ParseAPI is able to speculatively parse gaps (regions of binary that has
not been identified as code or data yet) to identify function entry
points and perform control flow traversal.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">GapParsingType</th>
<th class="head">Technique description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PreambleMatching</td>
<td>If instruction patterns are matched at an
adderss, the address is a function entry point</td>
</tr>
<tr class="row-odd"><td>IdiomMatching</td>
<td>Based on a pre-trained model, this technique
calculates the probability of an address to be a
function entry point and predicts whether which
addresses are function entry points</td>
</tr>
</tbody>
</table>
</div>
<p>void parseGaps(CodeRegion *cr, GapParsingType type=IdiomMatching)</p>
<p>Speculatively parse the indicated region of the binary using the
specified technique to find likely function entry points, enabled on the
x86 and x86-64 platforms.</p>
<p>Function * findFuncByEntry(CodeRegion * cr, Address entry)</p>
<p>Find the function starting at address <code class="docutils literal notranslate"><span class="pre">entry</span></code> in the indicated
CodeRegion. Returns null if no such function exists.</p>
<p>int findFuncs(CodeRegion * cr, Address addr, std::set&lt;Function*&gt; &amp;
funcs)</p>
<p>Finds all functions spanning <code class="docutils literal notranslate"><span class="pre">addr</span></code> in the code region, adding each to
<code class="docutils literal notranslate"><span class="pre">funcs</span></code>. The number of results of this stabbing query are returned.</p>
<p>int findFuncs(CodeRegion * cr, Address start, Address end,
std::set&lt;Function*&gt; &amp; funcs)</p>
<p>Finds all functions overlapping the range <code class="docutils literal notranslate"><span class="pre">[start,end)</span></code> in the code
region, adding each to <code class="docutils literal notranslate"><span class="pre">funcs</span></code>. The number of results of this stabbing
query are returned.</p>
<p>const funclist &amp; funcs()</p>
<p>Returns a const reference to a container of all functions in the binary.
Refer to Section <a class="reference external" href="#sec:containers">4.12</a> for container access
details.</p>
<p>Block * findBlockByEntry(CodeRegion * cr, Address entry)</p>
<p>Find the basic block starting at address <code class="docutils literal notranslate"><span class="pre">entry</span></code>. Returns null if no
such block exists.</p>
<p>int findBlocks(CodeRegion * cr, Address addr, std::set&lt;Block*&gt; &amp;
blocks)</p>
<p>Finds all blocks spanning <code class="docutils literal notranslate"><span class="pre">addr</span></code> in the code region, adding each to
<code class="docutils literal notranslate"><span class="pre">blocks</span></code>. Multiple blocks can be returned only on platforms with
variable-length instruction sets (such as IA32) for which overlapping
instructions are possible; at most one block will be returned on all
other platforms.</p>
<p>Block * findNextBlock(CodeRegion * cr, Address addr)</p>
<p>Find the next reachable basic block starting at address <code class="docutils literal notranslate"><span class="pre">entry</span></code>.
Returns null if no such block exists.</p>
<p>CodeSource * cs()</p>
<p>Return a reference to the underlying CodeSource.</p>
<p>CFGFactory * fact()</p>
<p>Return a reference to the CFG object factory.</p>
<p>bool defensiveMode()</p>
<p>Return a boolean specifying whether or not defensive mode is enabled.</p>
<p>bool isIATcall(Address insn, std::string &amp;calleeName)</p>
<p>Returns a boolean specifying if the address at <code class="docutils literal notranslate"><span class="pre">addr</span></code> is located at
the call named in <code class="docutils literal notranslate"><span class="pre">calleeName</span></code>.</p>
<p>void startCallbackBatch()</p>
<p>Starts a batch of callbacks that have been registered.</p>
<p>void finishCallbackBatch()</p>
<p>Completes all callbacks in the current batch.</p>
<p>void registerCallback(ParseCallback *cb);</p>
<p>Register a callback <code class="docutils literal notranslate"><span class="pre">cb</span></code></p>
<p>void unregisterCallback(ParseCallback *cb);</p>
<p>Unregister an existing callback <code class="docutils literal notranslate"><span class="pre">cb</span></code></p>
<p>void finalize()</p>
<p>Force complete parsing of the CodeObject; parsing operations are
otherwise completed only as needed to answer queries.</p>
<p>void destroy(Edge *)</p>
<p>Destroy the edge listed.</p>
<p>void destroy(Block *)</p>
<p>Destroy the code block listed.</p>
<p>void destroy(Function *)</p>
<p>Destroy the function listed.</p>
</div>
<div class="section" id="class-coderegion">
<h2>Class CodeRegion<a class="headerlink" href="#class-coderegion" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CodeSource.h</span></code></p>
<p>The CodeRegion interface is an accounting structure used to divide
CodeSources into distinct regions. This interface is mostly of interest
to CodeSource implementors.</p>
<p>void names(Address addr, vector&lt;std::string&gt; &amp; names)</p>
<p>Fills the provided vector with any names associated with the function at
a given address in the region, e.g. symbol names in an ELF or PE binary.</p>
<p>virtual bool findCatchBlock(Address addr, Address &amp; catchStart)</p>
<p>Finds the exception handler associated with an address, if one exists.
This routine is only implemented for binary code sources that support
structured exception handling, such as the SymtabAPI-based
SymtabCodeSource provided as part of the ParseAPI.</p>
<p>Address low()</p>
<p>The lower bound of the interval of address space covered by this region.</p>
<p>Address high()</p>
<p>The upper bound of the interval of address space covered by this region.</p>
<p>bool contains(Address addr)</p>
<p>Returns true if
<span class="math notranslate nohighlight">\(\small \texttt{addr} \in [\small \texttt{low()},\small \texttt{high()})\)</span>,
false otherwise.</p>
<p>virtual bool wasUserAdded() const</p>
<p>Return true if this region was added by the user, false otherwise.</p>
</div>
<div class="section" id="class-function">
<h2>Class Function<a class="headerlink" href="#class-function" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>The Function class represents the portion of the program CFG that is
reachable through intraprocedural control flow transfers from the
function’s entry block. Functions in the ParseAPI have only a single
entry point; multiple-entry functions such as those found in Fortran
programs are represented as several functions that “share” a subset of
the CFG. Functions may be non-contiguous and may share blocks with other
functions.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FuncSource</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT</td>
<td>recursive traversal (default)</td>
</tr>
<tr class="row-odd"><td>HINT</td>
<td>specified in CodeSource hints</td>
</tr>
<tr class="row-even"><td>GAP</td>
<td>speculative parsing heuristics</td>
</tr>
<tr class="row-odd"><td>GAPRT</td>
<td>recursive traversal from speculative parse</td>
</tr>
<tr class="row-even"><td>ONDEMAND</td>
<td>dynamically discovered at runtime</td>
</tr>
<tr class="row-odd"><td>MODIFICATION</td>
<td>Added via user modification</td>
</tr>
</tbody>
</table>
</div>
<p>Return status of an function, which indicates whether this function will
return to its caller or not; see description below.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FuncReturnStatus</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNSET</td>
<td>unparsed function (default)</td>
</tr>
<tr class="row-odd"><td>NORETURN</td>
<td>will not return</td>
</tr>
<tr class="row-even"><td>UNKNOWN</td>
<td>cannot be determined statically</td>
</tr>
<tr class="row-odd"><td>RETURN</td>
<td>may return</td>
</tr>
</tbody>
</table>
</div>
<p>typedef boost::transform_iterator&lt;selector, blockmap::iterator&gt;
bmap_iterator typedef boost::transform_iterator&lt;selector,
blockmap::const_iterator&gt; bmap_const_iterator typedef
boost::iterator_range&lt;bmap_iterator&gt; blocklist typedef
boost::iterator_range&lt;bmap_const_iterator&gt; const_blocklist typedef
std::set&lt;Edge*&gt; edgelist</p>
<p>Containers for block and edge access. Library users <em>must not</em> rely on
the underlying container type of std::set/std::vector lists, as it is
subject to change.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>name</td>
<td>string</td>
<td>Name of the function.</td>
</tr>
<tr class="row-odd"><td>addr</td>
<td>Address</td>
<td>Entry address of the
function.</td>
</tr>
<tr class="row-even"><td>entry</td>
<td>Block *</td>
<td>Entry block of the
function.</td>
</tr>
<tr class="row-odd"><td>parsed</td>
<td>bool</td>
<td>Whether the function
has been parsed.</td>
</tr>
<tr class="row-even"><td>blocks</td>
<td>blocklist &amp;</td>
<td>List of blocks
contained by this
function sorted by
entry address.</td>
</tr>
<tr class="row-odd"><td>callEdges</td>
<td>const edgelist &amp;</td>
<td>List of outgoing call
edges from this
function.</td>
</tr>
<tr class="row-even"><td>returnBlocks</td>
<td>const_blocklist &amp;</td>
<td>List of all blocks
ending in return
edges.</td>
</tr>
<tr class="row-odd"><td>exitBlocks</td>
<td>const_blocklist &amp;</td>
<td>List of all blocks
that end the
function, including
blocks with no
out-edges.</td>
</tr>
<tr class="row-even"><td>hasNoStackFrame</td>
<td>bool</td>
<td>True if the function
does not create a
stack frame.</td>
</tr>
<tr class="row-odd"><td>savesFramePointer</td>
<td>bool</td>
<td>True if the function
saves a frame pointer
(e.g. %ebp).</td>
</tr>
<tr class="row-even"><td>cleansOwnStack</td>
<td>bool</td>
<td>True if the function
tears down
stack-passed
arguments upon
return.</td>
</tr>
<tr class="row-odd"><td>region</td>
<td>CodeRegion *</td>
<td>Code region that
contains the
function.</td>
</tr>
<tr class="row-even"><td>isrc</td>
<td>InstructionSource *</td>
<td>The InstructionSource
for this function.</td>
</tr>
<tr class="row-odd"><td>obj</td>
<td>CodeObject *</td>
<td>CodeObject that
contains this
function.</td>
</tr>
<tr class="row-even"><td>src</td>
<td>FuncSrc</td>
<td>The type of hint that
identified this
function’s entry
point.</td>
</tr>
<tr class="row-odd"><td>restatus</td>
<td>FuncReturnStatus *</td>
<td>Returns the
best-effort
determination of
whether this function
may return or not.
Return status cannot
always be statically
determined, and at
most can guarantee
that a function <em>may</em>
return, not that it
<em>will</em> return.</td>
</tr>
<tr class="row-even"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing the
return type of the
function.</td>
</tr>
</tbody>
</table>
<p>Function(Address addr, string name, CodeObject * obj, CodeRegion *
region, InstructionSource * isource)</p>
<p>Creates a function at <code class="docutils literal notranslate"><span class="pre">addr</span></code> in the code region specified. Insructions
for this function are given in <code class="docutils literal notranslate"><span class="pre">isource</span></code>.</p>
<p>LoopTreeNode* getLoopTree()</p>
<p>Return the nesting tree of the loops in the function. See class
<code class="docutils literal notranslate"><span class="pre">LoopTreeNode</span></code> for more details</p>
<p>Loop* findLoop(const char *name)</p>
<p>Return the loop with the given nesting name. See class <code class="docutils literal notranslate"><span class="pre">LoopTreeNode</span></code>
for more details about how loop nesting names are assigned.</p>
<p>bool getLoops(vector&lt;Loop*&gt; &amp;loops);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">loops</span></code> with all the loops in the function</p>
<p>bool getOuterLoops(vector&lt;Loop*&gt; &amp;loops);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">loops</span></code> with all the outermost loops in the function</p>
<p>bool dominates(Block* A, Block *B);</p>
<p>Return true if block <code class="docutils literal notranslate"><span class="pre">A</span></code> dominates block <code class="docutils literal notranslate"><span class="pre">B</span></code></p>
<p>Block* getImmediateDominator(Block *A);</p>
<p>Return the immediate dominator of block <code class="docutils literal notranslate"><span class="pre">A</span></code>，<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the block
<code class="docutils literal notranslate"><span class="pre">A</span></code> does not have an immediate dominator.</p>
<p>void getImmediateDominates(Block *A, set&lt;Block*&gt; &amp;imm);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">imm</span></code> with all the blocks immediate dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>void getAllDominates(Block *A, set&lt;Block*&gt; &amp;dom);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">dom</span></code> with all the blocks dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>bool postDominates(Block* A, Block *B);</p>
<p>Return true if block <code class="docutils literal notranslate"><span class="pre">A</span></code> post-dominates block <code class="docutils literal notranslate"><span class="pre">B</span></code></p>
<p>Block* getImmediatePostDominator(Block *A);</p>
<p>Return the immediate post-dominator of block <code class="docutils literal notranslate"><span class="pre">A</span></code>，<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the
block <code class="docutils literal notranslate"><span class="pre">A</span></code> does not have an immediate post-dominator.</p>
<p>void getImmediatePostDominates(Block *A, set&lt;Block*&gt; &amp;imm);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">imm</span></code> with all the blocks immediate post-dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>void getAllPostDominates(Block *A, set&lt;Block*&gt; &amp;dom);</p>
<p>Fill <code class="docutils literal notranslate"><span class="pre">dom</span></code> with all the blocks post-dominated by block <code class="docutils literal notranslate"><span class="pre">A</span></code></p>
<p>std::vector&lt;FuncExtent *&gt; const&amp; extents()</p>
<p>Returns a list of contiguous extents of binary code within the function.</p>
<p>void setEntryBlock(block * new_entry)</p>
<p>Set the entry block for this function to <code class="docutils literal notranslate"><span class="pre">new_entry</span></code>.</p>
<p>void set_retstatus(FuncReturnStatus rs)</p>
<p>Set the return status for the function to <code class="docutils literal notranslate"><span class="pre">rs</span></code>.</p>
<p>bool contains(Block *b)</p>
<p>Return true if this function contains the given block <code class="docutils literal notranslate"><span class="pre">b</span></code>; otherwise
false.</p>
<p>void removeBlock(Block *)</p>
<p>Remove a basic block from the function.</p>
</div>
<div class="section" id="class-block">
<h2>Class Block<a class="headerlink" href="#class-block" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>A Block represents a basic block as defined in Section
<a class="reference external" href="#sec:abstractions">2</a>, and is the lowest level representation of
code in the CFG.</p>
<p>typedef std::vector&lt;Edge *&gt; edgelist</p>
<p>Container for edge access. Refer to Section <a class="reference external" href="#sec:containers">4.12</a>
for details. Library users <em>must not</em> rely on the underlying container
type of std::vector, as it is subject to change.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="27%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>start</td>
<td>Address</td>
<td>Address of the first
instruction in the block.</td>
</tr>
<tr class="row-odd"><td>end</td>
<td>Address</td>
<td>Address immediately following
the last instruction in the
block.</td>
</tr>
<tr class="row-even"><td>last</td>
<td>Address</td>
<td>Address of the last
instruction in the block.</td>
</tr>
<tr class="row-odd"><td>lastInsnAddr</td>
<td>Address</td>
<td>Alias of <code class="docutils literal notranslate"><span class="pre">last</span></code>.</td>
</tr>
<tr class="row-even"><td>size</td>
<td>Address</td>
<td>Size of the block; <code class="docutils literal notranslate"><span class="pre">end</span></code> -
<code class="docutils literal notranslate"><span class="pre">start</span></code>.</td>
</tr>
<tr class="row-odd"><td>parsed</td>
<td>bool</td>
<td>Whether the block has been
parsed.</td>
</tr>
<tr class="row-even"><td>obj</td>
<td>CodeObject *</td>
<td>CodeObject containing this
block.</td>
</tr>
<tr class="row-odd"><td>region</td>
<td>CodeRegion *</td>
<td>CodeRegion containing this
block.</td>
</tr>
<tr class="row-even"><td>sources</td>
<td>const edgelist &amp;</td>
<td>List of all in-edges to the
block.</td>
</tr>
<tr class="row-odd"><td>targets</td>
<td>const edgelist &amp;</td>
<td>List of all out-edges from
the block.</td>
</tr>
<tr class="row-even"><td>containingFuncs</td>
<td>int</td>
<td>Number of Functions that
contain this block.</td>
</tr>
</tbody>
</table>
<p>Block(CodeObject * o, CodeRegion * r, Address start, Function* f =
NULL)</p>
<p>Creates a block at <code class="docutils literal notranslate"><span class="pre">start</span></code> in the code region and code object
specified. Optionally, one can specify the function that will parse the
block. This constructor is used by the ParseAPI parser, which will
update its end address during parsing.</p>
<p>Block(CodeObject * o, CodeRegion * r, Address start, Address end,
Address last, Function* f = NULL)</p>
<p>Creates a block at <code class="docutils literal notranslate"><span class="pre">start</span></code> in the code region and code object
specified. The block has its last instruction at address <code class="docutils literal notranslate"><span class="pre">last</span></code> and
ends at address <code class="docutils literal notranslate"><span class="pre">end</span></code>. This constructor allows external parsers to
construct their own blocks.</p>
<p>bool consistent(Address addr, Address &amp; prev_insn)</p>
<p>Check whether address <code class="docutils literal notranslate"><span class="pre">addr</span></code> is <em>consistent</em> with this basic block. An
address is consistent if it is the boundary between two instructions in
the block. As long as <code class="docutils literal notranslate"><span class="pre">addr</span></code> is within the range of the block,
<code class="docutils literal notranslate"><span class="pre">prev_insn</span></code> will contain the address of the previous instruction
boundary before <code class="docutils literal notranslate"><span class="pre">addr</span></code>, regardless of whether <code class="docutils literal notranslate"><span class="pre">addr</span></code> is consistent
or not.</p>
<p>void getFuncs(std::vector&lt;Function *&gt; &amp; funcs)</p>
<p>Fills in the provided vector with all functions that share this basic
block.</p>
<p>template &lt;class OutputIterator&gt; void getFuncs(OutputIterator result)</p>
<p>Generic version of the above; adds each Function that contains this
block to the provided OutputIterator. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="nb">set</span><span class="o">&lt;</span><span class="n">Function</span> <span class="o">*&gt;</span> <span class="n">funcs</span><span class="p">;</span>
<span class="n">block</span><span class="o">-&gt;</span><span class="n">getFuncs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">inserter</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">funcs</span><span class="o">.</span><span class="n">begin</span><span class="p">()));</span>
</pre></div>
</div>
<p>typedef std::map&lt;Offset, InstructionAPI::Instruction::Ptr&gt; Insns void
getInsns(Insns &amp;insns) const</p>
<p>Disassembles the block and stores the result in <code class="docutils literal notranslate"><span class="pre">Insns</span></code>.</p>
<p>InstructionAPI::Instruction::Ptr getInsn(Offset o) const</p>
<p>Returns the instruction starting at offset <code class="docutils literal notranslate"><span class="pre">o</span></code> within the block.
Returns <code class="docutils literal notranslate"><span class="pre">InstructionAPI::Instruction::Ptr()</span></code> if <code class="docutils literal notranslate"><span class="pre">o</span></code> is outside the
block, or if an instruction does not begin at <code class="docutils literal notranslate"><span class="pre">o</span></code>.</p>
</div>
<div class="section" id="class-edge">
<h2>Class Edge<a class="headerlink" href="#class-edge" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>Typed Edges join two blocks in the CFG, indicating the type of control
flow transfer instruction that joins the blocks to each other. Edges may
not correspond to a control flow transfer instruction at all, as in the
case of the fallthrough edge that indicates where straight-line control
flow is split by incoming transfers from another location, such as a
branch. While not all blocks end in a control transfer instruction, all
control transfer instructions end basic blocks and have outgoing edges;
in the case of unresolvable control flow, the edge will target a special
“sink” block (see <code class="docutils literal notranslate"><span class="pre">sinkEdge()</span></code>, below).</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EdgeTypeEnum</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CALL</td>
<td>call edge</td>
</tr>
<tr class="row-odd"><td>COND_TAKEN</td>
<td>conditional branch–taken</td>
</tr>
<tr class="row-even"><td>COND_NOT_TAKEN</td>
<td>conditional branch–not taken</td>
</tr>
<tr class="row-odd"><td>INDIRECT</td>
<td>branch indirect</td>
</tr>
<tr class="row-even"><td>DIRECT</td>
<td>branch direct</td>
</tr>
<tr class="row-odd"><td>FALLTHROUGH</td>
<td>direct fallthrough (no branch)</td>
</tr>
<tr class="row-even"><td>CATCH</td>
<td>exception handler</td>
</tr>
<tr class="row-odd"><td>CALL_FT</td>
<td>post-call fallthrough</td>
</tr>
<tr class="row-even"><td>RET</td>
<td>return</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>src</td>
<td>Block *</td>
<td>Source of the edge.</td>
</tr>
<tr class="row-odd"><td>trg</td>
<td>Block *</td>
<td>Target of the edge.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>EdgeTypeEnum</td>
<td>Type of the edge.</td>
</tr>
<tr class="row-odd"><td>sinkEdge</td>
<td>bool</td>
<td>True if the target is the sink block.</td>
</tr>
<tr class="row-even"><td>interproc</td>
<td>bool</td>
<td>True if the edge should be
interpreted as interprocedural (e.g.
calls, returns, unconditional or
conditional tail calls).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="class-loop">
<h2>Class Loop<a class="headerlink" href="#class-loop" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>The Loop class represents code that may execute repeatedly. We detect
both natural loops (loops that have a single entry block) and
irreducible loops (loops that have multiple entry blocks). A back edge
is defined as an edge that has its source in the loop and has its target
being an entry block of the loop. It represents the end of an iteration
of the loop. For all the loops detected in a function, we also build a
loop nesting tree to represent the nesting relations between the loops.
See class <code class="docutils literal notranslate"><span class="pre">LoopTreeNode</span></code> for more details.</p>
<p>Loop* parent</p>
<p>Returns the loop which directly encloses this loop. NULL if no such
loop.</p>
<p>bool containsAddress(Address addr)</p>
<p>Returns true if the given address is within the range of this loop’s
basic blocks.</p>
<p>bool containsAddressInclusive(Address addr)</p>
<p>Returns true if the given address is within the range of this loop’s
basic blocks or its children.</p>
<p>int getLoopEntries(vector&lt;Block*&gt;&amp; entries);</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">entries</span></code> with the set of entry basic blocks of the loop. Return
the number of the entries that this loop has</p>
<p>int getBackEdges(vector&lt;Edge*&gt; &amp;edges)</p>
<p>Sets <code class="docutils literal notranslate"><span class="pre">edges</span></code> to the set of back edges in this loop. It returns the
number of back edges that are in this loop.</p>
<p>bool getContainedLoops(vector&lt;Loop*&gt; &amp;loops)</p>
<p>Returns a vector of loops that are nested under this loop.</p>
<p>bool getOuterLoops(vector&lt;Loop*&gt; &amp;loops)</p>
<p>Returns a vector of loops that are directly nested under this loop.</p>
<p>bool getLoopBasicBlocks(vector&lt;Block*&gt; &amp;blocks)</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">blocks</span></code> with all basic blocks in the loop</p>
<p>bool getLoopBasicBlocksExclusive(vector&lt;Block*&gt; &amp;blocks)</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">blocks</span></code> with all basic blocks in this loop, excluding the
blocks of its sub loops.</p>
<p>bool hasBlock(Block *b);</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this loop contains basic block <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>bool hasBlockExclusive(Block *b);</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this loop contains basic block <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> is
not in its sub loops.</p>
<p>bool hasAncestor(Loop *loop)</p>
<p>Returns true if this loop is a descendant of the given loop.</p>
<p>Function * getFunction();</p>
<p>Returns the function that this loop is in.</p>
</div>
<div class="section" id="class-looptreenode">
<h2>Class LoopTreeNode<a class="headerlink" href="#class-looptreenode" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>The LoopTreeNode class provides a tree interface to a collection of
instances of class Loop contained in a function. The structure of the
tree follows the nesting relationship of the loops in a function. Each
LoopTreeNode contains a pointer to a loop (represented by Loop), and a
set of sub-loops (represented by other LoopTreeNode objects). The
<code class="docutils literal notranslate"><span class="pre">loop</span></code> field at the root node is always <code class="docutils literal notranslate"><span class="pre">NULL</span></code> since a function may
contain multiple outer loops. The <code class="docutils literal notranslate"><span class="pre">loop</span></code> field is never <code class="docutils literal notranslate"><span class="pre">NULL</span></code> at
any other node since it always corresponds to a real loop. Therefore,
the outer most loops in the function are contained in the vector of
<code class="docutils literal notranslate"><span class="pre">children</span></code> of the root.</p>
<p>Each instance of LoopTreeNode is given a name that indicates its
position in the hierarchy of loops. The name of each outermost loop
takes the form of <code class="docutils literal notranslate"><span class="pre">loop_x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer from 1 to n,
where n is the number of outer loops in the function. Each sub-loop has
the name of its parent, followed by a <code class="docutils literal notranslate"><span class="pre">.y</span></code>, where <code class="docutils literal notranslate"><span class="pre">y</span></code> is 1 to m,
where m is the number of sub-loops under the outer loop. For example,
consider the following C function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span>
      <span class="o">...</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">foo</span></code> function will have a root LoopTreeNode, containing a NULL
loop entry and two LoopTreeNode children representing the functions
outermost loops. These children would have names <code class="docutils literal notranslate"><span class="pre">loop_1</span></code> and
<code class="docutils literal notranslate"><span class="pre">loop_2</span></code>, respectively representing the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> loops.
<code class="docutils literal notranslate"><span class="pre">loop_2</span></code> has no children. <code class="docutils literal notranslate"><span class="pre">loop_1</span></code> has two child LoopTreeNode
objects, named <code class="docutils literal notranslate"><span class="pre">loop_1.1</span></code> and <code class="docutils literal notranslate"><span class="pre">loop_1.2</span></code>, respectively representing
the <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> loops.</p>
<p>Loop *loop;</p>
<p>The Loop instance it points to.</p>
<p>std::vector&lt;LoopTreeNode *&gt; children;</p>
<p>The LoopTreeNode instances nested within this loop.</p>
<p>const char * name();</p>
<p>Returns the hierarchical name of this loop.</p>
<p>const char * getCalleeName(unsigned int i)</p>
<p>Returns the function name of the ith callee.</p>
<p>unsigned int numCallees()</p>
<p>Returns the number of callees contained in this loop’s body.</p>
<p>bool getCallees(vector&lt;Function *&gt; &amp;v);</p>
<p>Fills <code class="docutils literal notranslate"><span class="pre">v</span></code> with a vector of the functions called inside this loop.</p>
<p>Loop * findLoop(const char *name);</p>
<p>Looks up a loop by the hierarchical name</p>
</div>
<div class="section" id="class-codesource">
<span id="sec-codesource"></span><h2>Class CodeSource<a class="headerlink" href="#class-codesource" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CodeSource.h</span></code></p>
<p>The CodeSource interface is used by the ParseAPI to retrieve binary code
from an executable, library, or other binary code object; it also can
provide hints of function entry points (such as those derived from
debugging symbols) to seed the parser. The ParseAPI provides a default
implementation based on the SymtabAPI that supports many common binary
formats. For details on implementing a custom CodeSource, see Appendix
<a class="reference external" href="#sec:extend">5</a>.</p>
<p>virtual bool nonReturning(Address func_entry) virtual bool
nonReturning(std::string func_name)</p>
<p>Looks up whether a function returns (by name or location). This
information may be statically known for some code sources, and can lead
to better parsing accuracy.</p>
<p>virtual bool nonReturningSyscall(int /<em>number</em>/)</p>
<p>Looks up whether a system call returns (by system call number). This
information may be statically known for some code sources, and can lead
to better parsing accuracy.</p>
<p>virtual Address baseAddress() virtual Address loadAddress()</p>
<p>If the binary file type supplies non-zero base or load addresses (e.g.
Windows PE), implementations should override these functions.</p>
<p>std::map&lt; Address, std::string &gt; &amp; linkage()</p>
<p>Returns a reference to the external linkage map, which may or may not be
filled in for a particular CodeSource implementation.</p>
<p>struct Hint Address _addr; CodeRegion *_region; std::string _name;
Hint(Addr, CodeRegion *, std::string); std::vector&lt; Hint &gt; const&amp;
hints()</p>
<p>Returns a vector of the currently defined function entry hints.</p>
<p>std::vector&lt;CodeRegion *&gt; const&amp; regions()</p>
<p>Returns a read-only vector of code regions within the binary represented
by this code source.</p>
<p>int findRegions(Address addr, set&lt;CodeRegion *&gt; &amp; ret)</p>
<p>Finds all CodeRegion objects that overlap the provided address. Some
code sources (e.g. archive files) may have several regions with
overlapping address ranges; others (e.g. ELF binaries) do not.</p>
<p>bool regionsOverlap()</p>
<p>Indicates whether the CodeSource contains overlapping regions.</p>
</div>
<div class="section" id="class-parsecallback">
<h2>Class ParseCallback<a class="headerlink" href="#class-parsecallback" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">ParseCallback.h</span></code></p>
<p>The ParseCallback class allows ParseAPI users to be notified of various
events during parsing. For most users this notification is unnecessary,
and an instantiation of the default ParseCallback can be passed to the
CodeObject during initialization. Users who wish to be notified must
implement a class that inherits from ParseCallback, and implement one or
more of the methods described below to receive notification of those
events.</p>
<p>struct default_details default_details(unsigned char * b,size_t s, bool
ib); unsigned char * ibuf; size_t isize; bool isbranch;</p>
<p>Details used in the <code class="docutils literal notranslate"><span class="pre">unresolved_cf</span></code> and <code class="docutils literal notranslate"><span class="pre">abruptEnd_cf</span></code> callbacks.</p>
<p>virtual void instruction_cb(Function *, Block *, Address, insn_details
*)</p>
<p>Invoked for each instruction decoded during parsing. Implementing this
callback may incur significant overhead.</p>
<p>struct insn_details InsnAdapter::InstructionAdapter * insn;</p>
<p>void interproc_cf(Function *, Address, interproc_details *)</p>
<p>Invoked for each interprocedural control flow instruction.</p>
<p>struct interproc_details typedef enum ret, call, branch_interproc, //
tail calls, branches to plts syscall type_t; unsigned char * ibuf;
size_t isize; type_t type; union struct Address target; bool
absolute_address; bool dynamic_call; call; data;</p>
<p>Details used in the <code class="docutils literal notranslate"><span class="pre">interproc_cf</span></code> callback.</p>
<p>void overlapping_blocks(Block *, Block *)</p>
<p>Noification of inconsistent parse data (overlapping blocks).</p>
</div>
<div class="section" id="class-funcextent">
<h2>Class FuncExtent<a class="headerlink" href="#class-funcextent" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>Function Extents are used internally for accounting and lookup purposes.
They may be useful for users who wish to precisely identify the ranges
of the address space spanned by functions (functions are often
discontiguous, particularly on architectures with variable length
instruction sets).</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="21%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>func</td>
<td>Function *</td>
<td>Function linked to this extent.</td>
</tr>
<tr class="row-odd"><td>start</td>
<td>Address</td>
<td>Start of the extent.</td>
</tr>
<tr class="row-even"><td>end</td>
<td>Address</td>
<td>End of the extent (exclusive).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="edge-predicates">
<span id="sec-pred"></span><h2>Edge Predicates<a class="headerlink" href="#edge-predicates" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">CFG.h</span></code></p>
<p>Edge predicates control iteration over edges. For example, the provided
<code class="docutils literal notranslate"><span class="pre">Intraproc</span></code> edge predicate can be used with filter iterators and
standard algorithms, ensuring that only intraprocedural edges are
visited during iteration. Two other examples of edge predicates are
provided: <code class="docutils literal notranslate"><span class="pre">SingleContext</span></code> only visits edges that stay in a single
function context, and <code class="docutils literal notranslate"><span class="pre">NoSinkPredicate</span></code> does not visit edges to the
<em>sink</em> block. The following code traverses all of the basic blocks
within a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;boost/filter_iterator.hpp&gt;
using boost::make_filter_iterator;
struct target_block
{
  Block* operator()(Edge* e) { return e-&gt;trg(); }
};


vector&lt;Block*&gt; work;
Intraproc epred; // ignore calls, returns

work.push_back(func-&gt;entry()); // assuming `func&#39; is a Function*

// do_stuff is a functor taking a Block* as its argument
while(!work.empty()) {
    Block * b = work.back();
    work.pop_back();

    Block::edgelist &amp; targets = block-&gt;targets();
    // Do stuff for each out edge
    std::for_each(make_filter_iterator(targets.begin(), epred),
                  make_filter_iterator(targets.end(), epred),
                  do_stuff());
    std::transform(make_filter_iterator(targets.begin(), epred),
                   make_filter_iterator(targets.end(), epred),
                   std::back_inserter(work),
                   std::mem_fun(Edge::trg));
    Block::edgelist::const_iterator found_interproc =
            std::find_if(targets.begin(), targets.end(), Interproc());
    if(interproc != targets.end()) {
            // do something with the interprocedural edge you found
    }
}
</pre></div>
</div>
<p>Anything that can be treated as a function from <code class="docutils literal notranslate"><span class="pre">Edge*</span></code> to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>
can be used in this manner. This replaces the beta interface where all
<code class="docutils literal notranslate"><span class="pre">EdgePredicate</span></code>s needed to descend from a common parent class. Code
that previously constructed iterators from an edge predicate should be
replaced with equivalent code using filter iterators as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">OLD</span>
<span class="k">for</span><span class="p">(</span><span class="n">Block</span><span class="p">::</span><span class="n">edgelist</span><span class="p">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">epred</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">epred</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">NEW</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">()),</span>
         <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">targets</span><span class="p">,</span><span class="n">end</span><span class="p">()),</span>
         <span class="n">loop_body_as_function</span><span class="p">);</span>
<span class="o">//</span> <span class="n">NEW</span> <span class="p">(</span><span class="n">C</span><span class="o">++</span><span class="mi">11</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="n">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">epred</span><span class="p">,</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">targets</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="containers">
<span id="sec-containers"></span><h2>Containers<a class="headerlink" href="#containers" title="Permalink to this headline"></a></h2>
<p>Several of the ParseAPI data structures export containers of CFG
objects; the CodeObject provides a list of functions in the binary, for
example, while functions provide lists of blocks and so on. To avoid
tying the internal storage for these structures to any particular
container type, ParseAPI objects export a ContainerWrapper that provides
an iterator interface to the internal containers. These wrappers and
predicate interfaces are designed to add minimal overhead while
protecting ParseAPI users from exposure to internal container storage
details. Users <em>must not</em> rely on properties of the underlying container
type (e.g. storage order) unless that property is explicity stated in
this manual.</p>
<p>ContainerWrapper containers export the following interface (<code class="docutils literal notranslate"><span class="pre">iterator</span></code>
types vary depending on the template parameters of the ContainerWrapper,
but are always instantiations of the PredicateIterator described below):</p>
<p>iterator begin() iterator begin(predicate *)</p>
<p>Return an iterator pointing to the beginning of the container, with or
without a filtering predicate implementation (see Section
<a class="reference external" href="#sec:pred">4.11</a> for details on filter predicates).</p>
<p>iterator const&amp; end()</p>
<p>Return the iterator pointing to the end of the container (past the last
element).</p>
<p>size_t size()</p>
<p>Returns the number of elements in the container. Execution cost may vary
depending on the underlying container type.</p>
<p>bool empty()</p>
<p>Indicates whether the container is empty or not.</p>
<p>The elements in ParseAPI containers can be accessed by iteration using
an instantiation of the PredicateIterator. These iterators can
optionally act as filters, evaluating a boolean predicate for each
element and only returning those elements for which the predicate
returns true. <em>Iterators with non-null predicates may return fewer
elements during iteration than their “size()“ method indicates.</em>
Currently PredicateIterators only support forward iteration. The
operators <code class="docutils literal notranslate"><span class="pre">++</span></code> (prefix and postfix), <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, and <code class="docutils literal notranslate"><span class="pre">*</span></code>
(dereference) are supported.</p>
</div>
</div>
<div class="section" id="extending-parseapi">
<span id="sec-extend"></span><h1>Extending ParseAPI<a class="headerlink" href="#extending-parseapi" title="Permalink to this headline"></a></h1>
<p>The ParseAPI is design to be a low level toolkit for binary analysis
tools. Users can extend the ParseAPI in two ways: by extending the
control flow structures (Functions, Blocks, and Edges) to incorporate
additional data to support various analysis applications, and by adding
additional binary code sources that are unsupported by the default
SymtabAPI-based code source. For example, a code source that represents
a program image in memory could be implemented by fulfilling the
CodeSource and InstructionSource interfaces described in Section
<a class="reference external" href="#sec:codesource">4.8</a> and below. Implementations that extend the CFG
structures need only provide a custom allocation factory in order for
these objects to be allocated during parsing.</p>
<div class="section" id="instruction-and-code-sources">
<h2>Instruction and Code Sources<a class="headerlink" href="#instruction-and-code-sources" title="Permalink to this headline"></a></h2>
<p>A CodeSource, as described above, exports its own and the
InstructionSource interface for access to binary code and other details.
In addition to implementing the virtual methods in the CodeSource base
class (Section <a class="reference external" href="#sec:codesource">4.8</a>), the methods in the
pure-virtual InstructionSource class must be implemented:</p>
<p>virtual bool isValidAddress(const Address)</p>
<p>Returns true if the address is a valid code location.</p>
<p>virtual void* getPtrToInstruction(const Address)</p>
<p>Returns pointer to raw memory in the binary at the provided address.</p>
<p>virtual void* getPtrToData(const Address)</p>
<p>Returns pointer to raw memory in the binary at the provided address. The
address need not correspond to an executable code region.</p>
<p>virtual unsigned int getAddressWidth()</p>
<p>Returns the address width (e.g. four or eight bytes) for the represented
binary.</p>
<p>virtual bool isCode(const Address)</p>
<p>Indicates whether the location is in a code region.</p>
<p>virtual bool isData(const Address)</p>
<p>Indicates whether the location is in a data region.</p>
<p>virtual Address offset()</p>
<p>The start of the region covered by this instruction source.</p>
<p>virtual Address length()</p>
<p>The size of the region.</p>
<p>virtual Architecture getArch()</p>
<p>The architecture of the instruction source. See the Dyninst manual for
details on architecture differences.</p>
<p>virtual bool isAligned(const Address)</p>
<p>For fixed-width instruction architectures, must return true if the
address is a valid instruction boundary and false otherwise; otherwise
returns true. This method has a default implementation that should be
sufficient.</p>
<p>CodeSource implementors need to fill in several data structures in the
base CodeSource class:</p>
<p>std::map&lt;Address, std::string&gt; _linkage</p>
<p>Entries in the linkage map represent external linkage, e.g. the PLT in
ELF binaries. Filling in this map is optional.</p>
<p>Address _table_of_contents</p>
<p>Many binary format have “table of contents” structures for position
independant references. If such a structure exists, its address should
be filled in.</p>
<p>std::vector&lt;CodeRegion *&gt; _regions Dyninst::IBSTree&lt;CodeRegion&gt;
_region_tree</p>
<p>One or more contiguous regions of code or data in the binary object must
be registered with the base class. Keeping these structures in sync is
the responsibility of the implementing class.</p>
<p>std::vector&lt;Hint&gt; _hints</p>
<p>CodeSource implementors can supply a set of Hint objects describing
where functions are known to start in the binary. These hints are used
to seed the parsing algorithm. Refer to the CodeSource header file for
implementation details.</p>
</div>
<div class="section" id="cfg-object-factories">
<span id="sec-factories"></span><h2>CFG Object Factories<a class="headerlink" href="#cfg-object-factories" title="Permalink to this headline"></a></h2>
<p>Users who which to incorporate the ParseAPI into large projects may need
to store additional information about CFG objects like Functions,
Blocks, and Edges. The simplest way to associate the ParseAPI-level CFG
representation with higher-level implementation is to extend the CFG
classes provided as part of the ParseAPI. Because the parser itself does
not know how to construct such extended types, implementors must provide
an implementation of the CFGFactory that is specialized for their CFG
classes. The CFGFactory exports the following simple interface:</p>
<p>virtual Function * mkfunc(Address addr, FuncSource src, std::string
name, CodeObject * obj, CodeRegion * region,
Dyninst::InstructionSource * isrc)</p>
<p>Returns an object derived from Function as though the provided
parameters had been passed to the Function constructor. The ParseAPI
parser will never invoke <code class="docutils literal notranslate"><span class="pre">mkfunc()</span></code> twice with identical <code class="docutils literal notranslate"><span class="pre">addr</span></code>, and
<code class="docutils literal notranslate"><span class="pre">region</span></code> parameters—that is, Functions are guaranteed to be unique by
address within a region.</p>
<p>virtual Block * mkblock(Function * func, CodeRegion * region, Address
addr)</p>
<p>Returns an object derived from Block as though the provided parameters
had been passed to the Block constructor. The parser will never invoke
<code class="docutils literal notranslate"><span class="pre">mkblock()</span></code> with identical <code class="docutils literal notranslate"><span class="pre">addr</span></code> and <code class="docutils literal notranslate"><span class="pre">region</span></code> parameters.</p>
<p>virtual Edge * mkedge(Block * src, Block * trg, EdgeTypeEnum type)</p>
<p>Returns an object derived from Edge as though the provided parameters
had been passed to the Edge constructor. The parser <em>may</em> invoke
<code class="docutils literal notranslate"><span class="pre">mkedge()</span></code> multiple times with identical parameters.</p>
<p>virtual Block * mksink(CodeObject *obj, CodeRegion *r)</p>
<p>Returns a “sink” block derived from Block to which all unresolvable
control flow instructions will be linked. Implementors may return a
unique sink block per CodeObject or a single global sink.</p>
<p>Implementors of extended CFG classes are required to override the
default implementations of the <em>mk*</em> functions to allocate and return
the appropriate derived types statically cast to the base type.
Implementors must also add all allocated objects to the following
internal lists:</p>
<p>fact_list&lt;Edge&gt; edges_ fact_list&lt;Block&gt; blocks_ fact_list&lt;Function&gt;
funcs_</p>
<p>O(1) allocation lists for CFG types. See the CFG.h header file for list
insertion and removal operations.</p>
<p>Implementors <em>may</em> but are <em>not required to</em> override the deallocation
following deallocation routines. The primary reason to override these
routines is if additional action or cleanup is necessary upon CFG object
release; the default routines simply remove the objects from the
allocation list and invoke their destructors.</p>
<p>virtual void free_func(Function * f) virtual void free_block(Block *
b) virtual void free_edge(Edge * e) virtual void free_all()</p>
<p>CFG objects should be freed using these functions, rather than delete,
to avoid leaking memory.</p>
</div>
</div>
<div class="section" id="defensive-mode-parsing">
<span id="sec-defmode"></span><h1>Defensive Mode Parsing<a class="headerlink" href="#defensive-mode-parsing" title="Permalink to this headline"></a></h1>
<p>Binary code that defends itself against analysis may violate the
assumptions made by the the ParseAPI’s standard parsing algorithm.
Enabling defensive mode parsing activates more conservative assumptions
that substantially reduce the percentage of code that is analyzed by the
ParseAPI. For this reason, defensive mode parsing is best-suited for use
of ParseAPI in conjunction with dynamic analysis techniques that can
compensate for its limited coverage of the binary code.</p>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../instructionAPI/index.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../patchAPI/index.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>