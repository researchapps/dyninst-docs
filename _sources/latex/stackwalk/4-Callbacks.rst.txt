Callback Interface Default Implementations
==========================================

StackwalkerAPI provides one or more default implementations of each of
the callback classes described in Section 3.5. These implementations are
used by a default configuration of StackwalkerAPI.

.. _`subsec:debugger`:

Debugger Interface
------------------

This section describes how to use StackwalkerAPI for collecting 3rd
party stack walks. In 3rd party mode StackwalkerAPI uses the OS’s
debugger interface to connect to another process and walk its call
stacks. As part of being a debugger StackwalkerAPI receives and needs to
handle debug events. When a debugger event occurs, StackwalkerAPI must
get control of the host process in order to receive the debugger event
and continue the target process.

To illustrate the complexities with running in 3rd party mode, consider
the follow code snippet that uses StackwalkerAPI to collect a stack walk
every five seconds.

::

   Walker *walker = Walker::newWalker(pid);
   std::vector<Frame> swalk;
   for (;;) {
           walker->walkStack(swalk);
           sleep(5);
   }

StackwalkerAPI is running in 3rd party mode, since it attached to the
target process, . As the target process runs it may be generating debug
events such a thread creation and destruction, library loads and
unloads, signals, forking/execing, etc. When one of these debugger
events is generated the OS will pause the target process and send a
notice to the host process. The target process will remain paused until
the host process handles the debug event and resumes the target process.

In the above example the host process is spending almost all of its time
in the sleep call. If a debugger event happens during the sleep, then
StackwalkerAPI will not be able to get control of the host process and
handle the event for up to five seconds. This will cause long pauses in
the target process and lead to a potentially very large slowdown.

To work around this problem StackwalkerAPI provides a notification file
descriptor. This file descriptor represents a connection between the
StackwalkerAPI library and user code. StackwalkerAPI will write a single
byte to this file descriptor when a debug event occurs, thus notifying
the user code that it needs to let StackwalkerAPI receive and handle
debug events. The user code can use system calls such as select to watch
for events on the notification file descriptor.

The following example illustrates how to properly use StackwalkerAPI to
collect a stack walk from another process at a five second interval.
Details on the class, method, and method can be found in
Section `1.1.1 <#subsubsec:procdebug>`__. See the UNIX man pages for
more information on the system call. Note that this example does not
include all of the proper error handling and includes that should be
present when using .

::

   Walker *walker = Walker::newWalker(pid);
   ProcDebug *debugger = (ProcDebug *) walker->getProcessState();
   std::vector<Frame> swalk;
   for (;;) {
       walker->walkStack(swalk);       
       struct timeval timeout;
       timeout.tv_sec = 5;
       timeout.tv_usec = 0;
       int max = 1;
       fd_set readfds, writefds, exceptfds;
       FD_ZERO(&readfds); FD_ZERO(&writefds); FD_ZERO(&exceptfds);
       FD_SET(ProcDebug::getNotificationFD(), &readfds);
       for (;;) {
           int result = select(max, &readfds, &writefds, &exceptfds, &timeout);
           if (FD_ISSET(ProcDebug::getNotificationFD(), readfds)) {
               //Debug event
               ProcDebug::handleDebugEvent();
           }
           if (result == 0) {
               //Timeout
               break;
           }
       }
   }

.. _`subsubsec:procdebug`:

Class ProcDebug
~~~~~~~~~~~~~~~

Access to StackwalkerAPI’s debugger is through the class, which inherits
from the interface. The easiest way to get at a object is to cast the
return value of into a . C++’s operation can be used to test if a uses
the interface:

::

   ProcDebug *debugger;
   debugger = dynamic_cast<ProcDebug*>(walker->getProcessState());
   if (debugger != NULL) {
       //3rd party
       ...
   } else {
       //1st party
       ...
   }

In addition to the handling of debug events, described in
Section `1.1 <#subsec:debugger>`__, the class provides a process control
interface; users can pause and resume process or threads, detach from a
process, and test for events such as process death. As an implementation
of the class, also provides all of the functionality described in
Section `[subsec:processstate] <#subsec:processstate>`__.

.. container:: apient

   virtual bool pause(Dyninst::THR_ID tid = NULL_THR_ID)

.. container:: apient

   virtual bool resume(Dyninst::THR_ID tid = NULL_THR_ID)

.. container:: apient

   virtual bool detach(bool leave_stopped = false)

.. container:: apient

   virtual bool isTerminated()

.. container:: apient

   static int getNotificationFD()

.. container:: apient

   static bool handleDebugEvent(bool block = false)

.. _`sec:framesteppers`:

FrameSteppers
-------------

StackwalkerAPI ships with numerous default implementations of the class.
Each of these implementations allow StackwalkerAPI to walk a type of
call frames. Section `[subsec:defaults] <#subsec:defaults>`__ describes
which implementations are available on which platforms. This sections
gives a brief description of what each implementation does. Each of the
following classes implements the interface described in
Section `[subsec:framestepper] <#subsec:framestepper>`__, so we do not
repeat the API description for the classes here.

Several of the s use helper classes (see as an example). Users can
further customize the behavior of a by providing their own
implementation of these helper classes.

Class FrameFuncStepper
~~~~~~~~~~~~~~~~~~~~~~

This class implements stack walking through a call frame that is setup
with the architectures standard stack frame. For example, on x86 this
will be used to walk through stack frames that are setup with a
prologue.

Class FrameFuncHelper
^^^^^^^^^^^^^^^^^^^^^

uses a helper class, , to get information on what kind of stack frame
it’s walking through. The will generally use techniques such as binary
analysis to determine what type of stack frame the is walking through.
Users can have StackwalkerAPI use their own binary analysis mechanisms
by providing an implementation of this .

There are two important types used by and one important function:

.. container:: apient

   typedef enum unknown_t=0, no_frame, standard_frame,
   savefp_only_frame, frame_type;

.. container:: apient

   typedef enum unknown_s=0, unset_frame, halfset_frame, set_frame
   frame_state;

.. container:: apient

   typedef std::pair<frame_type, frame_state> alloc_frame_t; virtual
   alloc_frame_t allocatesFrame(Address addr) = 0;

Class SigHandlerStepper
~~~~~~~~~~~~~~~~~~~~~~~

The is used to walk through UNIX signal handlers as found on the call
stack. On some systems a signal handler generates a special kind of
stack frame that cannot be walked through using normal stack walking
techniques.

Class DebugStepper
~~~~~~~~~~~~~~~~~~

This class uses debug information found in a binary to walk through a
stack frame. It depends on SymtabAPI to read debug information from a
binary, then uses that debug information to walk through a call frame.

Most binaries must be built with debug information ( with ) in order to
include debug information that this uses. Some languages, such as C++,
automatically include stackwalking debug information for use by
exceptions. The class will also make use of this kind of exception
information if it is available.

Class AnalysisStepper
~~~~~~~~~~~~~~~~~~~~~

This class uses dataflow analysis to determine possible stack sizes at
all locations in a function as well as the location of the frame
pointer. It is able to handle optimized code with omitted frame pointers
and overlapping code sequences.

Class StepperWanderer
~~~~~~~~~~~~~~~~~~~~~

This class uses a heuristic approach to find possible return addresses
in the stack frame. If a return address is found that matches a valid
caller of the current function, we conclude it is the actual return
address and construct a matching stack frame. Since this approach is
heuristic it can make mistakes leading to incorrect stack information.
It has primarily been replaced by the described above.

Class BottomOfStackStepper
~~~~~~~~~~~~~~~~~~~~~~~~~~

The doesn’t actually walk through any type of call frame. Instead it
attempts to detect whether the bottom of the call stack has been
reached. If so, will report from its method. Otherwise it will report .
runs with a higher priority than any other class.
