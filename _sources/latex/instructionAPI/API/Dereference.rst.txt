.. _`sec:dereference`:

Dereference Class
-----------------

A object is an that dereferences another .

A contains an representing an effective address computation. Its use set
is the same as the use set of the being dereferenced.

It is not possible, given the information in a single instruction, to
evaluate the result of a dereference. may still be called on an that
includes dereferences, but the expected use case is as follows:

-  Determine the address being used in a dereference via the mechanism

-  Perform analysis to determine the contents of that address

-  If necessary, fill in the node with the contents of that addresss,
   using

The type associated with a node will be the type of the value *read*
*from* *memory*, not the type used for the address computation. Two s
that access the same address but interpret the contents of that memory
as different types will produce different values. The children of a at a
given address are identical, regardless of the type of dereference being
performed at that address. For example, the shown in Figure 6 could have
its root , which interprets the memory being dereferenced as a unsigned
16-bit integer, replaced with a that interprets the memory being
dereferenced as any other type. The remainder of the tree would,
however, remain unchanged.

.. container:: apient

   Dereference (Expression::Ptr addr, Result_Type result_type)

.. container:: apient

   virtual void getChildren (vector< InstructionAST::Ptr > & children)
   const

.. container:: apient

   virtual void getUses (set< InstructionAST::Ptr > & uses)

.. container:: apient

   virtual bool isUsed (InstructionAST::Ptr findMe) const
