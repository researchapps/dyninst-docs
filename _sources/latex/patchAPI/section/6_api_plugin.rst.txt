.. _sec-plugin-api:

Plugin API Reference
====================

This section describes the various plugin interfaces for extending
PatchAPI. We expect that most users should not have to ever explicitly
use an interface from this section; instead, they will use plugins
previously implemented by PatchAPI developers.

As with the public interface, all objects and methods in this section
are in the “Dyninst::PatchAPI” namespace.

.. _sec-3.2.1:

AddrSpace
---------

**Declared in**: AddrSpace.h

The AddrSpace class represents the address space of a **Mutatee**, where
it contains a collection of **PatchObjects** that represent shared
libraries or a binary executable. In addition, programmers implement
some memory management interfaces in the AddrSpace class to determine
the type of the code patching - 1st party, 3rd party, or binary
rewriting.

.. container:: apient

   virtual bool write(PatchObject\* obj, Address to, Address from,
   size_t size);

.. container:: apient

   virtual Address malloc(PatchObject\* obj, size_t size, Address near);

.. container:: apient

   virtual Address realloc(PatchObject\* obj, Address orig, size_t
   size);

.. container:: apient

   virtual bool free(PatchObject\* obj, Address orig);

.. container:: apient

   virtual bool loadObject(PatchObject\* obj);

.. container:: apient

   typedef std::map<const ParseAPI::CodeObject*, PatchObject*>
   AddrSpace::ObjMap;

   ObjMap& objMap();

.. container:: apient

   PatchObject\* executable();

.. container:: apient

   PatchMgrPtr mgr();

.. _sec-3.2.2:

Snippet
-------

**Declared in**: Snippet.h

The Snippet class allows programmers to customize their own snippet
representation and the corresponding mini-compiler to translate the
representation into the binary code.

.. container:: apient

   static Ptr create(Snippet\* a);

.. container:: apient

   virtual bool generate(Point \*pt, Buffer &buf);

.. _sec-3.2.3:

Command
-------

**Declared in**: Command.h

The Command class represents an instrumentation request (e.g., snippet
insertion or removal), or an internal logical step in the code patching
(e.g., install instrumentation).

.. container:: apient

   virtual bool run() = 0;

.. container:: apient

   virtual bool undo() = 0;

.. container:: apient

   virtual bool commit();

::

   if (run()) {
     return true;
   } else {
     undo();
     return false;
   }

.. _sec-3.2.4:

BatchCommand
------------

**Declared in**: Command.h

The BatchCommand class inherits from the Command class. It is actually a
container of a list of Commands that will be executed in a transaction:
all Commands will succeed, or all will fail.

.. container:: apient

   typedef std::list<CommandPtr> CommandList;

   CommandList to_do_; CommandList done_;

.. container:: apient

   virtual bool run(); virtual bool undo();

.. container:: apient

   void add(CommandPtr command);

.. container:: apient

   void remove(CommandList::iterator iter);

.. _sec-3.2.5:

Instrumenter
------------

**Declared in**: Command.h

The Instrumenter class inherits BatchCommand to encapsulate the core
code patching logic, which includes binary code generation. Instrumenter
would contain several logical steps that are individual Commands.

.. container:: apient

   CommandList user_commands_;

.. container:: apient

   static InstrumenterPtr create(AddrSpacePtr as);

.. container:: apient

   virtual bool replaceFunction(PatchFunction\* oldfunc, PatchFunction\*
   newfunc);

.. container:: apient

   virtual bool revertReplacedFunction(PatchFunction\* oldfunc);

.. container:: apient

   typedef std::map<PatchFunction*, PatchFunction*> FuncModMap;

.. container:: apient

   virtual FuncModMap& funcRepMap();

.. container:: apient

   virtual bool wrapFunction(PatchFunction\* oldfunc, PatchFunction\*
   newfunc, string name);

::

   void *malloc_wrapper(int size) {
     // do stuff
     void *ret = malloc_clone(size);
     // do more stuff
     return ret;
   }

.. container:: apient

   virtual bool revertWrappedFunction(PatchFunction\* oldfunc);

.. container:: apient

   virtual FuncModMap& funcWrapMap();

.. container:: apient

   bool modifyCall(PatchBlock \*callBlock, PatchFunction \*newCallee,
   PatchFunction \*context = NULL);

.. container:: apient

   bool revertModifiedCall(PatchBlock \*callBlock, PatchFunction
   \*context = NULL);

.. container:: apient

   bool removeCall(PatchBlock \*callBlock, PatchFunction \*context =
   NULL);

.. container:: apient

   typedef map<PatchBlock*, // B : A call block map<PatchFunction*, //
   F_c: Function context PatchFunction*> // F : The function to be
   replaced > CallModMap;

.. container:: apient

   CallModMap& callModMap();

.. container:: apient

   AddrSpacePtr as() const;

.. _sec-3.2.6:

Patcher
-------

**Declared in**: Command.h

The class Patcher inherits from the class BatchCommand. It accepts
instrumentation requests from users, where these instrumentation
requests are Commands (e.g., snippet insertion). Furthermore, Patcher
implicitly adds an instance of Instrumenter to the end of the Command
list to generate binary code and install the instrumentation.

.. container:: apient

   Patcher(PatchMgrPtr mgr)

.. container:: apient

   virtual bool run();

.. _sec-3.2.12:

CFGMaker
--------

**Declared in**: CFGMaker.h

The CFGMaker class is a factory class that constructs the above CFG
structures (PatchFunction, PatchBlock, and PatchEdge). The methods in
this class are used by PatchObject. Programmers can extend
PatchFunction, PatchBlock and PatchEdge by annotating their own data,
and then use this class to instantiate these CFG structures.

.. container:: apient

   virtual PatchFunction\* makeFunction(ParseAPI::Function\* func,
   PatchObject\* obj); virtual PatchFunction\*
   copyFunction(PatchFunction\* func, PatchObject\* obj);

   virtual PatchBlock\* makeBlock(ParseAPI::Block\* blk, PatchObject\*
   obj); virtual PatchBlock\* copyBlock(PatchBlock\* blk, PatchObject\*
   obj);

   virtual PatchEdge\* makeEdge(ParseAPI::Edge\* edge, PatchBlock\* src,
   PatchBlock\* trg, PatchObject\* obj); virtual PatchEdge\*
   copyEdge(PatchEdge\* edge, PatchObject\* obj);

.. _sec-3.2.13:

PointMaker
----------

**Declared in**: Point.h

The PointMaker class is a factory class that constructs instances of the
Point class. The methods of the PointMaker class are invoked by
PatchMgr’s findPoint methods. Programmers can extend the Point class,
and then implement a set of virtual methods in this class to instantiate
the subclasses of Point.

.. container:: apient

   PointMaker(PatchMgrPtr mgr);

.. container:: apient

   virtual Point \*mkFuncPoint(Point::Type t, PatchMgrPtr m,
   PatchFunction \*f); virtual Point \*mkFuncSitePoint(Point::Type t,
   PatchMgrPtr m, PatchFunction \*f, PatchBlock \*b); virtual Point
   \*mkBlockPoint(Point::Type t, PatchMgrPtr m, PatchBlock \*b,
   PatchFunction \*context); virtual Point \*mkInsnPoint(Point::Type t,
   PatchMgrPtr m, PatchBlock \*, Address a,
   InstructionAPI::Instruction::Ptr i, PatchFunction \*context); virtual
   Point \*mkEdgePoint(Point::Type t, PatchMgrPtr m, PatchEdge \*e,
   PatchFunction \*context);

.. _sec-3.3:

Default Plugin
--------------

.. _sec-3.3.1:

PushFrontCommand and PushBackCommand
------------------------------------

**Declared in**: Command.h

The class PushFrontCommand and the class PushBackCommand inherit from
the Command class. They are to insert a snippet to a point. A point
maintains a list of snippet instances. PushFrontCommand would add the
new snippet instance to the front of the list, while PushBackCommand
would add to the end of the list.

.. container:: apient

   static Ptr create(Point\* pt, SnippetPtr snip);

.. container:: apient

   InstancePtr instance();

.. _sec-3.3.2:

RemoveSnippetCommand
--------------------

**Declared in**: Command.h

The class RemoveSnippetCommand inherits from the Command class. It is to
delete a snippet Instance.

.. container:: apient

   static Ptr create(InstancePtr instance);

.. _sec-3.3.3:

RemoveCallCommand
-----------------

**Declared in**: Command.h

The class RemoveCallCommand inherits from the class Command. It is to
remove a function call.

.. container:: apient

   static Ptr create(PatchMgrPtr mgr, PatchBlock\* call_block,
   PatchFunction\* context = NULL);

.. _sec-3.3.4:

ReplaceCallCommand
------------------

**Declared in**: Command.h

The class ReplaceCallCommand inherits from the class Command. It is to
replace a function call with another function.

.. container:: apient

   static Ptr create(PatchMgrPtr mgr, PatchBlock\* call_block,
   PatchFunction\* new_callee, PatchFunction\* context);

.. _sec-3.3.5:

ReplaceFuncCommand
------------------

**Declared in**: Command.h

The class ReplaceFuncCommand inherits from the class Command. It is to
replace an old function with the new one.

.. container:: apient

   static Ptr create(PatchMgrPtr mgr, PatchFunction\* old_func,
   PatchFunction\* new_func);
