.. _`sec:extend`:

Extending ParseAPI
==================

The ParseAPI is design to be a low level toolkit for binary analysis
tools. Users can extend the ParseAPI in two ways: by extending the
control flow structures (Functions, Blocks, and Edges) to incorporate
additional data to support various analysis applications, and by adding
additional binary code sources that are unsupported by the default
SymtabAPI-based code source. For example, a code source that represents
a program image in memory could be implemented by fulfilling the
CodeSource and InstructionSource interfaces described in Section
`[sec:codesource] <#sec:codesource>`__ and below. Implementations that
extend the CFG structures need only provide a custom allocation factory
in order for these objects to be allocated during parsing.

Instruction and Code Sources
----------------------------

A CodeSource, as described above, exports its own and the
InstructionSource interface for access to binary code and other details.
In addition to implementing the virtual methods in the CodeSource base
class (Section `[sec:codesource] <#sec:codesource>`__), the methods in
the pure-virtual InstructionSource class must be implemented:

.. container:: apient

   virtual bool isValidAddress(const Address)

.. container:: apient

   virtual void\* getPtrToInstruction(const Address)

.. container:: apient

   virtual void\* getPtrToData(const Address)

.. container:: apient

   virtual unsigned int getAddressWidth()

.. container:: apient

   virtual bool isCode(const Address)

.. container:: apient

   virtual bool isData(const Address)

.. container:: apient

   virtual Address offset()

.. container:: apient

   virtual Address length()

.. container:: apient

   virtual Architecture getArch()

.. container:: apient

   virtual bool isAligned(const Address)

CodeSource implementors need to fill in several data structures in the
base CodeSource class:

.. container:: apient

   std::map<Address, std::string> \_linkage

.. container:: apient

   Address \_table_of_contents

.. container:: apient

   std::vector<CodeRegion \*> \_regions Dyninst::IBSTree<CodeRegion>
   \_region_tree

.. container:: apient

   std::vector<Hint> \_hints

.. _`sec:factories`:

CFG Object Factories
--------------------

Users who which to incorporate the ParseAPI into large projects may need
to store additional information about CFG objects like Functions,
Blocks, and Edges. The simplest way to associate the ParseAPI-level CFG
representation with higher-level implementation is to extend the CFG
classes provided as part of the ParseAPI. Because the parser itself does
not know how to construct such extended types, implementors must provide
an implementation of the CFGFactory that is specialized for their CFG
classes. The CFGFactory exports the following simple interface:

.. container:: apient

   virtual Function \* mkfunc(Address addr, FuncSource src, std::string
   name, CodeObject \* obj, CodeRegion \* region,
   Dyninst::InstructionSource \* isrc)

.. container:: apient

   virtual Block \* mkblock(Function \* func, CodeRegion \* region,
   Address addr)

.. container:: apient

   virtual Edge \* mkedge(Block \* src, Block \* trg, EdgeTypeEnum type)

.. container:: apient

   virtual Block \* mksink(CodeObject \*obj, CodeRegion \*r)

Implementors of extended CFG classes are required to override the
default implementations of the *mk\** functions to allocate and return
the appropriate derived types statically cast to the base type.
Implementors must also add all allocated objects to the following
internal lists:

.. container:: apient

   fact_list<Edge> edges\_ fact_list<Block> blocks\_ fact_list<Function>
   funcs\_

Implementors *may* but are *not required to* override the deallocation
following deallocation routines. The primary reason to override these
routines is if additional action or cleanup is necessary upon CFG object
release; the default routines simply remove the objects from the
allocation list and invoke their destructors.

.. container:: apient

   virtual void free_func(Function \* f) virtual void free_block(Block
   \* b) virtual void free_edge(Edge \* e) virtual void free_all()
