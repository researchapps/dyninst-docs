.. _`sec:example`:

Examples
========

Function Disassembly
--------------------

The following example uses ParseAPI and InstructionAPI to disassemble
the basic blocks in a function. As an example, it can be built with G++
as follows: . Note: this example must be compiled with C++11x support;
for G++ this is enabled with , and it is on by default for Visual
Studio.

.. code:: c++

   /*
      Copyright (C) 2015 Alin Mindroc
      (mindroc dot alin at gmail dot com)

      This is a sample program that shows how to use InstructionAPI in order to
      6  print the assembly code and functions in a provided binary.


      This program is free software; you can redistribute it and/or
      modify it under the terms of the GNU Lesser General Public
      11  License as published by the Free Software Foundation; either
      version 2.1 of the License, or (at your option) any later version.
      */
   #include <iostream>
   #include "CodeObject.h"
   #include "InstructionDecoder.h"
   using namespace std;
   using namespace Dyninst;
   using namespace ParseAPI;

   using namespace InstructionAPI;
   int main(int argc, char **argv){
       if(argc != 2){
   	printf("Usage: %s <binary path>\n", argv[0]);
   	return -1;
       }
       char *binaryPath = argv[1];

       SymtabCodeSource *sts;
       CodeObject *co;
       Instruction::Ptr instr;
       SymtabAPI::Symtab *symTab;
       std::string binaryPathStr(binaryPath);
       bool isParsable = SymtabAPI::Symtab::openFile(symTab, binaryPathStr);
       if(isParsable == false){
   	const char *error = "error: file can not be parsed";
   	cout << error;
   	return - 1;
       }
       sts = new SymtabCodeSource(binaryPath);
       co = new CodeObject(sts);
       //parse the binary given as a command line arg
       co->parse();

       //get list of all functions in the binary
       const CodeObject::funclist &all = co->funcs();
       if(all.size() == 0){
   	const char *error = "error: no functions in file";
   	cout << error;
   	return - 1;
       }
       auto fit = all.begin();
       Function *f = *fit;
       //create an Instruction decoder which will convert the binary opcodes to strings
       InstructionDecoder decoder(f->isrc()->getPtrToInstruction(f->addr()),
   	    InstructionDecoder::maxInstructionLength,
   	    f->region()->getArch());
       for(;fit != all.end(); ++fit){
   	Function *f = *fit;
   	//get address of entry point for current function

   	Address crtAddr = f->addr();
   	int instr_count = 0;
   	instr = decoder.decode((unsigned char *)f->isrc()->getPtrToInstruction(crtAddr));
   	auto fbl = f->blocks().end();
   	fbl--;
   	Block *b = *fbl;
   	Address lastAddr = b->last();
   	//if current function has zero instructions, donâ€™t output it
   	if(crtAddr == lastAddr)
   	    continue;
   	cout << "\n\n\"" << f->name() << "\" :";
   	while(crtAddr < lastAddr){
   	    //decode current instruction
   	    instr = decoder.decode((unsigned char *)f->isrc()->getPtrToInstruction(crtAddr));
   	    cout << "\n" << hex << crtAddr;
   	    cout << ": \"" << instr->format() << "\"";
   	    //go to the address of the next instruction
   	    crtAddr += instr->size();
   	    instr_count++;
   	}
       }
       return 0;
   }

Control flow graph traversal
----------------------------

The following complete example uses the ParseAPI to parse a binary and
dump its control flow graph in the Graphviz file format. As an example,
it can be built with G++ as follows: . Note: this example must be
compiled with C++11x support; for G++ this is enabled with , and it is
on by default for Visual Studio.

.. code:: c++

   // Example ParseAPI program; produces a graph (in DOT format) of the
   // control flow graph of the provided binary. 
   //
   // Improvements by E. Robbins (er209 at kent dot ac dot uk)
   //

   #include <stdio.h>
   #include <map>
   #include <vector>
   #include <unordered_map>
   #include <sstream>
   #include "CodeObject.h"
   #include "CFG.h"

   using namespace std;
   using namespace Dyninst;
   using namespace ParseAPI;

   int main(int argc, char * argv[])
   {
      map<Address, bool> seen;
      vector<Function *> funcs;
      SymtabCodeSource *sts;
      CodeObject *co;
      
      // Create a new binary code object from the filename argument
      sts = new SymtabCodeSource( argv[1] );
      co = new CodeObject( sts );
      
      // Parse the binary
      co->parse();
      cout << "digraph G {" << endl;
      
      // Print the control flow graph
      const CodeObject::funclist& all = co->funcs();
      auto fit = all.begin();
      for(int i = 0; fit != all.end(); ++fit, i++) { // i is index for clusters
         Function *f = *fit;
         
         // Make a cluster for nodes of this function
         cout << "\t subgraph cluster_" << i 
              << " { \n\t\t label=\""
              << f->name()
              << "\"; \n\t\t color=blue;" << endl;
         
         cout << "\t\t\"" << hex << f->addr() << dec
              << "\" [shape=box";
         if (f->retstatus() == NORETURN)
            cout << ",color=red";
         cout << "]" << endl;
         
         // Label functions by name
         cout << "\t\t\"" << hex << f->addr() << dec
              << "\" [label = \""
              << f->name() << "\\n" << hex << f->addr() << dec
              << "\"];" << endl;

         stringstream edgeoutput;
         
         auto bit = f->blocks().begin();
         for( ; bit != f->blocks().end(); ++bit) {
            Block *b = *bit;
            // Don't revisit blocks in shared code
            if(seen.find(b->start()) != seen.end())
               continue;
            
            seen[b->start()] = true;
            
            cout << "\t\t\"" << hex << b->start() << dec << 
               "\";" << endl;
            
            auto it = b->targets().begin();
            for( ; it != b->targets().end(); ++it) {
               if(!*it) continue;
               std::string s = "";
               if((*it)->type() == CALL)
                  s = " [color=blue]";
               else if((*it)->type() == RET)
                  s = " [color=green]";

               // Store the edges somewhere to be printed outside of the cluster
               edgeoutput << "\t\"" 
                          << hex << (*it)->src()->start()
                          << "\" -> \""
                          << (*it)->trg()->start()
                          << "\"" << s << endl;
            }
         }
         // End cluster
         cout << "\t}" << endl;

         // Print edges
         cout << edgeoutput.str() << endl;
      }
      cout << "}" << endl;
   }

Loop analysis
-------------

The following code example shows how to get loop information using
ParseAPI once we have an parsed Function object.

::

   void GetLoopInFunc(Function *f) {
       // Get all loops in the function
       vector<Loop*> loops;
       f->getLoops(loops);

       // Iterate over all loops
       for (auto lit = loops.begin(); lit != loops.end(); ++lit) {
           Loop *loop = *lit;

           // Get all the entry blocks of the loop
       vector<Block*> entries;
       loop->getLoopEntries(entries);

           // Get all the blocks in the loop
           vector<Block*> blocks;
       loop->getLoopBasicBlocks(blocks);

       // Get all the back edges in the loop
       vector<Edge*> backEdges;
       loop->getBackEdges(backEdges);
       }
   }
