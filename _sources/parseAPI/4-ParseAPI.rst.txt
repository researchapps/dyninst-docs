.. _`sec:api`:

The Parsing API
===============

Class CodeObject
----------------

The CodeObject class describes an individual binary code object, such as
an executable or library. It is the top-level container for parsing the
object as well as accessing that parse data. The following API routines
and data types are provided to support parsing and retrieving parsing
products.

.. container:: apient

   typedef std::set<Function \*, Function::less> funclist

.. container:: apient

   CodeObject(CodeSource \* cs, CFGFactory \* fact = NULL, ParseCallback
   \* cb = NULL, bool defensiveMode = false)

.. container:: apient

   void parse()

.. container:: apient

   void parse(Address target, bool recursive)

.. container:: apient

   void parse(CodeRegion \* cr, Address target, bool recursive)

.. container:: apient

   struct NewEdgeToParse Block \*source; Address target; EdgeTypeEnum
   type; bool parseNewEdges( vector<NewEdgeToParse> & worklist )

ParseAPI is able to speculatively parse gaps (regions of binary that has
not been identified as code or data yet) to identify function entry
points and perform control flow traversal.

.. container:: center

   +------------------+--------------------------------------------------+
   | GapParsingType   | Technique description                            |
   +==================+==================================================+
   | PreambleMatching | If instruction patterns are matched at an        |
   |                  | adderss, the address is a function entry point   |
   +------------------+--------------------------------------------------+
   | IdiomMatching    | Based on a pre-trained model, this technique     |
   |                  | calculates the probability of an address to be a |
   |                  | function entry point and predicts whether which  |
   |                  | addresses are function entry points              |
   +------------------+--------------------------------------------------+

.. container:: apient

   void parseGaps(CodeRegion \*cr, GapParsingType type=IdiomMatching)

.. container:: apient

   Function \* findFuncByEntry(CodeRegion \* cr, Address entry)

.. container:: apient

   int findFuncs(CodeRegion \* cr, Address addr, std::set<Function*> &
   funcs)

.. container:: apient

   int findFuncs(CodeRegion \* cr, Address start, Address end,
   std::set<Function*> & funcs)

.. container:: apient

   const funclist & funcs()

.. container:: apient

   Block \* findBlockByEntry(CodeRegion \* cr, Address entry)

.. container:: apient

   int findBlocks(CodeRegion \* cr, Address addr, std::set<Block*> &
   blocks)

.. container:: apient

   Block \* findNextBlock(CodeRegion \* cr, Address addr)

.. container:: apient

   CodeSource \* cs()

.. container:: apient

   CFGFactory \* fact()

.. container:: apient

   bool defensiveMode()

.. container:: apient

   bool isIATcall(Address insn, std::string &calleeName)

.. container:: apient

   void startCallbackBatch()

.. container:: apient

   void finishCallbackBatch()

.. container:: apient

   void registerCallback(ParseCallback \*cb);

.. container:: apient

   void unregisterCallback(ParseCallback \*cb);

.. container:: apient

   void finalize()

.. container:: apient

   void destroy(Edge \*)

.. container:: apient

   void destroy(Block \*)

.. container:: apient

   void destroy(Function \*)

Class CodeRegion
----------------

The CodeRegion interface is an accounting structure used to divide
CodeSources into distinct regions. This interface is mostly of interest
to CodeSource implementors.

.. container:: apient

   void names(Address addr, vector<std::string> & names)

.. container:: apient

   virtual bool findCatchBlock(Address addr, Address & catchStart)

.. container:: apient

   Address low()

.. container:: apient

   Address high()

.. container:: apient

   bool contains(Address addr)

.. container:: apient

   virtual bool wasUserAdded() const

Class Function
--------------

The Function class represents the portion of the program CFG that is
reachable through intraprocedural control flow transfers from the
function’s entry block. Functions in the ParseAPI have only a single
entry point; multiple-entry functions such as those found in Fortran
programs are represented as several functions that “share” a subset of
the CFG. Functions may be non-contiguous and may share blocks with other
functions.

.. container:: center

   ============ ==========================================
   FuncSource   Meaning
   ============ ==========================================
   RT           recursive traversal (default)
   HINT         specified in CodeSource hints
   GAP          speculative parsing heuristics
   GAPRT        recursive traversal from speculative parse
   ONDEMAND     dynamically discovered at runtime
   MODIFICATION Added via user modification
   ============ ==========================================

.. container:: center

   ================ ===============================
   FuncReturnStatus Meaning
   ================ ===============================
   UNSET            unparsed function (default)
   NORETURN         will not return
   UNKNOWN          cannot be determined statically
   RETURN           may return
   ================ ===============================

.. container:: apient

   typedef boost::transform_iterator<selector, blockmap::iterator>
   bmap_iterator typedef boost::transform_iterator<selector,
   blockmap::const_iterator> bmap_const_iterator typedef
   boost::iterator_range<bmap_iterator> blocklist typedef
   boost::iterator_range<bmap_const_iterator> const_blocklist typedef
   std::set<Edge*> edgelist

+-------------------+----------------------+-----------------------+
| Method name       | Return type          | Method description    |
+===================+======================+=======================+
| name              | string               | Name of the function. |
+-------------------+----------------------+-----------------------+
| addr              | Address              | Entry address of the  |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+
| entry             | Block \*             | Entry block of the    |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+
| parsed            | bool                 | Whether the function  |
|                   |                      | has been parsed.      |
+-------------------+----------------------+-----------------------+
| blocks            | blocklist &          | List of blocks        |
|                   |                      | contained by this     |
|                   |                      | function sorted by    |
|                   |                      | entry address.        |
+-------------------+----------------------+-----------------------+
| callEdges         | const edgelist &     | List of outgoing call |
|                   |                      | edges from this       |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+
| returnBlocks      | const_blocklist &    | List of all blocks    |
|                   |                      | ending in return      |
|                   |                      | edges.                |
+-------------------+----------------------+-----------------------+
| exitBlocks        | const_blocklist &    | List of all blocks    |
|                   |                      | that end the          |
|                   |                      | function, including   |
|                   |                      | blocks with no        |
|                   |                      | out-edges.            |
+-------------------+----------------------+-----------------------+
| hasNoStackFrame   | bool                 | True if the function  |
|                   |                      | does not create a     |
|                   |                      | stack frame.          |
+-------------------+----------------------+-----------------------+
| savesFramePointer | bool                 | True if the function  |
|                   |                      | saves a frame pointer |
|                   |                      | (e.g. %ebp).          |
+-------------------+----------------------+-----------------------+
| cleansOwnStack    | bool                 | True if the function  |
|                   |                      | tears down            |
|                   |                      | stack-passed          |
|                   |                      | arguments upon        |
|                   |                      | return.               |
+-------------------+----------------------+-----------------------+
| region            | CodeRegion \*        | Code region that      |
|                   |                      | contains the          |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+
| isrc              | InstructionSource \* | The InstructionSource |
|                   |                      | for this function.    |
+-------------------+----------------------+-----------------------+
| obj               | CodeObject \*        | CodeObject that       |
|                   |                      | contains this         |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+
| src               | FuncSrc              | The type of hint that |
|                   |                      | identified this       |
|                   |                      | function’s entry      |
|                   |                      | point.                |
+-------------------+----------------------+-----------------------+
| restatus          | FuncReturnStatus \*  | Returns the           |
|                   |                      | best-effort           |
|                   |                      | determination of      |
|                   |                      | whether this function |
|                   |                      | may return or not.    |
|                   |                      | Return status cannot  |
|                   |                      | always be statically  |
|                   |                      | determined, and at    |
|                   |                      | most can guarantee    |
|                   |                      | that a function *may* |
|                   |                      | return, not that it   |
|                   |                      | *will* return.        |
+-------------------+----------------------+-----------------------+
| getReturnType     | Type \*              | Type representing the |
|                   |                      | return type of the    |
|                   |                      | function.             |
+-------------------+----------------------+-----------------------+

.. container:: apient

   Function(Address addr, string name, CodeObject \* obj, CodeRegion \*
   region, InstructionSource \* isource)

.. container:: apient

   LoopTreeNode\* getLoopTree()

.. container:: apient

   Loop\* findLoop(const char \*name)

.. container:: apient

   bool getLoops(vector<Loop*> &loops);

.. container:: apient

   bool getOuterLoops(vector<Loop*> &loops);

.. container:: apient

   bool dominates(Block\* A, Block \*B);

.. container:: apient

   Block\* getImmediateDominator(Block \*A);

.. container:: apient

   void getImmediateDominates(Block \*A, set<Block*> &imm);

.. container:: apient

   void getAllDominates(Block \*A, set<Block*> &dom);

.. container:: apient

   bool postDominates(Block\* A, Block \*B);

.. container:: apient

   Block\* getImmediatePostDominator(Block \*A);

.. container:: apient

   void getImmediatePostDominates(Block \*A, set<Block*> &imm);

.. container:: apient

   void getAllPostDominates(Block \*A, set<Block*> &dom);

.. container:: apient

   std::vector<FuncExtent \*> const& extents()

.. container:: apient

   void setEntryBlock(block \* new_entry)

.. container:: apient

   void set_retstatus(FuncReturnStatus rs)

.. container:: apient

   bool contains(Block \*b)

.. container:: apient

   void removeBlock(Block \*)

Class Block
-----------

A Block represents a basic block as defined in Section
`[sec:abstractions] <#sec:abstractions>`__, and is the lowest level
representation of code in the CFG.

.. container:: apient

   typedef std::vector<Edge \*> edgelist

+-----------------+------------------+-------------------------------+
| Method name     | Return type      | Method description            |
+=================+==================+===============================+
| start           | Address          | Address of the first          |
|                 |                  | instruction in the block.     |
+-----------------+------------------+-------------------------------+
| end             | Address          | Address immediately following |
|                 |                  | the last instruction in the   |
|                 |                  | block.                        |
+-----------------+------------------+-------------------------------+
| last            | Address          | Address of the last           |
|                 |                  | instruction in the block.     |
+-----------------+------------------+-------------------------------+
| lastInsnAddr    | Address          | Alias of .                    |
+-----------------+------------------+-------------------------------+
| size            | Address          | Size of the block; - .        |
+-----------------+------------------+-------------------------------+
| parsed          | bool             | Whether the block has been    |
|                 |                  | parsed.                       |
+-----------------+------------------+-------------------------------+
| obj             | CodeObject \*    | CodeObject containing this    |
|                 |                  | block.                        |
+-----------------+------------------+-------------------------------+
| region          | CodeRegion \*    | CodeRegion containing this    |
|                 |                  | block.                        |
+-----------------+------------------+-------------------------------+
| sources         | const edgelist & | List of all in-edges to the   |
|                 |                  | block.                        |
+-----------------+------------------+-------------------------------+
| targets         | const edgelist & | List of all out-edges from    |
|                 |                  | the block.                    |
+-----------------+------------------+-------------------------------+
| containingFuncs | int              | Number of Functions that      |
|                 |                  | contain this block.           |
+-----------------+------------------+-------------------------------+

.. container:: apient

   Block(CodeObject \* o, CodeRegion \* r, Address start, Function\* f =
   NULL)

.. container:: apient

   Block(CodeObject \* o, CodeRegion \* r, Address start, Address end,
   Address last, Function\* f = NULL)

.. container:: apient

   bool consistent(Address addr, Address & prev_insn)

.. container:: apient

   void getFuncs(std::vector<Function \*> & funcs)

.. container:: apient

   template <class OutputIterator> void getFuncs(OutputIterator result)

::

          std::set<Function *> funcs;
          block->getFuncs(std::inserter(funcs, funcs.begin()));

.. container:: apient

   typedef std::map<Offset, InstructionAPI::Instruction::Ptr> Insns void
   getInsns(Insns &insns) const

.. container:: apient

   InstructionAPI::Instruction::Ptr getInsn(Offset o) const

Class Edge
----------

Typed Edges join two blocks in the CFG, indicating the type of control
flow transfer instruction that joins the blocks to each other. Edges may
not correspond to a control flow transfer instruction at all, as in the
case of the fallthrough edge that indicates where straight-line control
flow is split by incoming transfers from another location, such as a
branch. While not all blocks end in a control transfer instruction, all
control transfer instructions end basic blocks and have outgoing edges;
in the case of unresolvable control flow, the edge will target a special
“sink” block (see , below).

.. container:: center

   ============== ==============================
   EdgeTypeEnum   Meaning
   ============== ==============================
   CALL           call edge
   COND_TAKEN     conditional branch–taken
   COND_NOT_TAKEN conditional branch–not taken
   INDIRECT       branch indirect
   DIRECT         branch direct
   FALLTHROUGH    direct fallthrough (no branch)
   CATCH          exception handler
   CALL_FT        post-call fallthrough
   RET            return
   ============== ==============================

+-------------+--------------+---------------------------------------+
| Method name | Return type  | Method description                    |
+=============+==============+=======================================+
| src         | Block \*     | Source of the edge.                   |
+-------------+--------------+---------------------------------------+
| trg         | Block \*     | Target of the edge.                   |
+-------------+--------------+---------------------------------------+
| type        | EdgeTypeEnum | Type of the edge.                     |
+-------------+--------------+---------------------------------------+
| sinkEdge    | bool         | True if the target is the sink block. |
+-------------+--------------+---------------------------------------+
| interproc   | bool         | True if the edge should be            |
|             |              | interpreted as interprocedural (e.g.  |
|             |              | calls, returns, unconditional or      |
|             |              | conditional tail calls).              |
+-------------+--------------+---------------------------------------+

Class Loop
----------

The Loop class represents code that may execute repeatedly. We detect
both natural loops (loops that have a single entry block) and
irreducible loops (loops that have multiple entry blocks). A back edge
is defined as an edge that has its source in the loop and has its target
being an entry block of the loop. It represents the end of an iteration
of the loop. For all the loops detected in a function, we also build a
loop nesting tree to represent the nesting relations between the loops.
See class for more details.

.. container:: apient

   Loop\* parent

.. container:: apient

   bool containsAddress(Address addr)

.. container:: apient

   bool containsAddressInclusive(Address addr)

.. container:: apient

   int getLoopEntries(vector<Block*>& entries);

.. container:: apient

   int getBackEdges(vector<Edge*> &edges)

.. container:: apient

   bool getContainedLoops(vector<Loop*> &loops)

.. container:: apient

   bool getOuterLoops(vector<Loop*> &loops)

.. container:: apient

   bool getLoopBasicBlocks(vector<Block*> &blocks)

.. container:: apient

   bool getLoopBasicBlocksExclusive(vector<Block*> &blocks)

.. container:: apient

   bool hasBlock(Block \*b);

.. container:: apient

   bool hasBlockExclusive(Block \*b);

.. container:: apient

   bool hasAncestor(Loop \*loop)

.. container:: apient

   Function \* getFunction();

Class LoopTreeNode
------------------

The LoopTreeNode class provides a tree interface to a collection of
instances of class Loop contained in a function. The structure of the
tree follows the nesting relationship of the loops in a function. Each
LoopTreeNode contains a pointer to a loop (represented by Loop), and a
set of sub-loops (represented by other LoopTreeNode objects). The field
at the root node is always since a function may contain multiple outer
loops. The field is never at any other node since it always corresponds
to a real loop. Therefore, the outer most loops in the function are
contained in the vector of of the root.

Each instance of LoopTreeNode is given a name that indicates its
position in the hierarchy of loops. The name of each outermost loop
takes the form of , where is an integer from 1 to n, where n is the
number of outer loops in the function. Each sub-loop has the name of its
parent, followed by a , where is 1 to m, where m is the number of
sub-loops under the outer loop. For example, consider the following C
function:

::


   void foo() {
     int x, y, z, i;
     for (x=0; x<10; x++) {
       for (y = 0; y<10; y++)
         ...
       for (z = 0; z<10; z++)
         ...
     }
     for (i = 0; i<10; i++) {
        ...
     }
   }

The function will have a root LoopTreeNode, containing a NULL loop entry
and two LoopTreeNode children representing the functions outermost
loops. These children would have names and , respectively representing
the and loops. has no children. has two child LoopTreeNode objects,
named and , respectively representing the and loops.

.. container:: apient

   Loop \*loop;

.. container:: apient

   std::vector<LoopTreeNode \*> children;

.. container:: apient

   const char \* name();

.. container:: apient

   const char \* getCalleeName(unsigned int i)

.. container:: apient

   unsigned int numCallees()

.. container:: apient

   bool getCallees(vector<Function \*> &v);

.. container:: apient

   Loop \* findLoop(const char \*name);

.. _`sec:codesource`:

Class CodeSource
----------------

The CodeSource interface is used by the ParseAPI to retrieve binary code
from an executable, library, or other binary code object; it also can
provide hints of function entry points (such as those derived from
debugging symbols) to seed the parser. The ParseAPI provides a default
implementation based on the SymtabAPI that supports many common binary
formats. For details on implementing a custom CodeSource, see Appendix
`[sec:extend] <#sec:extend>`__.

.. container:: apient

   virtual bool nonReturning(Address func_entry) virtual bool
   nonReturning(std::string func_name)

.. container:: apient

   virtual bool nonReturningSyscall(int /*number*/)

.. container:: apient

   virtual Address baseAddress() virtual Address loadAddress()

.. container:: apient

   std::map< Address, std::string > & linkage()

.. container:: apient

   struct Hint Address \_addr; CodeRegion \*_region; std::string \_name;
   Hint(Addr, CodeRegion \*, std::string); std::vector< Hint > const&
   hints()

.. container:: apient

   std::vector<CodeRegion \*> const& regions()

.. container:: apient

   int findRegions(Address addr, set<CodeRegion \*> & ret)

.. container:: apient

   bool regionsOverlap()

Class ParseCallback
-------------------

The ParseCallback class allows ParseAPI users to be notified of various
events during parsing. For most users this notification is unnecessary,
and an instantiation of the default ParseCallback can be passed to the
CodeObject during initialization. Users who wish to be notified must
implement a class that inherits from ParseCallback, and implement one or
more of the methods described below to receive notification of those
events.

.. container:: apient

   struct default_details default_details(unsigned char \* b,size_t s,
   bool ib); unsigned char \* ibuf; size_t isize; bool isbranch;

.. container:: apient

   virtual void instruction_cb(Function \*, Block \*, Address,
   insn_details \*)

.. container:: apient

   struct insn_details InsnAdapter::InstructionAdapter \* insn;

.. container:: apient

   void interproc_cf(Function \*, Address, interproc_details \*)

.. container:: apient

   struct interproc_details typedef enum ret, call, branch_interproc, //
   tail calls, branches to plts syscall type_t; unsigned char \* ibuf;
   size_t isize; type_t type; union struct Address target; bool
   absolute_address; bool dynamic_call; call; data;

.. container:: apient

   void overlapping_blocks(Block \*, Block \*)

Class FuncExtent
----------------

Function Extents are used internally for accounting and lookup purposes.
They may be useful for users who wish to precisely identify the ranges
of the address space spanned by functions (functions are often
discontiguous, particularly on architectures with variable length
instruction sets).

=========== =========== ===============================
Method name Return type Method description
=========== =========== ===============================
func        Function \* Function linked to this extent.
start       Address     Start of the extent.
end         Address     End of the extent (exclusive).
=========== =========== ===============================

.. _`sec:pred`:

Edge Predicates
---------------

Edge predicates control iteration over edges. For example, the provided
edge predicate can be used with filter iterators and standard
algorithms, ensuring that only intraprocedural edges are visited during
iteration. Two other examples of edge predicates are provided: only
visits edges that stay in a single function context, and does not visit
edges to the *sink* block. The following code traverses all of the basic
blocks within a function:

::

       #include <boost/filter_iterator.hpp>
       using boost::make_filter_iterator;
       struct target_block
       {
         Block* operator()(Edge* e) { return e->trg(); }
       };


       vector<Block*> work;
       Intraproc epred; // ignore calls, returns
      
       work.push_back(func->entry()); // assuming `func' is a Function*

       // do_stuff is a functor taking a Block* as its argument
       while(!work.empty()) {
           Block * b = work.back();
           work.pop_back();

           Block::edgelist & targets = block->targets();
           // Do stuff for each out edge
           std::for_each(make_filter_iterator(targets.begin(), epred), 
                         make_filter_iterator(targets.end(), epred),
                         do_stuff());
           std::transform(make_filter_iterator(targets.begin(), epred),
                          make_filter_iterator(targets.end(), epred), 
                          std::back_inserter(work), 
                          std::mem_fun(Edge::trg));
           Block::edgelist::const_iterator found_interproc =
                   std::find_if(targets.begin(), targets.end(), Interproc());
           if(interproc != targets.end()) {
                   // do something with the interprocedural edge you found
           }
       }

Anything that can be treated as a function from to a can be used in this
manner. This replaces the beta interface where all s needed to descend
from a common parent class. Code that previously constructed iterators
from an edge predicate should be replaced with equivalent code using
filter iterators as follows:

::

     // OLD
     for(Block::edgelist::iterator i = targets.begin(epred); 
         i != targets.end(epred); 
         i++)
     {
       // ...
     }
     // NEW
     for_each(make_filter_iterator(epred, targets.begin(), targets.end()),
              make_filter_iterator(epred, targets.end(), targets,end()),
              loop_body_as_function);
     // NEW (C++11)
     for(auto i = make_filter_iterator(epred, targets.begin(), targets.end()); 
         i != make_filter_iterator(epred, targets.end(), targets.end()); 
         i++)
     {
       // ...
     }
     

.. _`sec:containers`:

Containers
----------

Several of the ParseAPI data structures export containers of CFG
objects; the CodeObject provides a list of functions in the binary, for
example, while functions provide lists of blocks and so on. To avoid
tying the internal storage for these structures to any particular
container type, ParseAPI objects export a ContainerWrapper that provides
an iterator interface to the internal containers. These wrappers and
predicate interfaces are designed to add minimal overhead while
protecting ParseAPI users from exposure to internal container storage
details. Users *must not* rely on properties of the underlying container
type (e.g. storage order) unless that property is explicity stated in
this manual.

ContainerWrapper containers export the following interface ( types vary
depending on the template parameters of the ContainerWrapper, but are
always instantiations of the PredicateIterator described below):

.. container:: apient

   iterator begin() iterator begin(predicate \*)

.. container:: apient

   iterator const& end()

.. container:: apient

   size_t size()

.. container:: apient

   bool empty()

The elements in ParseAPI containers can be accessed by iteration using
an instantiation of the PredicateIterator. These iterators can
optionally act as filters, evaluating a boolean predicate for each
element and only returning those elements for which the predicate
returns true. *Iterators with non-null predicates may return fewer
elements during iteration than their method indicates.* Currently
PredicateIterators only support forward iteration. The operators (prefix
and postfix), , , and (dereference) are supported.
