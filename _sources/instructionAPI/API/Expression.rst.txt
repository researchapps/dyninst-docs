.. _`sec:expression`:

Expression Class
----------------

An is an AST representation of how the value of an operand is computed.

The class extends the class by adding the concept of evaluation to the
nodes of an . Evaluation attempts to determine the of the computation
that the AST being evaluated represents. It will fill in results of as
many of the nodes in the tree as possible, and if full evaluation is
possible, it will return the result of the computation performed by the
tree.

Permissible leaf nodes of an tree are RegisterAST and Immediate objects.
Permissible internal nodes are and Dereference objects. An may represent
an immediate value, the contents of a register, or the contents of
memory at a given address, interpreted as a particular type.

The s in an tree contain a type and a value. Their values may be an
undefined value or an instance of their associated type. When two s are
combined using a , the specifies the output type. Sign extension, type
promotion, truncation, and all other necessary conversions are handled
automatically based on the input types and the output type. If both of
the s that are combined have defined values, the combination will also
have a defined value; otherwise, the combination’s value will be
undefined. For more information, see
Section `[sec:result] <#sec:result>`__,
Section `[sec:binaryFunction] <#sec:binaryFunction>`__, and
Section `[sec:dereference] <#sec:dereference>`__.

A user may specify the result of evaluating a given . This mechanism is
designed to allow the user to provide a Dereference or RegisterAST with
information about the state of memory or registers. It may additionally
be used to change the value of an Immediate or to specify the result of
a . This mechanism may be used to support other advanced analyses.

In order to make it more convenient to specify the results of particular
subexpressions, the method is provided. allows the user to specify that
a given subexpression has a particular value everywhere that it appears
in an expression. For example, if the state of certain registers is
known at the time an instruction is executed, a user can those registers
to their known values throughout an .

The evaluation mechanism, as mentioned above, will evaluate as many
sub-expressions of an expression as possible. Any operand that is more
complicated than a single immediate value, however, will depend on
register or memory values. The s of evaluating each subexpression are
cached automatically using the mechanism. The then attempts to determine
its based on the s of its children. If this can be determined (most
likely because register contents have been filled in via or ), it will
be returned from ; if it can not be determined, a with an undefined
value will be returned. See Figure 6 for an illustration of this
concept; the operand represented is . The contents of and have been
determined through some outside mechanism, and have been defined with .
The mechanism proceeds to determine the address being read by the ,
since this information can be determined given the contents of the
registers. This address is available from the Dereference through its
child in the tree, even though calling on the Dereference returns a with
an undefined value.

.. figure:: fig/deref-eval
   :alt: Applying to a Dereference tree with two registers having
   user-provided values.
   :name: fig:deref-eval

   Applying to a Dereference tree with two registers having
   user-provided values.

.. container:: apient

   typedef boost::shared_ptr<Expression> Ptr

.. container:: apient

   const Result & eval() const

.. container:: apient

   const setValue(const Result & knownValue)

.. container:: apient

   void clearValue()

.. container:: apient

   int size() const

.. container:: apient

   bool bind(Expression \* expr, const Result & value)

.. container:: apient

   virtual void apply(Visitor \*)

.. container:: apient

   virtual void getChildren(std::vector<Expression::Ptr> & children)
   const
