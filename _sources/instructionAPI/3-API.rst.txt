InstructionAPI Class Reference
==============================

.. _`sec:instruction`:

Instruction Class
-----------------

The Instruction class is a generic instruction representation that
contains operands, read/write semantic information about those operands,
and information about what other registers and memory locations are
affected by the operation the instruction performs.

The purpose of an Instruction object is to join an Operation with a
sequence of Operands, and provide an interface for some common summary
analyses (namely, the read/write sets, memory access information, and
control flow information).

The Operation contains knowledge about its mnemonic and sufficient
semantic details to answer the following questions:

-  What Operands are read/written?

-  What registers are implicitly read/written?

-  What memory locations are implicitly read/written?

-  What are the possible control flow successors of this instruction?

Each Operand is an AST built from RegisterAST and Immediate leaves. For
each Operand, you may determine:

-  Registers read

-  Registers written

-  Whether memory is read or written

-  Which memory addresses are read or written, given the state of all
   relevant registers

Instructions should be constructed from an pointing to machine language,
using the InstructionDecoder class. See InstructionDecoder for more
details.

.. container:: apient

   Instruction (Operation::Ptr what, size_t size, const unsigned char \*
   raw, Dyninst::Architecture arch)

.. container:: apient

   const Operation & getOperation() const

.. container:: apient

   void getOperands(std::vector<Operand> & operands) const

.. container:: apient

   Operand getOperand(int index) const

.. container:: apient

   unsigned char rawByte(unsigned int index) const

.. container:: apient

   size_t size() const

.. container:: apient

   const void \* ptr() const

.. container:: apient

   void getWriteSet(std::set<RegisterAST::Ptr> & regsWritten) const

.. container:: apient

   void getReadSet(std::set<RegisterAST::Ptr> & regsRead) const

.. container:: apient

   bool isRead(Expression::Ptr candidate) const

.. container:: apient

   bool isWritten(Expression::Ptr candidate) const

.. container:: apient

   bool readsMemory() const

.. container:: apient

   bool writesMemory() const

.. container:: apient

   void getMemoryReadOperands(std::set<Expression::Ptr> & memAccessors)
   const

.. container:: apient

   void getMemoryWriteOperands(std::set<Expression::Ptr> & memAccessors)
   const

.. container:: apient

   Expression::Ptr getControlFlowTarget() const

.. container:: apient

   bool allowsFallThrough() const

.. container:: apient

   std::string format(Address addr = 0)

.. container:: apient

   bool isValid() const

.. container:: apient

   bool isLegalInsn() const

.. container:: apient

   Architecture getArch() const

.. container:: apient

   InsnCategory getCategory() const

.. container:: apient

   struct CFT Expression::Ptr target; bool isCall; bool isIndirect; bool
   isConditional; bool isFallthrough;

   typedef ... cftConstIter; cftConstIter cft_begin() const;
   cftConstIter cft_end() const;

.. _`sec:operation`:

Operation Class
---------------

An Operation object represents a family of opcodes (operation encodings)
that perform the same task (e.g. the family). It includes information
about the number of operands, their read/write semantics, the implicit
register reads and writes, and the control flow behavior of a particular
assembly language operation. It additionally provides access to the
assembly mnemonic, which allows any semantic details that are not
encoded in the Instruction representation to be added by higher layers
of analysis.

As an example, the operation on IA32/AMD64 processors has the following
properties:

-  Operand 1 is read, but not written

-  Operand 2 is read, but not written

-  The following flags are written:

   -  Overflow

   -  Sign

   -  Zero

   -  Parity

   -  Carry

   -  Auxiliary

-  No other registers are read, and no implicit memory operations are
   performed

Operations are constructed by the as part of the process of constructing
an Instruction.

.. container:: apient

   const Operation::registerSet & implicitReads () const

.. container:: apient

   const Operation::registerSet & implicitWrites () const

.. container:: apient

   std::string format() const

.. container:: apient

   entryID getID() const

.. container:: apient

   prefixEntryID getPrefixID() const

.. container:: apient

   bool isRead(Expression::Ptr candidate) const

.. container:: apient

   bool isWritten(Expression::Ptr candidate) const

.. container:: apient

   const Operation::VCSet & getImplicitMemReads() const

.. container:: apient

   const Operation::VCSet & getImplicitMemWrites() const

.. _`sec:operand`:

Operand Class
-------------

An Operand object contains an AST built from RegisterAST and Immediate
leaves, and information about whether the Operand is read, written, or
both. This allows us to determine which of the registers that appear in
the Operand are read and which are written, as well as whether any
memory accesses are reads, writes, or both. An Operand, given full
knowledge of the values of the leaves of the AST, and knowledge of the
logic associated with the tree’s internal nodes, can determine the
result of any computations that are encoded in it. It will rarely be the
case that an Instruction is built with its Operands’ state fully
specified. This mechanism is instead intended to allow a user to fill in
knowledge about the state of the processor at the time the Instruction
is executed.

.. container:: apient

   Operand(Expression::Ptr val, bool read, bool written)

.. container:: apient

   void getReadSet(std::set<RegisterAST::Ptr> & regsRead) const

.. container:: apient

   void getWriteSet(std::set<RegisterAST::Ptr> & regsWritten) const

.. container:: apient

   bool isRead() const

.. container:: apient

   bool isWritten() const

.. container:: apient

   bool isRead(Expression::Ptr candidate) const

.. container:: apient

   bool isWritten(Expression::Ptr candidate) const

.. container:: apient

   bool readsMemory() const

.. container:: apient

   bool writesMemory() const

.. container:: apient

   void addEffectiveReadAddresses(std::set<Expression::Ptr> &
   memAccessors) const

.. container:: apient

   void addEffectiveWriteAddresses(std::set<Expression::Ptr> &
   memAccessors) const

.. container:: apient

   std::string format(Architecture arch, Address addr = 0) const

.. container:: apient

   Expression::Ptr getValue() const

.. _`sec:instructionAST`:

InstructionAST Class
--------------------

The InstructionAST class is the base class for all nodes in the ASTs
used by the Operand class. It defines the necessary interfaces for
traversing and searching an abstract syntax tree representing an
operand. For the purposes of searching an InstructionAST, we provide two
related interfaces. The first, , will return the registers that appear
in a given tree. The second, , will take as input another tree and
return true if that tree is a (not necessarily proper) subtree of this
one. requires us to define an equality relation on these abstract syntax
trees, and the equality operator is provided by the InstructionAST, with
the details implemented by the classes derived from InstructionAST. Two
AST nodes are equal if the following conditions hold:

-  They are of the same type

-  If leaf nodes, they represent the same immediate value or the same
   register

-  If non-leaf nodes, they represent the same operation and their
   corresponding children are equal

.. container:: apient

   typedef boost::shared_ptr<InstructionAST> Ptr

.. container:: apient

   bool operator==(const InstructionAST &rhs) const

.. container:: apient

   virtual void getChildren(vector<InstructionAPI::Ptr> & children)
   const

.. container:: apient

   virtual void getUses(set<InstructionAPI::Ptr> & uses)

.. container:: apient

   virtual bool isUsed(InstructionAPI::Ptr findMe) const

.. container:: apient

   virtual std::string format(formatStyle how == defaultStyle) const

.. _`sec:expression`:

Expression Class
----------------

An is an AST representation of how the value of an operand is computed.

The class extends the class by adding the concept of evaluation to the
nodes of an . Evaluation attempts to determine the of the computation
that the AST being evaluated represents. It will fill in results of as
many of the nodes in the tree as possible, and if full evaluation is
possible, it will return the result of the computation performed by the
tree.

Permissible leaf nodes of an tree are RegisterAST and Immediate objects.
Permissible internal nodes are and Dereference objects. An may represent
an immediate value, the contents of a register, or the contents of
memory at a given address, interpreted as a particular type.

The s in an tree contain a type and a value. Their values may be an
undefined value or an instance of their associated type. When two s are
combined using a , the specifies the output type. Sign extension, type
promotion, truncation, and all other necessary conversions are handled
automatically based on the input types and the output type. If both of
the s that are combined have defined values, the combination will also
have a defined value; otherwise, the combination’s value will be
undefined. For more information, see Section `1.7 <#sec:result>`__,
Section `1.10 <#sec:binaryFunction>`__, and
Section `1.11 <#sec:dereference>`__.

A user may specify the result of evaluating a given . This mechanism is
designed to allow the user to provide a Dereference or RegisterAST with
information about the state of memory or registers. It may additionally
be used to change the value of an Immediate or to specify the result of
a . This mechanism may be used to support other advanced analyses.

In order to make it more convenient to specify the results of particular
subexpressions, the method is provided. allows the user to specify that
a given subexpression has a particular value everywhere that it appears
in an expression. For example, if the state of certain registers is
known at the time an instruction is executed, a user can those registers
to their known values throughout an .

The evaluation mechanism, as mentioned above, will evaluate as many
sub-expressions of an expression as possible. Any operand that is more
complicated than a single immediate value, however, will depend on
register or memory values. The s of evaluating each subexpression are
cached automatically using the mechanism. The then attempts to determine
its based on the s of its children. If this can be determined (most
likely because register contents have been filled in via or ), it will
be returned from ; if it can not be determined, a with an undefined
value will be returned. See Figure 6 for an illustration of this
concept; the operand represented is . The contents of and have been
determined through some outside mechanism, and have been defined with .
The mechanism proceeds to determine the address being read by the ,
since this information can be determined given the contents of the
registers. This address is available from the Dereference through its
child in the tree, even though calling on the Dereference returns a with
an undefined value.

.. figure:: fig/deref-eval.pdf
   :alt: Applying to a Dereference tree with two registers having
   user-provided values.
   :name: fig:deref-eval

   Applying to a Dereference tree with two registers having
   user-provided values.

.. container:: apient

   typedef boost::shared_ptr<Expression> Ptr

.. container:: apient

   const Result & eval() const

.. container:: apient

   const setValue(const Result & knownValue)

.. container:: apient

   void clearValue()

.. container:: apient

   int size() const

.. container:: apient

   bool bind(Expression \* expr, const Result & value)

.. container:: apient

   virtual void apply(Visitor \*)

.. container:: apient

   virtual void getChildren(std::vector<Expression::Ptr> & children)
   const

.. _`sec:visitor`:

Visitor Paradigm
----------------

An alternative to the bind/eval mechanism is to use a *visitor*  [1]_
over an expression tree. The visitor concept applies a user-specified
visitor class to all nodes in an expression tree (in a post-order
traversal). The visitor paradigm can be used as a more efficient
replacement for bind/eval, to identify whether an expression has a
desired pattern, or to locate children of an expression tree.

A visitor is a user-defined class that inherits from the class defined
in . That class is repeated here for reference:

.. container:: apient

   class Visitor public: Visitor() virtual  Visitor() virtual void
   visit(BinaryFunction\* b) = 0; virtual void visit(Immediate\* i) = 0;
   virtual void visit(RegisterAST\* r) = 0; virtual void
   visit(Dereference\* d) = 0;;

A user provides implementations of the four methods. When applied to an
(via the method) the InstructionAPI will perform a post-order traversal
of the tree, calling the appropriate method at each node.

As a simple example, the following code prints out the name of each
register used in an :

.. code:: c

   #include "Instruction.h"
   #include "Operand.h"
   #include "Expression.h"
   #include "Register.h"
   #include "Visitor.h"
   #include <iostream>

   using namespace std;
   using namespace Dyninst;
   using namespace InstructionAPI;

   class PrintVisitor : public Visitor {
     public:
       PrintVisitor() {};
       ~PrintVisitor() {};
       virtual void visit(BinaryFunction* b) {};
       virtual void visit(Immediate* i) {};
       virtual void visit(RegisterAST* r) {
         cout << "\tVisiting register " << r->getID().name() << endl;
       }
       virtual void visit(Dereference* d) {};
   };

   void printRegisters(Instruction::Ptr insn) {
      PrintVisitor pv;
      std::vector<Operand> operands;
      insn->getOperands(operands);
      // c++11x allows auto to determine the type of a variable;
      // if not using c++11x, use 'std::vector<Operand>::iterator' instead.
      // For gcc, use the -std=c++0x argument.
      for (auto iter = operands.begin(); iter != operands.end(); ++iter) {
         cout << "Registers used for operand" << endl;
         (*iter).getValue()->apply(&pv);
      }
   }

Visitors may also set and use internal state. For example, the following
visitor (presented without surrounding use code) matches x86 and x86-64
instructions that add 0 to a register (effectively a noop).

.. code:: c

   class nopVisitor : public Visitor
   {
     public:
      nopVisitor() : foundReg(false), foundImm(false), foundBin(false), isNop(true) {}
      virtual ~nopVisitor() {}
      
      bool foundReg;
      bool foundImm;
      bool foundBin;
      bool isNop;
      
      virtual void visit(BinaryFunction*)
      {
         if (foundBin) isNop = false;
         if (!foundImm) isNop = false;
         if (!foundReg) isNop = false;
         foundBin = true;
      }
      virtual void visit(Immediate *imm)
      {
         if (imm != 0) isNop = false;
         foundImm = true;
      }
      virtual void visit(RegisterAST *)
      {
         foundReg = true;
      }
      virtual void visit(Dereference *)
      {
         isNop = false;
      }
   };

.. _`sec:result`:

Result Class
------------

A object represents a value computed by an AST.

The class is a tagged-union representation of the results that
Expressions can produce. It includes 8, 16, 32, 48, and 64 bit integers
(signed and unsigned), bit values, and single and double precision
floating point values. For each of these types, the value of a Result
may be undefined, or it may be a value within the range of the type.

The field is an enum that may contain any of the following values:

-  an unsigned 8-bit integer

-  a signed 8-bit integer

-  an unsigned 16-bit integer

-  a signed 16-bit integer

-  an unsigned 32-bit integer

-  a signed 32-bit integer

-  an unsigned 48-bit integer (IA32 pointers)

-  a signed 48-bit integer (IA32 pointers)

-  an unsigned 64-bit integer

-  a signed 64-bit integer

-  a single-precision float

-  a double-precision float

-  a single bit (individual flags)

-  a 512-bit memory value

-  a 128-bit integer, which often contains packed floating point values
   - a 14 byte memory value

.. container:: apient

   Result (Result_Type t)

.. container:: apient

   Result (Result_Type t, T v)

.. container:: apient

   bool operator== (const Result & o) const

.. container:: apient

   std::string format () const

.. container:: apient

   template <typename to_type> to_type convert() const

.. container:: apient

   int size () const

.. _`sec:registerAST`:

RegisterAST Class
-----------------

A object represents a register contained in an operand. As a is an , it
may contain the physical register’s contents if they are known.

.. container:: apient

   typedef dyn_detail::boost::shared_ptr<RegisterAST> Ptr

.. container:: apient

   RegisterAST (MachRegister r)

.. container:: apient

   void getChildren (vector< InstructionAST::Ptr > & children) const

.. container:: apient

   void getUses (set< InstructionAST::Ptr > & uses)

.. container:: apient

   bool isUsed (InstructionAST::Ptr findMe) const

.. container:: apient

   std::string format (formatStyle how = defaultStyle) const

.. container:: apient

   RegisterAST makePC (Dyninst::Architecture arch) [static]

.. container:: apient

   bool operator< (const RegisterAST & rhs) const

.. container:: apient

   MachRegister getID () const

.. container:: apient

   RegisterAST::Ptr promote (const InstructionAST::Ptr reg) [static]

.. _`sec:immediate`:

Immediate Class
---------------

The Immediate class represents an immediate value in an operand.

Since an Immediate represents a constant value, the and interface are
disabled on Immediate objects. If an immediate value is being modified,
a new Immediate object should be created to represent the new value.

.. container:: apient

   virtual bool isUsed(InstructionAST::Ptr findMe) const

.. container:: apient

   void getChildren(vector<InstructionAST::Ptr> &) const

.. container:: apient

   void getUses(set<InstructionAST::Ptr> &)

.. container:: apient

   bool isUsed(InstructionAPI::Ptr findMe) const

.. _`sec:binaryFunction`:

BinaryFunction Class
--------------------

A object represents a function that can combine two s and produce
another .

For the purposes of representing a single operand of an instruction, the
s of interest are addition and multiplication of integer values; this
allows an to represent all addressing modes on the architectures
currently supported by the Instruction API.

.. container:: apient

   BinaryFunction(Expression::Ptr arg1, Expression::Ptr arg2,
   Result_Type result_type, funcT:Ptr func)

.. container:: apient

   const Result & eval () const

.. container:: apient

   void getChildren (vector< InstructionAST::Ptr > & children) const

.. container:: apient

   void getUses (set< InstructionAST::Ptr > & uses)

.. container:: apient

   bool isUsed (InstructionAST::Ptr findMe) const

.. _`sec:dereference`:

Dereference Class
-----------------

A object is an that dereferences another .

A contains an representing an effective address computation. Its use set
is the same as the use set of the being dereferenced.

It is not possible, given the information in a single instruction, to
evaluate the result of a dereference. may still be called on an that
includes dereferences, but the expected use case is as follows:

-  Determine the address being used in a dereference via the mechanism

-  Perform analysis to determine the contents of that address

-  If necessary, fill in the node with the contents of that addresss,
   using

The type associated with a node will be the type of the value *read*
*from* *memory*, not the type used for the address computation. Two s
that access the same address but interpret the contents of that memory
as different types will produce different values. The children of a at a
given address are identical, regardless of the type of dereference being
performed at that address. For example, the shown in Figure 6 could have
its root , which interprets the memory being dereferenced as a unsigned
16-bit integer, replaced with a that interprets the memory being
dereferenced as any other type. The remainder of the tree would,
however, remain unchanged.

.. container:: apient

   Dereference (Expression::Ptr addr, Result_Type result_type)

.. container:: apient

   virtual void getChildren (vector< InstructionAST::Ptr > & children)
   const

.. container:: apient

   virtual void getUses (set< InstructionAST::Ptr > & uses)

.. container:: apient

   virtual bool isUsed (InstructionAST::Ptr findMe) const

.. _`sec:instructionDecoder`:

InstructionDecoder Class
------------------------

The class decodes instructions, given a buffer of bytes and a length,
and constructs an Instruction.

.. container:: apient

   InstructionDecoder(const unsigned char \*buffer, size_t size,
   Architecture arch) InstructionDecoder(const void \*buffer, size_t
   size, Architecture arch)

.. container:: apient

   Instruction::Ptr decode();

.. [1]
   From *Elements of Reusable Object-Oriented Software* by Gamma, Helm,
   Johnson, and Vlissides
