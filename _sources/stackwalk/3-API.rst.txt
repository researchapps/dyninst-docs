.. _`sec:api`:

API Reference
=============

This section describes the StackwalkerAPI interface. It is divided into
three sub-sections: a description of the definitions and basic types
used by this API, a description of the interface for collecting
stackwalks, and a description of the callback interface.

Definitions and Basic Types
---------------------------

The following definitions and basic types are referenced throughout the
rest of this manual.

.. _`subsec:definitions`:

Definitions
~~~~~~~~~~~

Stack Frame
   A stack frame is a record of a function (or function-like object)
   invocation. When a function is executed, it may create a frame on the
   call stack. StackwalkerAPI finds stack frames and returns a
   description of them when it walks a call stack. The following three
   definitions deal with stack frames.

Bottom of the Stack
   The bottom of the stack is the earliest stack frame in a call stack,
   usually a thread’s initial function. The stack grows from bottom to
   the top.

Top of the Stack
   The top of the stack is the most recent stack frame in a call stack.
   The stack frame at the top of the stack is for the currently
   executing function.

Frame Object
   A Frame object is StackwalkerAPI’s representation of a stack frame. A
   Frame object is a snapshot of a stack frame at a specific point in
   time. Even if a stack frame changes as a process executes, a Frame
   object will remain the same. Each Frame object is represented by an
   instance of the Frame class.

The following three definitions deal with fields in a Frame object.

SP (Stack Pointer)
   A Frame object’s SP member points to the top of its stack frame (a
   stack frame grows from bottom to top, similar to a call stack). The
   Frame object for the top of the stack has a SP that is equal to the
   value in the stack pointer register at the time the Frame object was
   created. The Frame object for any other stack frame has a SP that is
   equal to the top address in the stack frame.

FP (Frame Pointer)
   A Frame object’s FP member points to the beginning (or bottom) of its
   stack frame. The Frame object for the top of the stack has a FP that
   is equal to the value in the frame pointer register at the time the
   Frame object was created. The Frame object for any other stack frame
   has a FP that is equal to the beginning of the stack frame.

RA (Return Address)
   A Frame object’s RA member points to the location in the code space
   where control will resume when the function that created the stack
   frame resumes. The Frame object for the top of the stack has a RA
   that is equal to the value in the program counter register at the
   time the Frame object was created. The Frame object for any other
   stack frame has a RA that is found when walking a call stack.

= [rectangle, draw, minimum width=3cm, minimum height=1.5em, font=, node
distance=1.5em] = [rectangle, minimum width=3cm, draw, minimum
height=1.5em, fill=white, draw=white] = [rectangle] = [rectangle, font=]
= [draw, -latex’]

= [rectangle, draw, minimum width=4cm, minimum height=1.5em, font=, node
distance=1.5em] = [rectangle, minimum width=4cm, draw, minimum
height=1.5em, fill=white, draw=white] = [rectangle] = [rectangle, font=]
= [draw, -latex’]

Figure `[fig:layout] <#fig:layout>`__ shows the relationship between
application code, stack frames, and Frame objects. In the figure, the
source code on the left has run through the main and foo functions, and
into the bar function. It has created the call stack in the center,
which is shown as a sequence of words growing down. The current values
of the processor registers, while executing in bar, are shown below the
call stack. When StackwalkerAPI walks the call stack, it creates the
Frame objects shown on the right. Each Frame object corresponds to one
of the stack frames found in the call stack or application registers.

The call stack in Figure `[fig:layout] <#fig:layout>`__ is similar to
one that would be found on the x86 architecture. Details about how the
call stack is laid out may be different on other architectures, but the
meanings of the FP, SP, and RA fields in the Frame objects will remain
the same. The layout of the ARM64 stack may be found in
Figure `[fig:layout-armv8] <#fig:layout-armv8>`__ as an example of the
scope of architectural variations.

The following four definitions deal with processes involved in
StackwalkerAPI.

Target Process
   The process from which StackwalkerAPI is collecting stackwalks.

Host Process
   The process in which StackwalkerAPI code is currently running.

First Party Stackwalk
   StackwalkerAPI collects first party stackwalk when it walks a call
   stack in the same address space it is running in, i.e. the target
   process is the same as the host process.

Third Party Stackwalk
   StackwalkerAPI collects third party stackwalk when it walks the call
   stack in a different address space from the one it is running in,
   i.e. the target process is different from the host process. A third
   party stackwalk is usually done through a debugger interface.

Basic Types
~~~~~~~~~~~

.. container:: apient

   typedef unsigned long Address

.. container:: apient

   typedef ... Dyninst::PID

.. container:: apient

   typedef ... Dyninst::THR_ID

.. container:: apient

   class Dyninst::MachRegister

.. container:: apient

   typedef unsigned long Dyninst::MachRegisterVal

Namespace StackwalkerAPI
------------------------

The classes in Section `1.3 <#sec:stackwalking-interface>`__ and
Section `1.6 <#sec:callback-interface>`__ fall under the C++ namespace
Dyninst::Stackwalker. To access them, a user should refer to them using
the Dyninst::Stackwalker:: prefix, e.g. Dyninst::Stackwalker::Walker.
Alternatively, a user can add the C++ using keyword above any references
to StackwalkerAPI objects, e.g, using namespace Dyninst and using
namespace Stackwalker.

.. _`sec:stackwalking-interface`:

Stackwalking Interface
----------------------

This section describes StackwalkerAPI’s interface for walking a call
stack. This interface is sufficient for walking call stacks on all the
systems and variations covered by our default callbacks.

To collect a stackwalk, first create new Walker object associated with
the target process via

::

       Walker::newWalker()

or

::

       Walker::newWalker(Dyninst::PID pid)

Once a Walker object has been created, a call stack can be walked with
the

::

   Walker::walkStack

method. The new stack walk is returned as a vector of Frame objects.

.. _`subsec:walker`:

Class Walker
~~~~~~~~~~~~

The class allows users to walk call stacks and query basic information
about threads in a target process. The user should create a object for
each process from which they are walking call stacks. Each object is
associated with one process, but may walk call stacks on multiple
threads within that process. The class allows users to query for the
threads available for walking, and it allows you to specify a particular
thread whose call stack should be walked. Stackwalks are returned as a
vector of Frame objects.

Each Walker object contains three objects:

-  ProcessState

-  StepperGroup

-  SymbolLookup

These objects are part of the Callback Interface and can be used to
customize StackwalkerAPI. The object tells how to access data in the
target process, and it determines whether this collects first party or
third party stackwalks. will pick an appropriate default object based on
which factory method the users calls. The object is used to customize
how the steps through stack frames. The object is used to customize how
StackwalkerAPI looks up symbolic names of the function or object that
created a stack frame.

.. container:: apient

   static Walker \*newWalker() static Walker \*newWalker(Dyninst::PID
   pid) static Walker \*newWalker(Dyninst::PID pid, std::string
   executable) static Walker
   \*newWalker(Dyninst::ProcControlAPI::Process::ptr proc); static
   Walker \*newWalker(std::string executable, const
   std::vector<std::string> &argv) static Walker
   \*newWalker(ProcessState \*proc, StepperGroup \*steppergroup = NULL ,
   SymbolLookup \*lookup = NULL)

.. container:: apient

   static bool newWalker(const std::vector<Dyninst::PID> &pids,
   std::vector<Walker \*> &walkers_out) static bool newWalker(const
   std::vector<Dyninst::PID> &pids, std::vector<Walker \*> &walkers_out,
   std::string executable)

.. container:: apient

   bool walkStack(std::vector<Frame> &stackwalk, Dyninst::THR_ID thread
   = NULL_THR_ID)

.. container:: apient

   bool walkStackFromFrame(std::vector<Frame> &stackwalk, const Frame
   &frame)

.. container:: apient

   bool walkSingleFrame(const Frame &in, Frame &out)

.. container:: apient

   bool getInitialFrame(Frame &frame, Dyninst::THR_ID thread =
   NULL_THR_ID)

.. container:: apient

   bool getAvailableThreads(std::vector<Dyninst::THR_ID> &threads)

.. container:: apient

   ProcessState \*getProcessState() const

.. container:: apient

   StepperGroup \*getStepperGroup() const

.. container:: apient

   SymbolLookup \*getSymbolLookup() const

.. container:: apient

   bool addStepper(FrameStepper \*stepper)

.. container:: apient

   static SymbolReaderFactory \*getSymbolReader()

.. container:: apient

   static void setSymbolReader(SymbolReaderFactory \*);

.. container:: apient

   static void version(int &major, int &minor, int &maintenance)

.. _`subsec:frame`:

Class Frame
~~~~~~~~~~~

The class returns a call stack as a vector of objects. As described in
Section `1.1.1 <#subsec:definitions>`__, each Frame object represents a
stack frame, and contains a return address (RA), stack pointer (SP) and
frame pointer (FP). For each of these values, optionally, it stores the
location where the values were found. Each Frame object may also be
augmented with symbol information giving a function name (or a symbolic
name, in the case of non-functions) for the object that created the
stack frame.

The Frame class provides a set of functions (getRALocation,
getSPLocation and getFPLocation) that return the location in the target
process’ memory or registers where the RA, SP, or FP were found. These
functions may be used to modify the stack. For example, the DyninstAPI
uses these functions to change return addresses on the stack when it
relocates code. The RA, SP, and FP may be found in a register or in a
memory address on a call stack.

.. container:: apient

   static Frame \*newFrame(Dyninst::MachRegisterVal ra,
   Dyninst::MachRegisterVal sp, Dyninst::MachRegisterVal fp, Walker
   \*walker)

.. container:: apient

   bool operator==(const Frame &)

.. container:: apient

   Dyninst::MachRegisterVal getRA() const

.. container:: apient

   void setRA(Dyninst::MachRegisterVal val)

.. container:: apient

   Dyninst::MachRegisterVal getSP() const

.. container:: apient

   void setSP(Dyninst::MachRegisterVal val)

.. container:: apient

   Dyninst::MachRegisterVal getFP() const

.. container:: apient

   void setFP(Dyninst::MachRegisterVal val)

.. container:: apient

   bool isTopFrame() const; bool isBottomFrame() const;

.. container:: apient

   typedef enum loc_address, loc_register, loc_unknown storage_t;

.. container:: apient

   typedef struct union Dyninst::Address addr; Dyninst::MachRegister
   reg; val; storage_t location; location_t;

.. container:: apient

   location_t getRALocation() const

.. container:: apient

   void setRALocation(location_t newval)

.. container:: apient

   location_t getSPLocation() const

.. container:: apient

   void setSPLocation(location_t newval)

.. container:: apient

   location_t getFPLocation() const

.. container:: apient

   void setFPLocation(location_t newval)

.. container:: apient

   bool getName(std::string &str) const

.. container:: apient

   bool getObject(void\* &obj) const

.. container:: apient

   Walker \*getWalker() const;

.. container:: apient

   THR_ID getThread() const;

.. container:: apient

   FrameStepper\* getStepper() const

.. container:: apient

   bool getLibOffset(std::string &lib, Dyninst::Offset &offset, void\*
   &symtab) const

.. container:: apient

   bool nonCall() const

Mapping Addresses to Libraries
------------------------------

StackwalkerAPI provides an interface to access the addresses where
libraries are mapped in the target process.

.. container:: apient

   typedef std::pair<std::string, Address> LibAddrPair;

.. container:: apient

   class LibraryState

.. container:: apient

   virtual bool getLibraryAtAddr(Address addr, LibAddrPair &lib) = 0;

.. container:: apient

   virtual bool getLibraries(std::vector<LibAddrPair> &libs, bool
   allow_refresh = true) = 0;

.. container:: apient

   virtual bool getLibc(LibAddrPair &lc);

.. container:: apient

   virtual bool getLibthread(LibAddrPair &lt);

.. container:: apient

   virtual bool getAOut(LibAddrPair &ao) = 0;

Accessing Local Variables
-------------------------

StackwalkerAPI can be used to access local variables found in the frames
of a call stack. The StackwalkerAPI interface for accessing the values
of local variables is closely tied to the SymtabAPI interface for
collecting information about local variables–SymtabAPI handles for
functions, local variables, and types are part of this interface.

Given an initial handle to a SymtabAPI Function object, SymtabAPI can
look up local variables contained in that function and the types of
those local variables. See the SymtabAPI Programmer’s Guide for more
information.

.. container:: apient

   static Dyninst::SymtabAPI::Function \*getFunctionForFrame(Frame f)

.. container:: apient

   static int glvv_Success = 0; static int glvv_EParam = -1; static int
   glvv_EOutOfScope = -2; static int glvv_EBufferSize = -3; static int
   glvv_EUnknown = -4;

.. container:: apient

   static int getLocalVariableValue(Dyninst::SymtabAPI::localVar \*var,
   std::vector<Frame> &swalk, unsigned frame, void \*out_buffer,
   unsigned out_buffer_size)

.. _`sec:callback-interface`:

Callback Interface
------------------

This subsection describes the Callback Interface for StackwalkerAPI. The
Callback Interface is primarily used to port StackwalkerAPI to new
platforms, extend support for new types of stack frames, or integrate
StackwalkerAPI into existing tools.

The classes in this subsection are interfaces, they cannot be
instantiated. To create a new implementation of one of these interfaces,
create a new class that inherits from the callback class and implement
the necessary methods. To use a new ProcessState, StepperGroup, or
SymbolLookup class with StackwalkerAPI, create a new instance of the
class and register it with a new Walker object using the

::

   Walker::newWalker(ProcessState *, StepperGroup *, SymbolLookup *)

factory method (see Section `1.3.1 <#subsec:walker>`__). To use a new
FrameStepper class with StackwalkerAPI, create a new instance of the
class and register it with a StepperGroup using the

::

   StepperGroup::addStepper(FrameStepper *)

method (see Section `1.6.3 <#subsec:steppergroup>`__).

Some of the classes in the Callback Interface have methods with default
implementations. A new class that inherits from a Callback Interface can
optionally implement these methods, but it is not required. If a method
requires implementation, it is written as a C++ pure virtual method ().
A method with a default implementation is written as a C++ virtual
method ().

.. _`subsec:defaults`:

Default Implementations
~~~~~~~~~~~~~~~~~~~~~~~

The classes described in the Callback Interface are C++ abstract
classes, or interfaces. They cannot be instantiated. For each of these
classes StackwalkerAPI provides one or more default implementations on
each platform. These default implementations are classes that inherit
from the abstract classes described in the Callback Interface. If a user
creates a Walker object without providing their own , , and objects,
then StackwalkerAPI will use the default implementations listed in
Table `1 <#table:defaults>`__. These implementations are described in
Section `[sec:framesteppers] <#sec:framesteppers>`__.

.. container::
   :name: table:defaults

   .. table:: Callback Interface Defaults

      +--------------+--------------+--------------+--------------+-------------------------+
      |              | StepperGroup | ProcessState | SymbolLookup | FrameStepper            |
      +==============+==============+==============+==============+=========================+
      | Linux/x86    | 1. AddrRange | 1. ProcSelf  | 1. SwkSymtab | 1. FrameFuncStepper     |
      +--------------+--------------+--------------+--------------+-------------------------+
      | Linux/x86-64 |              | 2. ProcDebug |              | 2. SigHandlerStepper    |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 3. DebugStepper         |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 4. AnalysisStepper      |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 5. StepperWanderer      |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 6. BottomOfStackStepper |
      +--------------+--------------+--------------+--------------+-------------------------+
      | Linux/PPC    | 1. AddrRange | 1. ProcSelf  | 1. SwkSymtab | 1. FrameFuncStepper     |
      +--------------+--------------+--------------+--------------+-------------------------+
      | Linux/PPC-64 |              | 2. ProcDebug |              | 2. SigHandlerStepper    |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 3. AnalysisStepper      |
      +--------------+--------------+--------------+--------------+-------------------------+
      | Windows/x86  | 1. AddrRange | 1. ProcSelf  | 1. SwkSymtab | 1. FrameFuncStepper     |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              | 2. ProcDebug |              | 2. AnalysisStepper      |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 3. StepperWanderer      |
      +--------------+--------------+--------------+--------------+-------------------------+
      |              |              |              |              | 4. BottomOfStackStepper |
      +--------------+--------------+--------------+--------------+-------------------------+

.. _`subsec:framestepper`:

Class FrameStepper
~~~~~~~~~~~~~~~~~~

The class is an interface that tells StackwalkerAPI how to walk through
a specific type of stack frame. There may be many different ways of
walking through a stack frame on a platform, e.g, on Linux/x86 there are
different mechanisms for walking through system calls, signal handlers,
regular functions, and frameless functions. A single describes how to
walk through one of these types of stack frames.

A user can create their own classes that tell StackwalkerAPI how to walk
through new types of stack frames. A new object must be added to a
before it can be used.

In addition to walking through individual stack frames, a tells its when
it can be used. The registers address ranges that cover objects in the
target process’ code space (such as functions). These address ranges
should contain the objects that will create stack frames through which
the can walk. If multiple objects have overlapping address ranges, then
a priority value is used to determine which should be attempted first.

is an interface class; it cannot be instantiated. Users who want to
develop new objects should inherit from this class and implement the the
desired virtual functions. The , and functions must be implemented; all
others may be overridden if desired.

.. container:: apient

   typedef enum gcf_success, gcf_stackbottom, gcf_not_me, gcf_error
   gcframe_ret_t

.. container:: apient

   virtual gcframe_ret_t getCallerFrame(const Frame &in, Frame &out) = 0

.. container:: apient

   virtual void registerStepperGroup(StepperGroup \*steppergroup)

.. container:: apient

   virtual unsigned getPriority() const = 0

.. container:: apient

   FrameStepper(Walker \*w);

.. container:: apient

   virtual ProcessState \*getProcessState();

.. container:: apient

   virtual Walker \*getWalker();

.. container:: apient

   typedef std::pair<std::string, Address> LibAddrPair; typedef enum
   library_load, library_unload lib_change_t; virtual void
   newLibraryNotification(LibAddrPair \*libAddr, lib_change_t change);

.. container:: apient

   virtual const char \*getName() const = 0;

.. _`subsec:steppergroup`:

Class StepperGroup
~~~~~~~~~~~~~~~~~~

The class contains a collection of objects. The ’s primary job is to
decide which should be used to walk through a stack frame given a return
address. The default keeps a set of address ranges for each . If
multiple objects overlap an address, then the default will use a
priority system to decide.

provides both an interface and a default implementation of that
interface. Users who want to customize the should inherit from this
class and re-implement any of the below virtual functions.

.. container:: apient

   StepperGroup(Walker \*walker)

.. container:: apient

   virtual bool addStepper(FrameStepper \*stepper)

.. container:: apient

   virtual bool addStepper(FrameStepper \*stepper, Address start,
   Address end) = 0;

.. container:: apient

   virtual void registerStepper(FrameStepper \*stepper);

.. container:: apient

   virtual bool findStepperForAddr(Address addr, FrameStepper\* &out,
   const FrameStepper \*last_tried = NULL) = 0

.. container:: apient

   typedef std::pair<std::string, Address> LibAddrPair; typedef enum
   library_load, library_unload lib_change_t; virtual void
   newLibraryNotification(LibAddrPair \*libaddr, lib_change_t change);

.. container:: apient

   Walker \*getWalker() const

.. container:: apient

   void getSteppers(std::set<FrameStepper \*> &);

.. _`subsec:processstate`:

Class ProcessState
~~~~~~~~~~~~~~~~~~

The ProcessState class is a virtual class that defines an interface
through which StackwalkerAPI can access the target process. It allows
access to registers and memory, and provides basic information about the
threads in the target process. StackwalkerAPI provides two default types
of objects: does a first party stackwalk, and does a third party
stackwalk.

A new class can be created by inheriting from this class and
implementing the necessary methods.

.. container:: apient

   static ProcessState \*getProcessStateByPid(Dyninst::PID pid)

.. container:: apient

   virtual unsigned getAddressWidth() = 0;

.. container:: apient

   typedef enum Arch_x86, Arch_x86_64, Arch_ppc32, Arch_ppc64
   Architecture; virtual Dyninst::Architecture getArchitecture() = 0;

.. container:: apient

   virtual bool getRegValue(Dyninst::MachRegister reg, Dyninst::THR_ID
   thread, Dyninst::MachRegisterVal &val) = 0

.. container:: apient

   virtual bool readMem(void \*dest, Address source, size_t size) = 0

.. container:: apient

   virtual bool getThreadIds(std::vector<Dyninst::THR_ID> &threads) = 0

.. container:: apient

   virtual bool getDefaultThread(Dyninst::THR_ID &default_tid) = 0

.. container:: apient

   virtual Dyninst::PID getProcessId()

.. container:: apient

   Walker \*getWalker() const;

.. container:: apient

   std::string getExecutablePath();

Class LibraryState
^^^^^^^^^^^^^^^^^^

is a helper class for that provides information about the current DSOs
(libraries and executables) that are loaded into a process’ address
space. FrameSteppers frequently use the LibraryState to get the DSO
through which they are attempting to stack walk.

Each is represented using a object, which is defined as follows:

.. container:: apient

   typedef std::pair<std::string, Dyninst::Address> LibAddrPair

.. container:: apient

   virtual bool getLibraryAtAddr(Address addr, LibAddrPair &lib) = 0

.. container:: apient

   virtual bool getLibraries(std::vector<LibAddrPair> &libs) = 0

.. container:: apient

   virtual void notifyOfUpdate() = 0

.. container:: apient

   virtual Address getLibTrapAddress() = 0

Class SymbolLookup
~~~~~~~~~~~~~~~~~~

The virtual class is an interface for associating a symbolic name with a
stack frame. Each object contains an address (the RA) pointing into the
function (or function-like object) that created its stack frame.
However, users do not always want to deal with addresses when symbolic
names are more convenient. This class is an interface for mapping a
object’s RA into a name.

In addition to getting a name, this class can also associate an opaque
object (via a ) with a Frame object. It is up to the implementation what
to return in this opaque object.

The default implementation of provided by StackwalkerAPI uses the tool
to lookup symbol names. It returns a Symbol object in the anonymous .

.. container:: apient

   SymbolLookup(std::string exec_path = "");

.. container:: apient

   virtual bool lookupAtAddr(Address addr, string &out_name, void\*
   &out_value) = 0

.. container:: apient

   virtual Walker \*getWalker()

.. container:: apient

   virtual ProcessState \*getProcessSate()
