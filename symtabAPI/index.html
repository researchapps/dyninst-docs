<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Symtab API Introduction &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Stackwalk Introduction" href="../stackwalk/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Instruction API Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html">Introduction to Parse API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#parse-api-abstractions">Parse API Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#parse-api-examples">Parse API Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patch-api-abstractions">Patch API Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patch-api-examples">Patch API Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Stackwalk Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#stackwalk-abstractions">Stackwalk Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#stackwalk-api-reference">Stackwalk API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Symtab API Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#symtab-abstractions">Symtab Abstractions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#symbol-table-interface">Symbol Table Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-interface">Type Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#line-number-interface">Line Number Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#local-variable-interface">Local Variable Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-address-translation">Dynamic Address Translation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="#symtab-definitions-and-basic-types">Symtab Definitions and Basic Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#symtab-definitions">Symtab Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symtab-basic-types">Symtab Basic Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class-symtab">Class Symtab</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#file-opening-parsing">File opening/parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-lookup">Module lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-variable-and-symbol-lookup">Function, Variable, and Symbol lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#region-lookup">Region lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#insertion-and-modification">Insertion and modification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#catch-and-exception-block-lookup">Catch and Exception block lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symtab-information">Symtab information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#line-number-information">Line number information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-information">Type information</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-module">Class Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-variable-symbol-lookup">Function, Variable, Symbol lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#line-number-information-for-symtab">Line number information for Symtab</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-information-symtab">Type information Symtab</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-functionbase">Class FunctionBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symbtab-class-function">Symbtab Class Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-inlinedfunction">Class InlinedFunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-variable">Class Variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-symbol">Class Symbol</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#symbol-modification">Symbol modification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-archive">Class Archive</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-region">Class Region</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#removed">REMOVED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#relocation-information">Relocation Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-exceptionblock">Class ExceptionBlock</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-localvar">Class localVar</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-variablelocation">Class VariableLocation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#api-reference-line-number-interface">API Reference - Line Number Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class-lineinformation">Class LineInformation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-statement">Class Statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterating-over-line-information">Iterating over Line Information</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#api-reference-type-interface">API Reference - Type Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class-type">Class Type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-typeenum">Class typeEnum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-typefunction">Class typeFunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-typescalar">Class typeScalar</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-field">Class Field</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-fieldlisttype">Class fieldListType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#class-typestruct-public-fieldlisttype">Class typeStruct : public fieldListType</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-typeunion">Class typeUnion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-typecommon">Class typeCommon</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-cblock">Class CBlock</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-derivedtype">Class derivedType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#class-typepointer">Class typePointer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-typetypedef">Class typeTypedef</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-typeref">Class typeRef</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-rangedtype">Class rangedType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#class-typesubrange">Class typeSubrange</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-typearray">Class typeArray</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#api-reference-dynamic-components">API Reference - Dynamic Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#class-addresslookup">Class AddressLookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-processreader">Class ProcessReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#building-symtabapi">Building SymtabAPI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#building-on-unix">Building on Unix</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-on-windows">Building on Windows</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Symtab API Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/symtabAPI/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="symtab-api-introduction">
<span id="sec-symtab-intro"></span><h1>Symtab API Introduction<a class="headerlink" href="#symtab-api-introduction" title="Permalink to this headline"></a></h1>
<p>SymtabAPI is a multi-platform library for parsing symbol tables, object
file headers and debug information. SymtabAPI currently supports the ELF
(IA-32, AMD-64, ARMv8-64, and POWER) and PE (Windows) object file
formats. In addition, it also supports the DWARF debugging format.</p>
<p>The main goal of this API is to provide an abstract view of binaries and
libraries across multiple platforms. An abstract interface provides two
benefits: it simplifies the development of a tool since the complexity
of a particular file format is hidden, and it allows tools to be easily
ported between platforms. Each binary object file is represented in a
canonical platform independent manner by the API. The canonical format
consists of four components: a header block that contains general
information about the object (e.g., its name and location), a set of
symbol lists that index symbols within the object for fast lookup, debug
information (type, line number and local variable information) present
in the object file and a set of additional data that represents
information that may be present in the object (e.g., relocation or
exception information). Adding a new format requires no changes to the
interface and hence will not affect any of the tools that use the
SymtabAPI.</p>
<p>Our other design goal with SymtabAPI is to allow users and tool
developers to easily extend or add symbol or debug information to the
library through a platform-independent interface. Often times it is
impossible to satify all the requirements of a tool that uses SymtabAPI,
as those requirements can vary from tool to tool. So by providing
extensible structures, SymtabAPI allows tools to modify any structure to
fit their own requirements. Also, tools frequently use more
sophisticated analyses to augment the information available from the
binary directly; it should be possible to make this extra information
available to the SymtabAPI library. An example of this is a tool
operating on a stripped binary. Although the symbols for the majority of
functions in the binary may be missing, many can be determined via more
sophisticated analysis. In our model, the tool would then inform the
SymtabAPI library of the presence of these functions; this information
would be incorporated and available for subsequent analysis. Other
examples of such extensions might involve creating and adding new types
or adding new local variables to certain functions.</p>
</div>
<div class="section" id="symtab-abstractions">
<span id="sec-symtab-abstractions"></span><h1>Symtab Abstractions<a class="headerlink" href="#symtab-abstractions" title="Permalink to this headline"></a></h1>
<p>= [rectangle, draw, fill=green!25] = [rectangle, draw, rounded corners,
fill=yellow!25] = [ellipse, draw, fill=red!25] = [trapezium, trapezium
left angle=70, trapezium right angle=70, draw, fill=cyan!25] = []</p>
<p>SymtabAPI provides a simple set of abstractions over complicated data
structures which makes it straight-forward to use. The SymtabAPI
consists of five classes of interfaces: the symbol table interface, the
type interface, the line map interface, the local variable interface,
and the address translation interface.</p>
<p>Figure&nbsp;<a class="reference external" href="#fig:object-ownership">[fig:object-ownership]</a> shows the
ownership hierarchy for the SymtabAPI classes. Ownership here is a
“contains” relationship; if one class owns another, then instances of
the owner class maintain an exclusive instance of the other. For
example, each Symtab class instance contains multiple instances of class
Symbol and each Symbol class instance belongs to one Symtab class
instance. Each of four interfaces and the classes belonging to these
interfaces are described in the rest of this section. The API functions
in each of the classes are described in detail in Section
<a class="reference external" href="#sec:symtabAPI">6</a>.</p>
<div class="section" id="symbol-table-interface">
<h2>Symbol Table Interface<a class="headerlink" href="#symbol-table-interface" title="Permalink to this headline"></a></h2>
<p>The symbol table interface is responsible for parsing the object file
and handling the look-up and addition of new symbols. It is also
responsible for the emit functionality that SymtabAPI supports. The
Symtab and the Module classes inherit from the LookupInterface class, an
abstract class, ensuring the same lookup function signatures for both
Module and Symtab classes.</p>
<dl class="docutils">
<dt>Symtab</dt><dd>A Symtab class object represents either an object file on-disk or
in-memory that the SymtabAPI library operates on.</dd>
<dt>Symbol</dt><dd>A Symbol class object represents an entry in the symbol table.</dd>
<dt>Module</dt><dd>A Module class object represents a particular source file in cases
where multiple files were compiled into a single binary object; if
this information is not present, we use a single default module.</dd>
<dt>Archive</dt><dd>An Archive class object represents a collection of binary objects
stored in a single file (e.g., a static archive).</dd>
<dt>ExceptionBlock</dt><dd>An ExceptionBlock class object represents an exception block which
contains the information necessary for run-time exception handling.</dd>
</dl>
<p>In addition, we define two symbol aggregates, Function and Variable.
These classes collect multiple symbols with the same address and type
but different names; for example, weak and strong symbols for a single
function.</p>
</div>
<div class="section" id="type-interface">
<span id="subsec-typeinterface"></span><h2>Type Interface<a class="headerlink" href="#type-interface" title="Permalink to this headline"></a></h2>
<p>The Type interface is responsible for parsing type information from the
object file and handling the look-up and addition of new type
information. Figure <a class="reference external" href="#fig:class-inherit">[fig:class-inherit]</a> shows
the class inheritance diagram for the type interface. Class Type is the
base class for all of the classes that are part of the interface. This
class provides the basic common functionality for all the types, such as
querying the name and size of a type. The rest of the classes represent
specific types and provide more functionality based on the type.</p>
<p>= [rectangle, draw, rounded corners, fill=yellow!100] = [rectangle,
draw, rounded corners, fill=yellow!100, node distance=.65cm] =
[rectangle, draw, rounded corners, pattern=north west lines, pattern
color=yellow] = []</p>
<p>Some of the types inherit from a second level of type classes, each
representing a separate category of types.</p>
<dl class="docutils">
<dt>fieldListType</dt><dd><ul class="simple">
<li>This category of types represent the container types that contain a list of fields. Examples of this category include structure and the union types.</li>
</ul>
</dd>
<dt>derivedType</dt><dd><ul class="simple">
<li>This category of types represent types derived from a base type. Examples of this category include typedef, pointer and reference types.</li>
</ul>
</dd>
<dt>rangedType</dt><dd><ul class="simple">
<li>This category represents range types. Examples of this category include the array and the sub-range types.</li>
</ul>
</dd>
</dl>
<p>The enum, function, common block and scalar types do not fall under any
of the above category of types. Each of the specific types is derived
from Type.</p>
</div>
<div class="section" id="line-number-interface">
<h2>Line Number Interface<a class="headerlink" href="#line-number-interface" title="Permalink to this headline"></a></h2>
<p>The Line Number interface is responsible for parsing line number
information from the object file debug information and handling the
look-up and addition of new line information. The main classes for this
interface are LineInformation and LineNoTuple.</p>
<dl class="docutils">
<dt>LineInformation</dt><dd>A LineInformation class object represents a mapping of line numbers
to address range within a module (source file).</dd>
<dt>Statement/LineNoTuple</dt><dd>A Statement class object represents a location in source code with
a source file, line number in that source file and start column in
that line. For backwards compatibility, Statements may also be
referred to as LineNoTuples.</dd>
</dl>
</div>
<div class="section" id="local-variable-interface">
<h2>Local Variable Interface<a class="headerlink" href="#local-variable-interface" title="Permalink to this headline"></a></h2>
<p>The Local Variable Interface is responsible for parsing local variable
and parameter information of functions from the object file debug
information and handling the look-up and addition of new add new local
variables. All the local variables within a function are tied to the
Symbol class object representing that function.</p>
<dl class="docutils">
<dt>localVar</dt><dd>A localVar class object represents a local variable or a parameter
belonging to a function.</dd>
</dl>
</div>
<div class="section" id="dynamic-address-translation">
<h2>Dynamic Address Translation<a class="headerlink" href="#dynamic-address-translation" title="Permalink to this headline"></a></h2>
<p>The AddressLookup class is a component for mapping between absolute
addresses found in a running process and SymtabAPI objects. This is
useful because libraries can load at different addresses in different
processes. Each AddressLookup instance is associated with, and provides
mapping for, one process.</p>
</div>
</div>
<div class="section" id="simple-examples">
<h1>Simple Examples<a class="headerlink" href="#simple-examples" title="Permalink to this headline"></a></h1>
<p>To illustrate the ideas in the API, this section presents several short
examples that demonstrate how the API can be used. SymtabAPI has the
ability to parse files that are on-disk or present in memory. The user
program starts by requesting SymtabAPI to parse an object file.
SymtabAPI returns a handle if the parsing succeeds, whcih can be used
for further interactions with the SymtabAPI library. The following
example shows how to parse a shared object file on disk.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Name the object file to be parsed:</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;libfoo.so&quot;</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Declare a pointer to an object of type Symtab; this represents the file.</span>
<span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Parse the object file</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Symtab</span><span class="o">::</span><span class="n">openFile</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Once the object file is parsed successfully and the handle is obtained,
symbol look up and update operations can be performed in the following
way:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">syms</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Function</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">funcs</span><span class="p">;</span><span class="w"></span>

<span class="c1">// search for a function with demangled (pretty) name &quot;bar&quot;.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">findFunctionsByName</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Add a new (mangled) primary name to the first function</span>
<span class="w">       </span><span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addMangledName</span><span class="p">(</span><span class="s">&quot;newname&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// search for symbol of any type with demangled (pretty) name &quot;bar&quot;.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">findSymbol</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">::</span><span class="n">ST_UNKNOWN</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// change the type of the found symbol to type variable(ST_OBJECT)</span>
<span class="w">    </span><span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setType</span><span class="p">(</span><span class="n">Symbol</span><span class="o">::</span><span class="n">ST_OBJECT</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// These changes are automatically added to symtabAPI; no further</span>
<span class="w">    </span><span class="c1">// actions are required by the user.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>New symbols, functions, and variables can be created and added to the
library at any point using the handle returned by successful parsing of
the object file. When possible, add a function or variable rather than a
symbol directly.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Module for the symbol</span>
<span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">mod</span><span class="p">;</span><span class="w"></span>

<span class="c1">// obj represents a handle to a parsed object file.</span>
<span class="c1">// Lookup module handle for &quot;DEFAULT_MODULE&quot;</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">findModuleByName</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DEFAULT_MODULE&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create a new function symbol</span>
<span class="n">Variable</span><span class="w"> </span><span class="o">*</span><span class="n">newVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">createVariable</span><span class="p">(</span><span class="s">&quot;newIntVar&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// Name of new variable</span>
<span class="w">                                       </span><span class="mh">0x12345</span><span class="p">,</span><span class="w">      </span><span class="c1">// Offset from data section</span>
<span class="w">                                       </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// Size of symbol</span>
</pre></div>
</div>
<p>SymtabAPI gives the ability to query type information present in the
object file. Also, new user defined types can be added to SymtabAPI. The
following example shows both how to query type information after an
object file is successfully parsed and also add a new structure type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a new struct Type</span>
<span class="c1">// typedef struct{</span>
<span class="c1">//int field1,</span>
<span class="c1">//int field2[10]</span>
<span class="c1">// } struct1;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Find a handle to the integer type; obj represents a handle to a parsed object file</span>
<span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">lookupType</span><span class="p">;</span><span class="w"></span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">findType</span><span class="p">(</span><span class="n">lookupType</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;int&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Convert the generic type object to the specific scalar type object</span>
<span class="n">typeScalar</span><span class="w"> </span><span class="o">*</span><span class="n">intType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupType</span><span class="o">-&gt;</span><span class="n">getScalarType</span><span class="p">();</span><span class="w"></span>

<span class="c1">// container to hold names and types of the new structure type</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="n">fields</span><span class="p">;</span><span class="w"></span>

<span class="c1">//create a new array type(int type2[10])</span>
<span class="n">typeArray</span><span class="w"> </span><span class="o">*</span><span class="n">intArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeArray</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;intArray&quot;</span><span class="p">,</span><span class="n">intType</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="p">);</span><span class="w"></span>

<span class="c1">//types of the structure fields</span>
<span class="n">fields</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;field1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">intType</span><span class="p">));</span><span class="w"></span>
<span class="n">fields</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;field2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">intArray</span><span class="p">));</span><span class="w"></span>

<span class="c1">//create the structure type</span>
<span class="n">typeStruct</span><span class="w"> </span><span class="o">*</span><span class="n">struct1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeStruct</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;struct1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fields</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Users can also query line number information present in an object file.
The following example shows how to use SymtabAPI to get the address
range for a line number within a source file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">// obj represents a handle to a parsed object file using symtabAPI</span>
<span class="c1">// Container to hold the address range</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Offset</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ranges</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Get the address range for the line 30 in source file foo.c</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">getAddressRanges</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo.c&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Local variable information can be obtained using symtabAPI. You can
query for a local variable within the entire object file or just within
a function. The following example shows how to find local variable foo
within function bar.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Obj represents a handle to a parsed object file using symtabAPI</span>
<span class="c1">// Get the Symbol object representing function bar</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">syms</span><span class="p">;</span><span class="w"></span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">findSymbol</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">::</span><span class="n">ST_FUNCTION</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Find the local var foo within function bar</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">vars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">findLocalVarible</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The rest of this document describes the class hierarchy and the API in
detail.</p>
</div>
<div class="section" id="symtab-definitions-and-basic-types">
<h1>Symtab Definitions and Basic Types<a class="headerlink" href="#symtab-definitions-and-basic-types" title="Permalink to this headline"></a></h1>
<p>The following definitions and basic types are referenced throughout the
rest of this document.</p>
<div class="section" id="symtab-definitions">
<h2>Symtab Definitions<a class="headerlink" href="#symtab-definitions" title="Permalink to this headline"></a></h2>
<dl class="docutils">
<dt>Offset</dt><dd>Offsets represent an address relative to the start address(base) of
the object file. For executables, the Offset represents an absolute
address. The following definitions deal with the symbol table
interface.</dd>
<dt>Object File</dt><dd>An object file is the representation of code that a compiler or
assembler generates by processing a source code file. It represents
.o’s, a.out’s and shared libraries.</dd>
<dt>Region</dt><dd>A region represents a contiguous area of the file that contains
executable code or readable data; for example, an ELF section.</dd>
<dt>Symbol</dt><dd>A symbol represents an entry in the symbol table, and may identify a
function, variable or other structure within the file.</dd>
<dt>Function</dt><dd>A function represents a code object within the file represented by
one or more symbols.</dd>
<dt>Variable</dt><dd>A variable represents a data object within the file represented by
one or more symbols.</dd>
<dt>Module</dt><dd>A module represents a particular source file in cases where multiple
files were compiled into a single binary object; if this information
is not present, or if the binary object is a shared library, we use a
single default module.</dd>
<dt>Archive</dt><dd>An archive represents a collection of binary objects stored in a
single file (e.g., a static archive).</dd>
<dt>Relocations</dt><dd>These provide the necessary information for inter-object references
between two object files.</dd>
<dt>Exception Blocks</dt><dd>These contain the information necessary for run-time exception
handling The following definitions deal with members of the Symbol
class.</dd>
<dt>Mangled Name</dt><dd>A mangled name for a symbol provides a way of encoding additional
information about a function, structure, class or another data type
in a symbol name. It is a technique used to produce unique names for
programming entities in many modern programming languages. For
example, the method <em>foo</em> of class C with signature <em>int C::foo(int,
int)</em> has a mangled name <em>_ZN1C3fooEii</em> when compiled with gcc.
Mangled names may include a sequence of clone suffixes (begins with
‘.’ that indicate a compiler synthesized function), and this may be
followed by a version suffix (begins with ‘&#64;’).</dd>
<dt>Pretty Name</dt><dd>A pretty name for a symbol is the demangled user-level symbolic name
without type information for the function parameters and return
types. For non-mangled names, the pretty name is the symbol name. Any
function clone suffixes of the symbol are appended to the result of
the demangler. For example, a symbol with a mangled name
<em>_ZN1C3fooEii</em> for the method <em>int C::foo(int, int)</em> has a pretty
name <em>C::foo</em>. Version suffixes are removed from the mangled name
before conversion to the pretty name. The pretty name can be obtained
by running the command line tool <code class="docutils literal notranslate"><span class="pre">c++filt</span></code> as
<code class="docutils literal notranslate"><span class="pre">c++filt</span> <span class="pre">-i</span> <span class="pre">-p</span> <span class="pre">name</span></code>, or using the libiberty library function
<code class="docutils literal notranslate"><span class="pre">cplus_demangle</span></code> with options of <code class="docutils literal notranslate"><span class="pre">DMGL_AUTO</span> <span class="pre">|</span> <span class="pre">DMGL_ANSI</span></code>.</dd>
<dt>Typed Name</dt><dd>A typed name for a symbol is the demangled user-level symbolic name
including type information for the function parameters. Typically,
but not always, function return type information is not included. Any
function clone information is also included. For non-mangled names,
the typed name is the symbol name. For example, a symbol with a
mangled name <em>_ZN1C3fooEii</em> for the method <em>int C::foo(int, int)</em>
has a typed name <em>C::foo(int, int)</em>. Version suffixes are removed
from the mangled name before conversion to the typed name. The typed
name can be obtained by running the command line tool <code class="docutils literal notranslate"><span class="pre">c++filt</span></code> as
<code class="docutils literal notranslate"><span class="pre">c++filt</span> <span class="pre">-i</span> <span class="pre">name</span></code>, or using the libiberty library function
<code class="docutils literal notranslate"><span class="pre">cplus_demangle</span></code> with options of
<code class="docutils literal notranslate"><span class="pre">DMGL_AUTO</span> <span class="pre">|</span> <span class="pre">DMGL_ANSI</span> <span class="pre">|</span> <span class="pre">DMGL_PARAMS</span></code>.</dd>
<dt>Symbol Linkage</dt><dd>The symbol linkage for a symbol gives information on the visibility
(binding) of this symbol, whether it is visible only in the object
file where it is defined (local), if it is visible to all the object
files that are being linked (global), or if its a weak alias to a
global symbol.</dd>
<dt>Symbol Type</dt><dd>Symbol type for a symbol represents the category of symbols to which
it belongs. It can be a function symbol or a variable symbol or a
module symbol. The following definitions deal with the type and the
local variable interface.</dd>
<dt>Type</dt><dd>A type represents the data type of a variable or a parameter. This
can represent language pre-defined types (e.g. int, float),
pre-defined types in the object (e.g., structures or unions), or
user-defined types.</dd>
<dt>Local Variable</dt><dd>A local variable represents a variable that has been declared within
the scope of a sub-routine or a parameter to a sub-routine.</dd>
</dl>
</div>
<div class="section" id="symtab-basic-types">
<h2>Symtab Basic Types<a class="headerlink" href="#symtab-basic-types" title="Permalink to this headline"></a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">Offset</span><span class="w"></span>
</pre></div>
</div>
<p>An integer value that contains an offset from base address of the object
file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">typeId_t</span><span class="w"></span>
</pre></div>
</div>
<p>A unique handle for identifying a type. Each of types is assigned a
globally unique ID. This way it is easier to identify any data type of a
variable or a parameter.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">PID</span><span class="w"></span>
</pre></div>
</div>
<p>A handle for identifying a process that is used by the dynamic
components of SymtabAPI. On UNIX platforms PID is a int, on Windows it
is a HANDLE that refers to a process.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">Address</span><span class="w"></span>
</pre></div>
</div>
<p>An integer value that represents an address in a process. This is used
by the dynamic components of SymtabAPI.</p>
</div>
</div>
<div class="section" id="namespace-symtabapi">
<h1>Namespace SymtabAPI<a class="headerlink" href="#namespace-symtabapi" title="Permalink to this headline"></a></h1>
<p>The classes described in the following sections are under the C++
namespace Dyninst::SymtabAPI. To access them a user should refer to them
using the Dyninst:: and SymtabAPI:: prefixes, e.g.
Dyninst::SymtabAPI::Type. Alternatively, a user can add the C++ using
keyword above any references to SymtabAPI objects, e.g, using namespace
Dyninst and using namespace SymtabAPI.</p>
</div>
<div class="section" id="api-reference-symbol-table-interface">
<span id="sec-symtabapi"></span><h1>API Reference - Symbol Table Interface<a class="headerlink" href="#api-reference-symbol-table-interface" title="Permalink to this headline"></a></h1>
<p>This section describes the symbol table interface for the SymtabAPI
library. Currently this interface has the following capabilities:</p>
<ul class="simple">
<li>Parsing the symbols in a binary, either on disk or in memory</li>
<li>Querying for symbols</li>
<li>Updating existing symbol information</li>
<li>Adding new symbols</li>
<li>Exporting symbols in standard formats</li>
<li>Accessing relocation and exception information</li>
<li>Accessing and modifying header information</li>
</ul>
<p>The symbol table information is represented by the Symtab, Symbol,
Archive, and Region classes. Module, Function, and Variable provide
abstractions that support common use patterns. Finally, LocalVar
represents function-local variables and parameters.</p>
<div class="section" id="class-symtab">
<h2>Class Symtab<a class="headerlink" href="#class-symtab" title="Permalink to this headline"></a></h2>
<p><strong>Defined in:</strong> <code class="docutils literal notranslate"><span class="pre">Symtab.h</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> class represents an object file either on-disk or
in-memory. This class is responsible for the parsing of the <code class="docutils literal notranslate"><span class="pre">Object</span></code>
file information and holding the data that can be accessed through look
up functions.</p>
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">The Symtab Class</span><a class="headerlink" href="#id1" title="Permalink to this table"></a></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">file</span></code></td>
<td>std::string</td>
<td>Full path to the opened file or provided name for the memory image.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">name</span></code></td>
<td>std::string</td>
<td>File name without path.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">memberName</span></code></td>
<td>std::string</td>
<td>For archive (.a) files, returns the object file (.o) this Symtab represents.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">getNumberOfRegions</span></code></td>
<td>unsigned</td>
<td>Number of regions.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">getNumberOfSymbols</span></code></td>
<td>unsigned</td>
<td>Total number of symbols in both the static and dynamic tables.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">mem_image</span></code></td>
<td>char *</td>
<td>Pointer to memory image for the Symtab; not valid for disk files.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">imageOffset</span></code></td>
<td>Offset</td>
<td>Offset at the first code segment from the start of the binary.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">dataOffset</span></code></td>
<td>Offset</td>
<td>Offset at the first data segment from the start of the binary.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">imageLength</span></code></td>
<td>Offset</td>
<td>Size of the primary code-containing region, typically .text.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">dataLength</span></code></td>
<td>Offset</td>
<td>Size of the primary data-containing region, typically .data.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">isStaticBinary</span></code></td>
<td>bool</td>
<td>True if the binary was compiled statically.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">isExecutable</span></code></td>
<td>bool</td>
<td>True if the file is an executable.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">isSharedLibrary</span></code></td>
<td>bool</td>
<td>True if the file is a shared library.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">isExec</span></code></td>
<td>bool</td>
<td>True if the file can only be an executable, false otherwise including both executables and shared libraries. Typically files that are bot executables and shared libraries are primarily used as libraries, if you need to determine specifics use the methods <code class="docutils literal notranslate"><span class="pre">isExecutable</span></code> and <code class="docutils literal notranslate"><span class="pre">isSharedLibrary</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">isStripped</span></code></td>
<td>bool</td>
<td>True if the file was stripped of symbol table information.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">getAddressWidth</span></code></td>
<td>unsigned</td>
<td>Size (in bytes) of a pointer value in the Symtab; 4 for 32-bit binaries and 8 for 64-bit binaries.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">getArchitecture</span></code></td>
<td>Architecture</td>
<td>Representation of the system architecture for the binary.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">getLoadOffset</span></code></td>
<td>Offset</td>
<td>The suggested load offset of the file; typically 0 for shared libraries.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">getEntryOffset</span></code></td>
<td>Offset</td>
<td>The entry point (where execution beings) of the binary.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">getBaseOffset</span></code></td>
<td>Offset</td>
<td>(Windows only) the OS-specified base offset of the file.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ObjectType</span><span class="w"> </span><span class="n">getObjectType</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method queries information on the type of the object file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isExecutable</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSharedLibrary</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isExec</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>These methods respectively return true if the Symtab’s object is an
executable, a shared library, and an executable is that is not a shared
library. An object may be both an executable and a shared library.</p>
<p>An Elf Object that can be loaded into memory to form an executable’s
image has one of two types: ET_EXEC and ET_DYN. ET_EXEC type objects are
executables that are loaded at a fixed address determined at link time.
ET_DYN type objects historically were shared libraries that are loaded
at an arbitrary location in memory and are position independent code
(PIC). The ET_DYN object type was reused for position independent
executables (PIE) that allows the executable to be loaded at an
arbitrary location in memory. Although generally not the case an object
can be both a PIE executable and a shared library. Examples of these
include libc.so and the dynamic linker library (ld.so). These objects
are generally used as a shared library so <code class="docutils literal notranslate"><span class="pre">isExec()</span></code> will classify
these based on their typical usage. The methods below use heuristics to
classify ET_DYN object types correctly based on the properties of the
Elf Object, and will correctly classify most objects. Due to the
inherent ambiguity of ET_DYN object types, the heuristics may fail to
classify some libraries that are also executables as an executable. This
can happen in object is a shared library and an executable, and its
entry point happens to be at the start of the .text section.</p>
<p><code class="docutils literal notranslate"><span class="pre">isExecutable()</span></code> is equivalent to elfutils’ <code class="docutils literal notranslate"><span class="pre">elfclassify</span> <span class="pre">--program</span></code>
test with the refinement of the soname value and entry point tests.
Pseudocode for the algorithm is shown below:</p>
<ul class="simple">
<li><strong>if</strong> (<strong>not</strong> loadable()) <strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (object type is ET_EXEC) <strong>return</strong> <em>true</em></li>
<li><strong>if</strong> (has an interpreter (PT_INTERP segment exists)) <strong>return</strong>
<em>true</em></li>
<li><strong>if</strong> (PIE flag is set in FLAGS_1 of the PT_DYNAMIC segment)
<strong>return</strong> <em>true</em></li>
<li><strong>if</strong> (DT_DEBUG tag exists in PT_DYNAMIC segment) <strong>return</strong> <em>true</em></li>
<li><strong>if</strong> (has a soname and its value is “linux-gate.so.1”) <strong>return</strong>
<em>false</em></li>
<li><strong>if</strong> (entry point is in range .text section offset plus 1 to the
end of the .text section) <strong>return</strong> <em>true</em></li>
<li><strong>if</strong> (has a soname and its value starts with “ld-linux”) <strong>return</strong>
<em>true</em></li>
<li><strong>otherwise return</strong> <em>false</em></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">isSharedLibrary()</span></code> is equivalent to elfutils’
<code class="docutils literal notranslate"><span class="pre">elfclassify</span> <span class="pre">--library</span></code>. Pseudocode for the algorithm is shown below:</p>
<ul class="simple">
<li><strong>if</strong> (<strong>not</strong> loadable()) <strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (object type is ET_EXEC) <strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (there is no PT_DYNAMIC segment) <strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (PIE flag is set in FLAGS_1 of the PT_DYNAMIC segment)
<strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (DT_DEBUG tag exists in PT_DYNAMIC segment) <strong>return</strong> <em>false</em></li>
<li><strong>otherwise return</strong> <em>true</em></li>
</ul>
<p>Elf files can also store data that is neither an executable nor a shared
library including object files, core files and debug symbol files. To
distinguish these cases the <code class="docutils literal notranslate"><span class="pre">loadable()</span></code> function is defined using the
pseudocode shown below and returns true is the file can loaded into a
process’s address space:</p>
<ul class="simple">
<li><strong>if</strong> (object type is neither ET_EXEC nor ET_DYN) <strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (there is are no program segments with the PT_LOAD flag set)
<strong>return</strong> <em>false</em></li>
<li><strong>if</strong> (contains no sections) <strong>return</strong> <em>true</em></li>
<li><strong>if</strong> (contains a section with the SHF_ALLOC flag set and a section
type of neither SHT_NOTE nor SHT_NOBITS) <strong>return</strong> <em>true</em></li>
<li><strong>otherwise return</strong> <em>false</em></li>
</ul>
<div class="section" id="file-opening-parsing">
<h3>File opening/parsing<a class="headerlink" href="#file-opening-parsing" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">openFile</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Creates a new <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object for an object file on disk. This object
serves as a handle to the parsed object file. <code class="docutils literal notranslate"><span class="pre">filename</span></code> represents
the name of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> file to be parsed. The <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object is
returned in <code class="docutils literal notranslate"><span class="pre">obj</span></code> if the parsing succeeds. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the
file is parsed without an error, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.
<code class="docutils literal notranslate"><span class="pre">getLastSymtabError()</span></code> and <code class="docutils literal notranslate"><span class="pre">printError()</span></code> should be called to get
more error details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">openFile</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">mem_image</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object for an object file
in memory. This object serves as a handle to the parsed object file.
<code class="docutils literal notranslate"><span class="pre">mem_image</span></code> represents the pointer to the <code class="docutils literal notranslate"><span class="pre">Object</span></code> file in memory to
be parsed. <code class="docutils literal notranslate"><span class="pre">size</span></code> indicates the size of the image. <code class="docutils literal notranslate"><span class="pre">name</span></code> specifies
the name we will give to the parsed object. The <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object is
returned in <code class="docutils literal notranslate"><span class="pre">obj</span></code> if the parsing succeeds. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the
file is parsed without an error, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.
<code class="docutils literal notranslate"><span class="pre">getLastSymtabError()</span></code> and <code class="docutils literal notranslate"><span class="pre">printError()</span></code> should be called to get
more error details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">findOpenSymtab</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find a previously opened <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> that matches the provided name.</p>
</div>
<div class="section" id="module-lookup">
<h3>Module lookup<a class="headerlink" href="#module-lookup" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">getDefaultModule</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the default module, a collection of all functions, variables,
and symbols that do not have an explicit module specified.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findModuleByName</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method searches for a module with name <code class="docutils literal notranslate"><span class="pre">name</span></code>. If the module
exists returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> set to the module handle; otherwise
returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findModuleByOffset</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method searches for a module that starts at offset <code class="docutils literal notranslate"><span class="pre">offset</span></code>. If
the module exists returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> set to the module
handle; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllModules</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">module</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all modules in the object file. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on
success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no modules. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Module</span></code>.</p>
</div>
<div class="section" id="function-variable-and-symbol-lookup">
<h3>Function, Variable, and Symbol lookup<a class="headerlink" href="#function-variable-and-symbol-lookup" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findFuncByEntryOffset</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the <code class="docutils literal notranslate"><span class="pre">Function</span></code> object that begins at <code class="docutils literal notranslate"><span class="pre">offset</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there is no matching
function. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findFunctionsByName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">NameType</span><span class="w"> </span><span class="n">nameType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anyName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRegex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">checkCase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds and returns a vector of <code class="docutils literal notranslate"><span class="pre">Function</span></code>s whose names
match the given pattern. The <code class="docutils literal notranslate"><span class="pre">nameType</span></code> parameter determines which
names are searched: mangled, pretty, typed, or any. If the <code class="docutils literal notranslate"><span class="pre">isRegex</span></code>
flag is set a regular expression match is performed with the symbol
names. <code class="docutils literal notranslate"><span class="pre">checkCase</span></code> is applicable only if <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> has been set.
This indicates if the case be considered while performing regular
expression matching. <code class="docutils literal notranslate"><span class="pre">ret</span></code> contains the list of matching Functions, if
any. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it finds functions that match the given name,
otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getContainingFunction</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the function, if any, that contains the provided
<code class="docutils literal notranslate"><span class="pre">offset</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure. The
error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>. Note that this method does
not parse, and therefore relies on the symbol table for information. As
a result it may return incorrect information if the symbol table is
wrong or if functions are either non-contiguous or overlapping. For more
precision, use the ParseAPI library.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllFunctions</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all functions in the object file. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no modules. The error value is set
to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariablesByOffset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Variable</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a vector of <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s with the specified
offset. There may be more than one variable at an offset if they have
different sizes. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there is
no matching variable. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariablesByName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Variable</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">NameType</span><span class="w"> </span><span class="n">nameType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anyName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRegex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">checkCase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds and returns a vector of <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s whose names
match the given pattern. The <code class="docutils literal notranslate"><span class="pre">nameType</span></code> parameter determines which
names are searched: mangled, pretty, typed, or any (note: a <code class="docutils literal notranslate"><span class="pre">Variable</span></code>
may not have a typed name). If the <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> flag is set a regular
expression match is performed with the symbol names. <code class="docutils literal notranslate"><span class="pre">checkCase</span></code> is
applicable only if <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> has been set. This indicates if the case
be considered while performing regular expression matching. <code class="docutils literal notranslate"><span class="pre">ret</span></code>
contains the list of matching <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s, if any. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
if it finds variables that match the given name, otherwise returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllVariables</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Variable</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all variables in the object file. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no modules. The error value is set
to <code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findSymbol</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">::</span><span class="n">SymbolType</span><span class="w"> </span><span class="n">sType</span><span class="p">,</span><span class="w"> </span><span class="n">NameType</span><span class="w"> </span><span class="n">nameType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anyName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRegex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">checkCase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds and returns a vector of symbols with type <code class="docutils literal notranslate"><span class="pre">sType</span></code>
whose names match the given name. The <code class="docutils literal notranslate"><span class="pre">nameType</span></code> parameter determines
which names are searched: mangled, pretty, typed, or any. If the
<code class="docutils literal notranslate"><span class="pre">isRegex</span></code> flag is set a regular expression match is performed with the
symbol names. <code class="docutils literal notranslate"><span class="pre">checkCase</span></code> is applicable only if <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> has been
set. This indicates if the case be considered while performing regular
expression matching. <code class="docutils literal notranslate"><span class="pre">ret</span></code> contains the list of matched symbols if
any. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it finds symbols with the given attributes. or
else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. The error value is set <code class="docutils literal notranslate"><span class="pre">to</span> <span class="pre">No_Such_Function</span></code> /
<code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>/ <code class="docutils literal notranslate"><span class="pre">No_Such_Module</span></code>/ <code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code> based on
the type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">findSymbolByOffset</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Return a pointer to a vector of <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>s with the specified offset.
The pointer belongs to <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> and should not be modified or freed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllSymbols</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all symbols. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and
<code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no symbols. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllSymbolsByType</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">::</span><span class="n">SymbolType</span><span class="w"> </span><span class="n">sType</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all symbols whose type matches the given type
<code class="docutils literal notranslate"><span class="pre">sType</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no
symbols with the given type. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllUndefinedSymbols</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all symbols that reference symbols in other files
(e.g., external functions or variables). Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is at
least one such symbol or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with the error set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code>.</p>
</div>
<div class="section" id="region-lookup">
<h3>Region lookup<a class="headerlink" href="#region-lookup" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getCodeRegions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Region</span><span class="w"> </span><span class="o">*&gt;&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds all the code regions in the object file. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> containing the code regions if there is at least
one code region in the object file or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getDataRegions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Region</span><span class="w"> </span><span class="o">*&gt;&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds all the data regions in the object file. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> containing the data regions if there is at least
one data region in the object file or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getMappedRegions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Region</span><span class="w"> </span><span class="o">*&gt;&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds all the loadable regions in the object file. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> containing the loadable regions if there is at
least one loadable region in the object file or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllRegions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Region</span><span class="w"> </span><span class="o">*&gt;&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves all the regions in the object file. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> containing the regions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllNewRegions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Region</span><span class="w"> </span><span class="o">*&gt;&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds all the new regions added to the object file. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">ret</span></code> containing the regions if there is at least one
new region that is added to the object file or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findRegion</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">sname</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find a region (ELF section) wih name <code class="docutils literal notranslate"><span class="pre">sname</span></code> in the binary. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if found, with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to the region pointer. Otherwise
returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findRegion</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find a region (ELF section) with a memory offset of <code class="docutils literal notranslate"><span class="pre">addr</span></code> and memory
size of <code class="docutils literal notranslate"><span class="pre">size</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if found, with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to the
region pointer. Otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findRegionByEntry</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">soff</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find a region (ELF section) with a memory offset of <code class="docutils literal notranslate"><span class="pre">addr</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if found, with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to the region pointer. Otherwise
returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">reg</span></code> set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">findEnclosingRegion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find the region (ELF section) whose virtual address range contains
<code class="docutils literal notranslate"><span class="pre">offset</span></code>. Returns the region if found; otherwise returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<div class="section" id="insertion-and-modification">
<h3>Insertion and modification<a class="headerlink" href="#insertion-and-modification" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">emit</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Creates a new file using the specified name that contains all changes
made by the user.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addLibraryPrereq</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">lib</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Add a library dependence to the file such that when the file is loaded,
the library will be loaded as well. Cannot be used for static binaries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">createFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method creates a <code class="docutils literal notranslate"><span class="pre">Function</span></code> and updates all necessary data
structures (including creating Symbols, if necessary). The function has
the provided mangled name, offset, and size, and is added to the Module
<code class="docutils literal notranslate"><span class="pre">mod</span></code>. Symbols representing the function are added to the static and
dynamic symbol tables. Returns the pointer to the new <code class="docutils literal notranslate"><span class="pre">Function</span></code> on
success or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Variable</span><span class="w"> </span><span class="o">*</span><span class="n">createVariable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method creates a <code class="docutils literal notranslate"><span class="pre">Variable</span></code> and updates all necessary data
structures (including creating Symbols, if necessary). The variable has
the provided mangled name, offset, and size, and is added to the Module
<code class="docutils literal notranslate"><span class="pre">mod</span></code>. Symbols representing the variable are added to the static and
dynamic symbol tables. Returns the pointer to the new <code class="docutils literal notranslate"><span class="pre">Variable</span></code> on
success or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">newsym</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new symbol <code class="docutils literal notranslate"><span class="pre">newsym</span></code> to all of the internal data
structures. The primary name of the <code class="docutils literal notranslate"><span class="pre">newsym</span></code> must be a mangled name.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure. A new copy of
<code class="docutils literal notranslate"><span class="pre">newsym</span></code> is not made. <code class="docutils literal notranslate"><span class="pre">newsym</span></code> must not be deallocated after adding
it to symtabAPI. We suggest using <code class="docutils literal notranslate"><span class="pre">createFunction</span></code> or
<code class="docutils literal notranslate"><span class="pre">createVariable</span></code> when possible.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">newsym</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">referringSymbol</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new dynamic symbol <code class="docutils literal notranslate"><span class="pre">newsym</span></code> which refers to
<code class="docutils literal notranslate"><span class="pre">referringSymbol</span></code> to all of the internal data structures. <code class="docutils literal notranslate"><span class="pre">newsym</span></code>
must represent a dynamic symbol. The primary name of the newsym must be
a mangled name. All the required version names are allocated
automatically. Also if the <code class="docutils literal notranslate"><span class="pre">referringSymbol</span></code> belongs to a shared
library which is not currently a dependency, the shared library is added
to the list of dependencies implicitly. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and
<code class="docutils literal notranslate"><span class="pre">false</span></code> on failure. A new copy of <code class="docutils literal notranslate"><span class="pre">newsym</span></code> is not made. <code class="docutils literal notranslate"><span class="pre">newsym</span></code>
must not be deallocated after adding it to symtabAPI.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">deleteFunction</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">func</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method deletes the <code class="docutils literal notranslate"><span class="pre">Function</span></code> <code class="docutils literal notranslate"><span class="pre">func</span></code> from all of symtab’s data
structures. It will not be available for further queries. Return
<code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">func</span></code> is not owned by the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">deleteVariable</span><span class="p">(</span><span class="n">Variable</span><span class="w"> </span><span class="o">*</span><span class="n">var</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method deletes the variable <code class="docutils literal notranslate"><span class="pre">var</span></code> from all of symtab’s data
structures. It will not be available for further queries. Return
<code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">var</span></code> is not owned by the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">deleteSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">sym</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method deletes the symbol <code class="docutils literal notranslate"><span class="pre">sym</span></code> from all of symtab’s data
structures. It will not be available for further queries. Return
<code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if func is not owned by the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addRegion</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="o">::</span><span class="n">RegionType</span><span class="w"> </span><span class="n">rType_</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">loadable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">memAlign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">),</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">tls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Creates a new region using the specified parameters and adds it to the
file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Offset</span><span class="w"> </span><span class="n">getFreeOffset</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Find a contiguous region of unused space within the file (which may be
at the end of the file) of the specified size and return an offset to
the start of the region. Useful for allocating new regions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">addRegion</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">newreg</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Adds the provided region to the file.</p>
</div>
<div class="section" id="catch-and-exception-block-lookup">
<h3>Catch and Exception block lookup<a class="headerlink" href="#catch-and-exception-block-lookup" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllExceptions</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExceptionBlock</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exceptions</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves all the exception blocks in the <code class="docutils literal notranslate"><span class="pre">Object</span></code> file.
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no exception blocks else returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
with exceptions containing a vector of <code class="docutils literal notranslate"><span class="pre">ExceptionBlock</span></code>s.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findException</span><span class="p">(</span><span class="n">ExceptionBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">excp</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the exception block in the binary at the offset
<code class="docutils literal notranslate"><span class="pre">addr</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if there is no exception block at the given
offset else returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">excp</span></code> containing the exception
block.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findCatchBlock</span><span class="p">(</span><span class="n">ExceptionBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">excp</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the address range <code class="docutils literal notranslate"><span class="pre">[addr,</span> <span class="pre">addr+size]</span></code>
contains a catch block, with <code class="docutils literal notranslate"><span class="pre">excp</span></code> pointing to the appropriate block,
else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="symtab-information">
<h3>Symtab information<a class="headerlink" href="#symtab-information" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">obj_Unknown</span><span class="p">,</span><span class="w"> </span><span class="n">obj_SharedLib</span><span class="p">,</span><span class="w"> </span><span class="n">obj_Executable</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">_RelocatableFile</span><span class="p">,</span><span class="w"> </span><span class="n">ObjectType</span><span class="p">;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isCode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">where</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method checks if the given offset <code class="docutils literal notranslate"><span class="pre">where</span></code> belongs to the text
section. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if that is the case or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">where</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method checks if the given offset <code class="docutils literal notranslate"><span class="pre">where</span></code> belongs to the data
section. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if that is the case or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isValidOffset</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">where</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method checks if the given offset <code class="docutils literal notranslate"><span class="pre">where</span></code> is valid. For an offset
to be valid it should be aligned and it should be a valid code offset or
a valid data offset. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds or else returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="line-number-information">
<h3>Line number information<a class="headerlink" href="#line-number-information" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAddressRanges</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">LineNo</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the address ranges in <code class="docutils literal notranslate"><span class="pre">ranges</span></code> corresponding to
the line with line number <code class="docutils literal notranslate"><span class="pre">lineNo</span></code> in the source file <code class="docutils literal notranslate"><span class="pre">lineSource</span></code>.
Searches all modules for the given source. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at least
one address range corresponding to the line number was found and returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> if none found.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSourceLines</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LineNoTuple</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lines</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">addressInRange</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the source file names and line numbers corresponding
to the given address <code class="docutils literal notranslate"><span class="pre">addressInRange</span></code>. Searches all modules for the
given source. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one tuple corresponding to the
offset was found and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if none found.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addLine</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineNo</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineOffset</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">lowInclusiveAddr</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">highExclusiveAddr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new line to the line map. <code class="docutils literal notranslate"><span class="pre">lineSource</span></code> represents
the source file name. <code class="docutils literal notranslate"><span class="pre">lineNo</span></code> represents the line number. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">addAddressRange</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">lowInclusiveAddr</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">highExclusiveAddr</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineNo</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds an address range
<code class="docutils literal notranslate"><span class="pre">[lowInclusiveAddr,</span> <span class="pre">highExclusiveAddr)</span></code> for the line with line number
<code class="docutils literal notranslate"><span class="pre">lineNo</span></code> in source file <code class="docutils literal notranslate"><span class="pre">lineSource</span></code> at offset <code class="docutils literal notranslate"><span class="pre">lineOffset</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on error.</p>
</div>
<div class="section" id="type-information">
<h3>Type information<a class="headerlink" href="#type-information" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">parseTypesNow</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Forces SymtabAPI to perform type parsing instead of delaying it to when
needed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Performs a look up among all the built-in types, standard types and
user-defined types and returns a handle to the found type with name
<code class="docutils literal notranslate"><span class="pre">name</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a type is found with type containing the
handle to the type, else return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Adds a new type <code class="docutils literal notranslate"><span class="pre">type</span></code> to symtabAPI. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">getAllstdTypes</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Returns all the standard types that normally occur in a program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">getAllbuiltInTypes</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Returns all the built-in types defined in the binary.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findLocalVariable</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The method returns a list of local variables named name within the
object file. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with <code class="docutils literal notranslate"><span class="pre">vars</span></code> containing a list of
<code class="docutils literal notranslate"><span class="pre">localVar</span></code> objects corresponding to the local variables if found or
else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariableType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method looks up a global variable with name <code class="docutils literal notranslate"><span class="pre">name</span></code> and returns
its type attribute. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a variable is found or returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> with type set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">SymtabError</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SymtabError</span></code> can take one of the following values.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymtabError enum</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Obj_Parsing</td>
<td>An error occurred during object
parsing(internal error).</td>
</tr>
<tr class="row-odd"><td>Syms_To_Functions</td>
<td>An error occurred in converting symbols
to functions(internal error).</td>
</tr>
<tr class="row-even"><td>Build_Function_Lists</td>
<td>An error occurred while building function
lists(internal error).</td>
</tr>
<tr class="row-odd"><td>No_Such_Function</td>
<td>No matching function exists with the
given inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Variable</td>
<td>No matching variable exists with the
given inputs.</td>
</tr>
<tr class="row-odd"><td>No_Such_Module</td>
<td>No matching module exists with the given
inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Symbol</td>
<td>No matching symbol exists with the given
inputs.</td>
</tr>
<tr class="row-odd"><td>No_Such_Region</td>
<td>No matching region exists with the given
inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Member</td>
<td>No matching member exists in the archive
with the given inputs.</td>
</tr>
<tr class="row-odd"><td>Not_A_File</td>
<td>Binary to be parsed may be an archive and
not a file.</td>
</tr>
<tr class="row-even"><td>Not_An_Archive</td>
<td>Binary to be parsed is not an archive.</td>
</tr>
<tr class="row-odd"><td>Duplicate_Symbol</td>
<td>Duplicate symbol found in symbol table.</td>
</tr>
<tr class="row-even"><td>Export_Error</td>
<td>Error occurred during export of modified
symbol table.</td>
</tr>
<tr class="row-odd"><td>Emit_Error</td>
<td>Error occurred during generation of
modified binary.</td>
</tr>
<tr class="row-even"><td>Invalid_Flags</td>
<td>Flags passed are invalid.</td>
</tr>
<tr class="row-odd"><td>Bad_Frame_Data</td>
<td>Stack walking DWARF information has bad
frame data.</td>
</tr>
<tr class="row-even"><td>No_Frame_Entry</td>
<td>No stack walking frame data found in
debug information for this location.</td>
</tr>
<tr class="row-odd"><td>Frame_Read_Error</td>
<td>Failed to read stack frame data.</td>
</tr>
<tr class="row-even"><td>Multiple_Region_Matches</td>
<td>Multiple regions match the provided data.</td>
</tr>
<tr class="row-odd"><td>No_Error</td>
<td>Previous operation did not result in
failure.</td>
</tr>
</tbody>
</table>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">SymtabError</span><span class="w"> </span><span class="n">getLastSymtabError</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns an error value for the previously performed
operation that resulted in a failure. SymtabAPI sets a global error
value in case of error during any operation. This call returns the last
error that occurred while performing any operation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">printError</span><span class="p">(</span><span class="n">SymtabError</span><span class="w"> </span><span class="n">serr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a detailed description of the enum value serr in
human readable format.</p>
</div>
</div>
<div class="section" id="class-module">
<span id="module"></span><h2>Class Module<a class="headerlink" href="#class-module" title="Permalink to this headline"></a></h2>
<p>This class represents the concept of a single source file. Currently,
Modules are only identified for the executable file; each shared library
is made up of a single Module, ignoring any source file information that
may be present. We also create a single module, called
<code class="docutils literal notranslate"><span class="pre">DEFAULT_MODULE</span></code>, for each Symtab that contains any symbols for which
module information was unavailable. This may be compiler template code,
or files produced without module information.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">supportedLanguages</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lang_Unknown</td>
<td>Unknown source language</td>
</tr>
<tr class="row-odd"><td>lang_Assembly</td>
<td>Raw assembly code</td>
</tr>
<tr class="row-even"><td>lang_C</td>
<td>C source code</td>
</tr>
<tr class="row-odd"><td>lang_CPlusPlus</td>
<td>C++ source code</td>
</tr>
<tr class="row-even"><td>lang_GnuCPlusPlus</td>
<td>C++ with GNU extensions</td>
</tr>
<tr class="row-odd"><td>lang_Fortran</td>
<td>Fortran source code</td>
</tr>
<tr class="row-even"><td>lang_Fortran_with_pretty_debug</td>
<td>Fortran with debug annotations</td>
</tr>
<tr class="row-odd"><td>lang_CMFortran</td>
<td>Fortran with CM extensions</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>isShared</td>
<td>bool</td>
<td>True if the module is for a shared library, false for an executable.</td>
</tr>
<tr class="row-odd"><td>fullName</td>
<td>std::string &amp;</td>
<td>Name, including path, of the source file represented by the module.</td>
</tr>
<tr class="row-even"><td>fileName</td>
<td>std::string &amp;</td>
<td>Name, not including path, of the source file represented by the module.</td>
</tr>
<tr class="row-odd"><td>language</td>
<td>supportedLanguages</td>
<td>The source language used by the Module.</td>
</tr>
<tr class="row-even"><td>addr</td>
<td>Offset</td>
<td>Offset of the start of the module, as reported by the symbol table, assuming contiguous modules.</td>
</tr>
<tr class="row-odd"><td>exec</td>
<td>Symtab *</td>
<td>Symtab object that contains the module.</td>
</tr>
</tbody>
</table>
<div class="section" id="function-variable-symbol-lookup">
<h3>Function, Variable, Symbol lookup<a class="headerlink" href="#function-variable-symbol-lookup" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findFunctionByEntryOffset</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the <code class="docutils literal notranslate"><span class="pre">Function</span></code> object that begins at <code class="docutils literal notranslate"><span class="pre">offset</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there is no matching
function. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">mangledName</span><span class="p">,</span><span class="w"> </span><span class="n">prettyName</span><span class="p">,</span><span class="w"> </span><span class="n">typedName</span><span class="p">,</span><span class="w"> </span><span class="n">anyName</span><span class="w"> </span><span class="n">NameType</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">findFunctionsByName</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="o">::</span><span class="n">NameType</span><span class="w"> </span><span class="n">nameType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anyName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRegex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">checkCase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds and returns a vector of <code class="docutils literal notranslate"><span class="pre">Functions</span></code> whose names
match the given pattern. The <code class="docutils literal notranslate"><span class="pre">nameType</span></code> parameter determines which
names are searched: mangled, pretty, typed, or any. If the <code class="docutils literal notranslate"><span class="pre">isRegex</span></code>
flag is set a regular expression match is performed with the symbol
names. <code class="docutils literal notranslate"><span class="pre">checkCase</span></code> is applicable only if <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> has been set.
This indicates if the case be considered while performing regular
expression matching. <code class="docutils literal notranslate"><span class="pre">ret</span></code> contains the list of matching
<code class="docutils literal notranslate"><span class="pre">Function</span></code>s, if any. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it finds functions that
match the given name, otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. The error value is
set to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllFunctions</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all functions in the object file. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no modules. The error value is set
to <code class="docutils literal notranslate"><span class="pre">No_Such_Function</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariablesByOffset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Variable</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a vector of <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s with the specified
offset. There may be more than one variable at an offset if they have
different sizes. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there is
no matching variable. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariablesByName</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="o">::</span><span class="n">NameType</span><span class="w"> </span><span class="n">nameType</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isRegex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">checkCase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method finds and returns a vector of <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s whose names
match the given pattern. The <code class="docutils literal notranslate"><span class="pre">nameType</span></code> parameter determines which
names are searched: mangled, pretty, typed, or any (note: a <code class="docutils literal notranslate"><span class="pre">Variable</span></code>
may not have a typed name). If the <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> flag is set a regular
expression match is performed with the symbol names. <code class="docutils literal notranslate"><span class="pre">checkCase</span></code> is
applicable only if <code class="docutils literal notranslate"><span class="pre">isRegex</span></code> has been set. This indicates if the case
be considered while performing regular expression matching. <code class="docutils literal notranslate"><span class="pre">ret</span></code>
contains the list of matching <code class="docutils literal notranslate"><span class="pre">Variables</span></code>, if any. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if
it finds variables that match the given name, otherwise returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>. The error value is set to <code class="docutils literal notranslate"><span class="pre">No_Such_Variable</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllSymbols</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all symbols. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and
<code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no symbols. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllSymbolsByType</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">::</span><span class="n">SymbolType</span><span class="w"> </span><span class="n">sType</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all symbols whose type matches the given type
<code class="docutils literal notranslate"><span class="pre">sType</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> if there are no
symbols with the given type. The error value is set to
<code class="docutils literal notranslate"><span class="pre">No_Such_Symbol</span></code>.</p>
</div>
<div class="section" id="line-number-information-for-symtab">
<span id="line-number-information-1"></span><h3>Line number information for Symtab<a class="headerlink" href="#line-number-information-for-symtab" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAddressRanges</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineNo</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the address ranges in <code class="docutils literal notranslate"><span class="pre">ranges</span></code> corresponding to
the line with line number <code class="docutils literal notranslate"><span class="pre">lineNo</span></code> in the source file <code class="docutils literal notranslate"><span class="pre">lineSource</span></code>.
Searches only this module for the given source. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at
least one address range corresponding to the line number was found and
returns false if none found.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSourceLines</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Statement</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lines</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">addressInRange</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the source file names and line numbers corresponding
to the given address <code class="docutils literal notranslate"><span class="pre">addressInRange</span></code>. Searches only this module for
the given source. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one tuple corresponding to
the offset was found and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if none found. The
<code class="docutils literal notranslate"><span class="pre">Statement</span></code> class used to be named <code class="docutils literal notranslate"><span class="pre">LineNoTuple</span></code>; backwards
compatibility is provided via typedef.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LineInformation</span><span class="w"> </span><span class="o">*</span><span class="n">getLineInformation</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the line map (section <a class="reference external" href="#LineInformation">7.1</a>)
corresponding to the module. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no line
information existing for the module.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getStatements</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Statement</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">statements</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Returns all line information (section <a class="reference external" href="#Statement">7.2</a>) available
for the module.</p>
</div>
<div class="section" id="type-information-symtab">
<span id="subsubsec-typeinfo"></span><h3>Type information Symtab<a class="headerlink" href="#type-information-symtab" title="Permalink to this headline"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method performs a look up and returns a handle to the named
<code class="docutils literal notranslate"><span class="pre">type</span></code>. This method searches all the built-in types, standard types
and user-defined types within the module. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a type is
found with type containing the handle to the type, else return
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findLocalVariable</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The method returns a list of local variables within the module with name
<code class="docutils literal notranslate"><span class="pre">name</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with vars containing a list of <code class="docutils literal notranslate"><span class="pre">localVar</span></code>
objects corresponding to the local variables if found or else returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findVariableType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method looks up a global variable with name <code class="docutils literal notranslate"><span class="pre">name</span></code> and returns
its type attribute. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a variable is found or returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> with <code class="docutils literal notranslate"><span class="pre">type</span></code> set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
</div>
<div class="section" id="class-functionbase">
<span id="functionbase"></span><h2>Class FunctionBase<a class="headerlink" href="#class-functionbase" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">FunctionBase</span></code> class provides a common interface that can
represent either a regular function or an inlined function.</p>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">FunctionBase Class</span><a class="headerlink" href="#id2" title="Permalink to this table"></a></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getModule</td>
<td>const Module *</td>
<td>Module this function belongs to.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>Size encoded in the symbol table; may not be actual function size.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>Region containing this function.</td>
</tr>
<tr class="row-odd"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing the return type of the function.</td>
</tr>
<tr class="row-even"><td>getName</td>
<td>std::string</td>
<td>Returns primary name of the function (first mangled name or DWARF name).</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setModule</span><span class="w"> </span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function changes the module to which the function belongs to
<code class="docutils literal notranslate"><span class="pre">module</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setSize</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function changes the size of the function to <code class="docutils literal notranslate"><span class="pre">size</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setOffset</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The method changes the offset of the function to <code class="docutils literal notranslate"><span class="pre">offset</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addMangledName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a mangled name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
function. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addPrettyName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a pretty name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
function. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addTypedName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a typed name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If <code class="docutils literal notranslate"><span class="pre">isPrimary</span></code>
is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the function. This
method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getLocalVariables</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the local variables in the function. <code class="docutils literal notranslate"><span class="pre">vars</span></code>
contains the list of variables found. If there is no debugging
information present then it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with the error code set to
<code class="docutils literal notranslate"><span class="pre">NO_DEBUG_INFO</span></code> accordingly. Otherwise it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VariableLocation</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getFramePtr</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a list of frame pointer offsets (abstract top of the
stack) for the function. See the <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> class description
for more information.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getParams</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the parameters to the function. <code class="docutils literal notranslate"><span class="pre">params</span></code> contains
the list of parameters. If there is no debugging information present
then it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with the error code set to <code class="docutils literal notranslate"><span class="pre">NO_DEBUG_INFO</span></code>
accordingly. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findLocalVariable</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a list of local variables within a function that
have name <code class="docutils literal notranslate"><span class="pre">name</span></code>. <code class="docutils literal notranslate"><span class="pre">vars</span></code> contains the list of variables found.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setReturnType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Sets the return type of a function to <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">FunctionBase</span><span class="o">*</span><span class="w"> </span><span class="n">getInlinedParent</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Gets the function that this function is inlined into, if any. Returns
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no parent.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">InlineCollection</span><span class="o">&amp;</span><span class="w"> </span><span class="n">getInlines</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Gets the set of functions inlined into this one (possibly empty).</p>
</div>
<div class="section" id="symbtab-class-function">
<span id="function"></span><h2>Symbtab Class Function<a class="headerlink" href="#symbtab-class-function" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class represents a collection of symbols that have the
same address and a type of <code class="docutils literal notranslate"><span class="pre">ST_FUNCTION</span></code>. When appropriate, use this
representation instead of the underlying <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> objects.</p>
<table border="1" class="docutils" id="id3">
<caption><span class="caption-text">Class Function</span><a class="headerlink" href="#id3" title="Permalink to this table"></a></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getModule</td>
<td>const Module *</td>
<td>Module this function belongs to.</td>
</tr>
<tr class="row-odd"><td>getOffset</td>
<td>Offset</td>
<td>Offset in the file associated with the function.</td>
</tr>
<tr class="row-even"><td>getSize</td>
<td>unsigned</td>
<td>Size encoded in the symbol table; may not be actual function size.</td>
</tr>
<tr class="row-odd"><td>mangled_names_begin</td>
<td>Aggregate::name_iter</td>
<td>Beginning of a range of unique names of symbols pointing to this function.</td>
</tr>
<tr class="row-even"><td>mangled_names_end</td>
<td>Aggregate::name_iter</td>
<td>End of a range of symbols pointing to this function.</td>
</tr>
<tr class="row-odd"><td>pretty_names_begin</td>
<td>Aggregate::name_iter</td>
<td>As above, but prettified with the demangler.</td>
</tr>
<tr class="row-even"><td>pretty_names_end</td>
<td>Aggregate::name_iter</td>
<td>As above, but prettified with the demangler.</td>
</tr>
<tr class="row-odd"><td>typed_names_begin</td>
<td>Aggregate::name_iter</td>
<td>As above, but including full type strings.</td>
</tr>
<tr class="row-even"><td>typed_names_end</td>
<td>Aggregate::name_iter</td>
<td>As above, but including full type strings.</td>
</tr>
<tr class="row-odd"><td>getRegion</td>
<td>Region *</td>
<td>Region containing this function</td>
</tr>
<tr class="row-even"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing the return type of the function.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSymbols</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">syms</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the vector of <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>s that refer to the
function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setModule</span><span class="w"> </span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function changes the module to which the function belongs to
<code class="docutils literal notranslate"><span class="pre">module</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setSize</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function changes the size of the function to <code class="docutils literal notranslate"><span class="pre">size</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setOffset</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The method changes the offset of the function to <code class="docutils literal notranslate"><span class="pre">offset</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addMangledName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a mangled name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
function. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addPrettyName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a pretty name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
function. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addTypedName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a typed name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the function. If <code class="docutils literal notranslate"><span class="pre">isPrimary</span></code>
is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the function. This
method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getLocalVariables</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the local variables in the function. <code class="docutils literal notranslate"><span class="pre">vars</span></code>
contains the list of variables found. If there is no debugging
information present then it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with the error code set to
<code class="docutils literal notranslate"><span class="pre">NO_DEBUG_INFO</span></code> accordingly. Otherwise it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VariableLocation</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getFramePtr</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a list of frame pointer offsets (abstract top of the
stack) for the function. See the <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> class description
for more information.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getParams</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the parameters to the function. <code class="docutils literal notranslate"><span class="pre">params</span></code> contains
the list of parameters. If there is no debugging information present
then it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> with the error code set to <code class="docutils literal notranslate"><span class="pre">NO_DEBUG_INFO</span></code>
accordingly. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findLocalVariable</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">localVar</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a list of local variables within a function that
have name <code class="docutils literal notranslate"><span class="pre">name</span></code>. <code class="docutils literal notranslate"><span class="pre">vars</span></code> contains the list of variables found.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setReturnType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Sets the return type of a function to <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
</div>
<div class="section" id="class-inlinedfunction">
<span id="inlinedfunction"></span><h2>Class InlinedFunction<a class="headerlink" href="#class-inlinedfunction" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">InlinedFunction</span></code> class represents an inlined function, as found
in DWARF information. Its interface is almost entirely inherited from
<code class="docutils literal notranslate"><span class="pre">FunctionBase</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Dyninst</span><span class="o">::</span><span class="n">Offset</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getCallsite</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the file and line corresponding to the call site of an inlined
function.</p>
</div>
<div class="section" id="class-variable">
<h2>Class Variable<a class="headerlink" href="#class-variable" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Variable</span></code> class represents a collection of symbols that have the
same address and represent data.</p>
<table border="1" class="docutils" id="id4">
<caption><span class="caption-text">Variable Class</span><a class="headerlink" href="#id4" title="Permalink to this table"></a></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getOffset</td>
<td>Offset</td>
<td>Offset associated with this variable.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>Size of this variable encoded in the symbol table.</td>
</tr>
<tr class="row-even"><td>mangled_names_begin</td>
<td>Aggregate::name_iter</td>
<td>Beginning of a range of unique names of symbols pointing to this variable.</td>
</tr>
<tr class="row-odd"><td>mangled_names_end</td>
<td>Aggregate::name_iter</td>
<td>End of a range of unique names of symbols pointing to this variable.</td>
</tr>
<tr class="row-even"><td>getType</td>
<td>Type *</td>
<td>Type of this variable, if known.</td>
</tr>
<tr class="row-odd"><td>getModule</td>
<td>const Module *</td>
<td>Module this variable belongs to.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>Region that contains this variable.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSymbols</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">syms</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the vector of <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>s that refer to the
variable.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setModule</span><span class="w"> </span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method changes the module to which the variable belongs. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setSize</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method changes the size of the variable to <code class="docutils literal notranslate"><span class="pre">size</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setOffset</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The method changes the offset of the variable. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it
succeeds.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addMangledName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a mangled name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the variable. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
variable. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addPrettyName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a pretty name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the variable. If
<code class="docutils literal notranslate"><span class="pre">isPrimary</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the
variable. This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on
failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addTypedName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPrimary</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a typed name <code class="docutils literal notranslate"><span class="pre">name</span></code> to the variable. If <code class="docutils literal notranslate"><span class="pre">isPrimary</span></code>
is <code class="docutils literal notranslate"><span class="pre">true</span></code> then it becomes the default name for the variable. This
method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Sets the type of the variable to <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
</div>
<div class="section" id="class-symbol">
<h2>Class Symbol<a class="headerlink" href="#class-symbol" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> class represents a symbol in the object file. This class
holds the symbol information such as the mangled, pretty and typed
names, the module in which it is present, type, linkage, offset and
size.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymbolType</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ST_UNKNOWN</td>
<td>Unknown type</td>
</tr>
<tr class="row-odd"><td>ST_FUNCTION</td>
<td>Function or other executable code sequence</td>
</tr>
<tr class="row-even"><td>ST_OBJECT</td>
<td>Variable or other data object</td>
</tr>
<tr class="row-odd"><td>ST_MODULE</td>
<td>Source file declaration</td>
</tr>
<tr class="row-even"><td>ST_SETION</td>
<td>Region declaration</td>
</tr>
<tr class="row-odd"><td>ST_TLS</td>
<td>Thread-local storage declaration</td>
</tr>
<tr class="row-even"><td>ST_DELETED</td>
<td>Deleted symbol</td>
</tr>
<tr class="row-odd"><td>ST_NOTYPE</td>
<td>Miscellaneous symbol</td>
</tr>
</tbody>
</table>
</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymbolLinkage</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SL_UNKNOWN</td>
<td>Unknown linkage</td>
</tr>
<tr class="row-odd"><td>SL_GLOBAL</td>
<td>Process-global symbol</td>
</tr>
<tr class="row-even"><td>SL_LOCAL</td>
<td>Process-local (e.g., static) symbol</td>
</tr>
<tr class="row-odd"><td>SL_WEAK</td>
<td>Alternate name for a function or variable</td>
</tr>
</tbody>
</table>
</div>
<p>The following two types are platform-specific:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">SV_UNKNOWN</span><span class="p">,</span><span class="w"> </span><span class="n">SV_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="n">SV_INTERNAL</span><span class="p">,</span><span class="w"> </span><span class="n">SV_HIDDEN</span><span class="p">,</span><span class="w"></span>
<span class="n">SV_PROTECTED</span><span class="w"> </span><span class="n">SymbolVisibility</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">TAG_UNKNOWN</span><span class="p">,</span><span class="w"> </span><span class="n">TAG_USER</span><span class="p">,</span><span class="w"> </span><span class="n">TAG_LIBRARY</span><span class="p">,</span><span class="w"> </span><span class="n">TAG_INTERNAL</span><span class="w"> </span><span class="n">SymbolTag</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getMangledName</td>
<td>string</td>
<td>Raw name of the symbol in the symbol table, including name mangling.</td>
</tr>
<tr class="row-odd"><td>getPrettyName</td>
<td>string</td>
<td>Demangled name of the symbol with parameters (for functions) removed.</td>
</tr>
<tr class="row-even"><td>getTypedName</td>
<td>string</td>
<td>Demangled name of the symbol including full function parameters.</td>
</tr>
<tr class="row-odd"><td>getModule</td>
<td>Module *</td>
<td>The module, if any, that contains the symbol.</td>
</tr>
<tr class="row-even"><td>getType</td>
<td>SymbolType</td>
<td>The symboltype (as defined above) of the symbol.</td>
</tr>
<tr class="row-odd"><td>getLinkage</td>
<td>SymbolLinkage</td>
<td>The linkage (as defined above) of the symbol.</td>
</tr>
<tr class="row-even"><td>getVisibility</td>
<td>SymbolVisibility</td>
<td>The visibility (as defined above) of the symbol.</td>
</tr>
<tr class="row-odd"><td>tag</td>
<td>SymbolTag</td>
<td>The tag (as defined above) of the symbol.</td>
</tr>
<tr class="row-even"><td>getOffset</td>
<td>Offset</td>
<td>The Offset of the object the symbol refers to.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>The size of the object the symbol refers to.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>The region containing the symbol.</td>
</tr>
<tr class="row-odd"><td>getIndex</td>
<td>int</td>
<td>The index of the symbol within the symbol table.</td>
</tr>
<tr class="row-even"><td>getStrIndex</td>
<td>int</td>
<td>The index of the symbol name in the string table.</td>
</tr>
<tr class="row-odd"><td>IsInDynSymtab</td>
<td>bool</td>
<td>If true, the symbol is dynamic and can be used as the target of an intermodule reference. Implies isInSymtab is false.</td>
</tr>
<tr class="row-even"><td>IsInSymtab</td>
<td>bool</td>
<td>If true, the symbol is static. Implies isInDynSymtab is false.</td>
</tr>
<tr class="row-odd"><td>IsAbsolute</td>
<td>bool</td>
<td>If true, the offset encoded in the symbol is an absolute value rather than offset.</td>
</tr>
<tr class="row-even"><td>IsFunction</td>
<td>bool</td>
<td>If true, the symbol refers to a function.</td>
</tr>
<tr class="row-odd"><td>GetFunction</td>
<td>Funcion *</td>
<td>The Function that contains this symbol if such a Function exists.</td>
</tr>
<tr class="row-even"><td>isVariable</td>
<td>bool</td>
<td>If true, the symbol refers to a variable.</td>
</tr>
<tr class="row-odd"><td>getVariable</td>
<td>Variable *</td>
<td>The Variable that contains the symbol if such a Variable exists.</td>
</tr>
<tr class="row-even"><td>getSymtab</td>
<td>Symtab *</td>
<td>The Symtab that contains the symbol.</td>
</tr>
<tr class="row-odd"><td>getPtrOffset</td>
<td>Offset</td>
<td>For binaries with an OPD section, the offset in the OPD that contains the function pointer data structure for this symbol.</td>
</tr>
<tr class="row-even"><td>getLocalTOC</td>
<td>Offset</td>
<td>For platforms with a TOC register, the expected TOC for this object referred to by this symbol.</td>
</tr>
<tr class="row-odd"><td>isCommonStorage</td>
<td>bool</td>
<td>True if the symbol represents a common section (Fortran).</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SYMTAB_EXPORT</span><span class="w"> </span><span class="n">Symbol</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">SymbolType</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"></span>
<span class="n">SymbolLinkage</span><span class="w"> </span><span class="n">linkage</span><span class="p">,</span><span class="w"> </span><span class="n">SymbolVisibility</span><span class="w"> </span><span class="n">visibility</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"></span>
<span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">dyamic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">absolute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">strindex</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">commonStorage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Symbol creation interface:</p>
<dl class="docutils">
<dt>name</dt><dd>The mangled name of the symbol.</dd>
<dt>type</dt><dd>The type of the symbol as specified above.</dd>
<dt>linkage</dt><dd>The linkage of the symbol as specified above.</dd>
<dt>visibility</dt><dd>The visibility of the symbol as specified above.</dd>
<dt>offset</dt><dd>The offset within the file that the symbol refers to.</dd>
<dt>module</dt><dd>The source code module the symbol should belong to; default is no
module.</dd>
<dt>region</dt><dd>The region the symbol belongs to; if left unset this will be
determined if a new binary is generated.</dd>
<dt>size</dt><dd>The size of the object the symbol refers to; defaults to 0.</dd>
<dt>dynamic</dt><dd>If true, the symbol belongs to the dynamic symbol table (ELF) and may
be used as the target of inter-module references.</dd>
<dt>absolute</dt><dd>If true, the offset specified is treated as an absolute value rather
than an offset.</dd>
<dt>index</dt><dd>The index in the symbol table. If left unset, it will be determined
when generating a new binary.</dd>
<dt>strindex</dt><dd>The index in the string table that contains the symbol name. If left
unset, it will be determined when generating a new binary.</dd>
<dt>commonStorage</dt><dd>If true, the symbol references common storage (Fortran).</dd>
</dl>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getVersionFileName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fileName</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves the file name in which this symbol is present.
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if this symbol does not have any version information
present otherwise returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getVersions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">vers</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves all the version names for this symbol. Returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> if the symbol does not have any version information present.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getVersionNum</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="o">&amp;</span><span class="n">verNum</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves the version number of the symbol. Returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> if the symbol does not have any version information present.</p>
<div class="section" id="symbol-modification">
<h3>Symbol modification<a class="headerlink" href="#symbol-modification" title="Permalink to this headline"></a></h3>
<p>Most elements of a <code class="docutils literal notranslate"><span class="pre">Symbol</span></code> can be modified using the functions below.
Each returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setSize</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setOffset</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">newOffset</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">setMangledName</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setType</span><span class="w"> </span><span class="p">(</span><span class="n">SymbolType</span><span class="w"> </span><span class="n">sType</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">setModule</span><span class="w"> </span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setRegion</span><span class="w"> </span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">region</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">setDynamic</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">dyn</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setAbsolute</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">absolute</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">setCommonStorage</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">common</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setFunction</span><span class="w"> </span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">*</span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"></span>
<span class="n">setVariable</span><span class="w"> </span><span class="p">(</span><span class="n">Variable</span><span class="w"> </span><span class="o">*</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setIndex</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setStrIndex</span><span class="w"></span>
<span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setPtrOffset</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setLocalTOC</span><span class="w"> </span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">toc</span><span class="p">)</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">setVersionNum</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setVersionFileName</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"></span>
<span class="o">&amp;</span><span class="n">fileName</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">setVersions</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vers</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="class-archive">
<span id="archive"></span><h2>Class Archive<a class="headerlink" href="#class-archive" title="Permalink to this headline"></a></h2>
<p>This is used only on ELF platforms. This class represents an archive.
This class has information of all the members in the archives.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">openArchive</span><span class="p">(</span><span class="n">Archive</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new <code class="docutils literal notranslate"><span class="pre">Archive</span></code> object for an archive file
on disk. This object serves as a handle to the parsed archive file.
<code class="docutils literal notranslate"><span class="pre">name</span></code> represents the name of the archive to be parsed. The
<code class="docutils literal notranslate"><span class="pre">Archive</span></code> object is returned in <code class="docutils literal notranslate"><span class="pre">img</span></code> if the parsing succeeds. This
method returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if the given file is not an archive. The error
is set to <code class="docutils literal notranslate"><span class="pre">Not_An_Archive</span></code>. This returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the archive is
parsed without an error. <code class="docutils literal notranslate"><span class="pre">printSymtabError()</span></code> should be called to get
more error details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">openArchive</span><span class="p">(</span><span class="n">Archive</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">mem_image</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new <code class="docutils literal notranslate"><span class="pre">Archive</span></code> object for an archive file
in memory. This object serves as a handle to the parsed archive file.
<code class="docutils literal notranslate"><span class="pre">mem_image</span></code> represents the pointer to the archive to be parsed.
<code class="docutils literal notranslate"><span class="pre">size</span></code> represents the size of the memory image. The <code class="docutils literal notranslate"><span class="pre">Archive</span></code> object
is returned in <code class="docutils literal notranslate"><span class="pre">img</span></code> if the parsing succeeds. This method returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> if the given file is not an archive. The error is set to
<code class="docutils literal notranslate"><span class="pre">Not_An_Archive</span></code>. This returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the archive is parsed
without an error. <code class="docutils literal notranslate"><span class="pre">printSymtabError()</span></code> should be called to get more
error details. This method is not supported currently on all ELF
platforms.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getMember</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">member_name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the member object handle if the member exists in the
archive. <code class="docutils literal notranslate"><span class="pre">img</span></code> corresponds to the object handle for the member. This
method returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if the member with name <code class="docutils literal notranslate"><span class="pre">member_name</span></code> does
not exist else returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getMemberByOffset</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">img</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">memberOffset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the member object handle if the member exists at the
start offset <code class="docutils literal notranslate"><span class="pre">memberOffset</span></code> in the archive. <code class="docutils literal notranslate"><span class="pre">img</span></code> corresponds to the
object handle for the member. This method returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if the
member with name <code class="docutils literal notranslate"><span class="pre">member_name</span></code> does not exist else returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllMembers</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">members</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns all the member object handles in the archive.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success with <code class="docutils literal notranslate"><span class="pre">members</span></code> containing the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code>
Objects for all the members in the archive.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isMemberInArchive</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">member_name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the member with name <code class="docutils literal notranslate"><span class="pre">member_name</span></code>
exists in the archive or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">findMemberWithDefinition</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method retrieves the member in an archive which contains the
definition to a symbol with mangled name <code class="docutils literal notranslate"><span class="pre">name</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> with
<code class="docutils literal notranslate"><span class="pre">obj</span></code> containing the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> handle to that member or else returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">SymtabError</span><span class="w"> </span><span class="n">getLastError</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns an error value for the previously performed
operation that resulted in a failure. SymtabAPI sets a global error
value in case of error during any operation. This call returns the last
error that occurred while performing any operation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">printError</span><span class="p">(</span><span class="n">SymtabError</span><span class="w"> </span><span class="n">serr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns a detailed description of the enum value <code class="docutils literal notranslate"><span class="pre">serr</span></code> in
human readable format.</p>
</div>
<div class="section" id="class-region">
<h2>Class Region<a class="headerlink" href="#class-region" title="Permalink to this headline"></a></h2>
<p>This class represents a contiguous range of code or data as encoded in
the object file. For ELF, regions represent ELF sections.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">perm_t</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RP_R</td>
<td>Read-only data</td>
</tr>
<tr class="row-odd"><td>RP_RW</td>
<td>Read/write data</td>
</tr>
<tr class="row-even"><td>RP_RX</td>
<td>Read-only code</td>
</tr>
<tr class="row-odd"><td>RP_RWX</td>
<td>Read/write code</td>
</tr>
</tbody>
</table>
</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">RegionType</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT_TEXT</td>
<td>Executable code</td>
</tr>
<tr class="row-odd"><td>RT_DATA</td>
<td>Read/write data</td>
</tr>
<tr class="row-even"><td>RT_TEXTDATA</td>
<td>Mix of code and data</td>
</tr>
<tr class="row-odd"><td>RT_SYMTAB</td>
<td>Static symbol table</td>
</tr>
<tr class="row-even"><td>RT_STRTAB</td>
<td>String table used by the symbol table</td>
</tr>
<tr class="row-odd"><td>RT_BSS</td>
<td>0-initialized memory</td>
</tr>
<tr class="row-even"><td>RT_SYMVERSIONS</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-odd"><td>RT_SYMVERDEF</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-even"><td>RT_SYMVERNEEDED</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-odd"><td>RT_REL</td>
<td>Relocation section</td>
</tr>
<tr class="row-even"><td>RT_RELA</td>
<td>Relocation section</td>
</tr>
<tr class="row-odd"><td>RT_PLTREL</td>
<td>Relocation section for PLT (inter-library
references) entries</td>
</tr>
<tr class="row-even"><td>RT_PLTRELA</td>
<td>Relocation section for PLT (inter-library
references) entries</td>
</tr>
<tr class="row-odd"><td>RT_DYNAMIC</td>
<td>Decription of library dependencies</td>
</tr>
<tr class="row-even"><td>RT_HASH</td>
<td>Fast symbol lookup section</td>
</tr>
<tr class="row-odd"><td>RT_GNU_HASH</td>
<td>GNU-specific fast symbol lookup section</td>
</tr>
<tr class="row-even"><td>RT_OTHER</td>
<td>Miscellaneous information</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getRegionNumber</td>
<td>unsigned</td>
<td>Index of the region in the file, starting at 0.</td>
</tr>
<tr class="row-odd"><td>getRegionName</td>
<td>std::string</td>
<td>Name of the region (e.g., .text, .data).</td>
</tr>
<tr class="row-even"><td>getPtrToRawData</td>
<td>void *</td>
<td>Read-only pointer to the region’s raw data buffer.</td>
</tr>
<tr class="row-odd"><td>getDiskOffset</td>
<td>Offset</td>
<td>Offset within the file where the region begins.</td>
</tr>
<tr class="row-even"><td>getDiskSize</td>
<td>unsigned long</td>
<td>Size of the region’s data in the file.</td>
</tr>
<tr class="row-odd"><td>getMemOffset</td>
<td>Offset</td>
<td>Location where the region will be loaded into memory, modified by the file’s base load address.</td>
</tr>
<tr class="row-even"><td>getMemSize</td>
<td>unsigned long</td>
<td>Size of the region in memory, including zero padding.</td>
</tr>
<tr class="row-odd"><td>isBSS</td>
<td>bool</td>
<td>Type query for uninitialized data regions (zero disk size, non-zero memory size).</td>
</tr>
<tr class="row-even"><td>isText</td>
<td>bool</td>
<td>Type query for executable code regions.</td>
</tr>
<tr class="row-odd"><td>isData</td>
<td>bool</td>
<td>Type query for initialized data regions.</td>
</tr>
<tr class="row-even"><td>getRegionPermissions</td>
<td>perm_t</td>
<td>Permissions for the region; perm_t is defined above.</td>
</tr>
<tr class="row-odd"><td>getRegionType</td>
<td>RegionType</td>
<td>Type of the region as defined above.</td>
</tr>
<tr class="row-even"><td>isLoadable</td>
<td>bool</td>
<td>True if the region will be loaded into memory (e.g., code or data) false otherwise (e.g., debug information).</td>
</tr>
<tr class="row-odd"><td>isDirty</td>
<td>bool</td>
<td>True if the region’s raw data buffer has been modified by the user.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">createRegion</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">diskOff</span><span class="p">,</span><span class="w"> </span><span class="n">perm_t</span><span class="w"> </span><span class="n">perms</span><span class="p">,</span><span class="w"> </span><span class="n">RegionType</span><span class="w"> </span><span class="n">regType</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">diskSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">memOff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">memSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rawDataPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isLoadable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isTLS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">memAlign</span><span class="w"> </span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new region with the provided arguments.
The <code class="docutils literal notranslate"><span class="pre">memOff</span></code> and <code class="docutils literal notranslate"><span class="pre">memSize</span></code> parameters identify where the region
should be loaded in memory (modified by the base address of the file);
if <code class="docutils literal notranslate"><span class="pre">memSize</span></code> is larger than <code class="docutils literal notranslate"><span class="pre">diskSize</span></code> the remainder will be
zero-padded (e.g., bss regions).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isOffsetInRegion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the offset falls within the region data.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">setRegionNumber</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Sets the region index; the value must not overlap with any other regions
and is not checked.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setPtrToRawData</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">newPtr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rawsize</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Set the raw data pointer of the region to <code class="docutils literal notranslate"><span class="pre">newPtr</span></code>. <code class="docutils literal notranslate"><span class="pre">rawsize</span></code>
represents the size of the raw data buffer. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if success
or <code class="docutils literal notranslate"><span class="pre">false</span></code> when unable to set/change the raw data of the region.
Implicitly changes the disk and memory sizes of the region.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setRegionPermissions</span><span class="p">(</span><span class="n">perm_t</span><span class="w"> </span><span class="n">newPerms</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This sets the regions permissions to <code class="docutils literal notranslate"><span class="pre">newPerms</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on
success.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setLoadable</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">isLoadable</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets whether the region is loaded into memory at load time.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addRelocationEntry</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">relocationAddr</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">dynref</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="n">relType</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="o">::</span><span class="n">RegionType</span><span class="w"> </span><span class="n">rtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Region</span><span class="o">::</span><span class="n">RT_REL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Creates and adds a relocation entry for this region. The symbol
<code class="docutils literal notranslate"><span class="pre">dynref</span></code> represents the symbol used by he relocation, <code class="docutils literal notranslate"><span class="pre">relType</span></code> is
the (platform-specific) relocation type, and <code class="docutils literal notranslate"><span class="pre">rtype</span></code> represents
whether the relocation is REL or RELA (ELF-specific).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">relocationEntry</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getRelocations</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Get the vector of relocation entries that will modify this region. The
vector should not be modified.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addRelocationEntry</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">relocationEntry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rel</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Add the provided relocation entry to this region.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">patchData</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Patch the raw data for this region. <code class="docutils literal notranslate"><span class="pre">buf</span></code> represents the buffer to be
patched at offset <code class="docutils literal notranslate"><span class="pre">off</span></code> and size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<div class="section" id="removed">
<h3>REMOVED<a class="headerlink" href="#removed" title="Permalink to this headline"></a></h3>
<p>The following methods were removed since they were inconsistent and
dangerous to use.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Offset</span><span class="w"> </span><span class="n">getRegionAddr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Please use <code class="docutils literal notranslate"><span class="pre">getDiskOffset</span></code> or <code class="docutils literal notranslate"><span class="pre">getMemOffset</span></code> instead, as
appropriate.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">getRegionSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Please use <code class="docutils literal notranslate"><span class="pre">getDiskSize</span></code> or <code class="docutils literal notranslate"><span class="pre">getMemSize</span></code> instead, as appropriate.</p>
</div>
</div>
<div class="section" id="relocation-information">
<h2>Relocation Information<a class="headerlink" href="#relocation-information" title="Permalink to this headline"></a></h2>
<p>This class represents object relocation information.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Offset</span><span class="w"> </span><span class="n">target_addr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the offset that will be overwritten when relocations are
processed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Offset</span><span class="w"> </span><span class="n">rel_addr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the offset of the relocation itself.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Offset</span><span class="w"> </span><span class="n">addend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the value added to the relocation; whether this value is used
or not is specific to the relocation type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the user-readable name of the relocation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">getDynSym</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the symbol whose final address will be used in the relocation
calculation. How this address is used is specific to the relocation
type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">getRelType</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>Specifies the platform-specific relocation type.</p>
</div>
<div class="section" id="class-exceptionblock">
<span id="exceptionblock"></span><h2>Class ExceptionBlock<a class="headerlink" href="#class-exceptionblock" title="Permalink to this headline"></a></h2>
<p>This class represents an exception block present in the object file.
This class gives all the information pertaining to that exception block.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>hasTry</td>
<td>bool</td>
<td>True if the exception block has a try block.</td>
</tr>
<tr class="row-odd"><td>tryStart</td>
<td>Offset</td>
<td>Start of the try block if it exists, else 0.</td>
</tr>
<tr class="row-even"><td>tryEnd</td>
<td>Offset</td>
<td>End of the try block if it exists, else 0.</td>
</tr>
<tr class="row-odd"><td>trySize</td>
<td>Offset</td>
<td>Size of the try block if it exists, else 0.</td>
</tr>
<tr class="row-even"><td>catchStart</td>
<td>Offset</td>
<td>Start of the catch block.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">contains</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the offset <code class="docutils literal notranslate"><span class="pre">addr</span></code> is contained with in
the try block. If there is no try block associated with this exception
block or the offset does not fall within the try block, it returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-localvar">
<span id="localvar"></span><h2>Class localVar<a class="headerlink" href="#class-localvar" title="Permalink to this headline"></a></h2>
<p>This represents a local variable or parameter of a function.</p>
<table border="1" class="docutils" id="id5">
<caption><span class="caption-text">Class localVar</span><a class="headerlink" href="#id5" title="Permalink to this table"></a></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getName</td>
<td>string &amp;</td>
<td>Name of the local variable or parameter.</td>
</tr>
<tr class="row-odd"><td>getType</td>
<td>Type *</td>
<td>Type associated with the variable.</td>
</tr>
<tr class="row-even"><td>getFileName</td>
<td>string &amp;</td>
<td>File where the variable was declared, if known.</td>
</tr>
<tr class="row-odd"><td>getLineNum</td>
<td>int</td>
<td>Line number where the variable was declared, if known.</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VariableLocation</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getLocationLists</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>A local variable can be in scope at different positions and based on
that it is accessible in different ways. Location lists provide a way to
encode that information. The method retrieves the location list,
specified in terms of <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> structures (section
<a class="reference external" href="#VariableLocation">6.13</a>) where the variable is in scope.</p>
</div>
<div class="section" id="class-variablelocation">
<span id="variablelocation"></span><h2>Class VariableLocation<a class="headerlink" href="#class-variablelocation" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> class is an encoding of the location of a
variable in memory or registers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">storageUnset</span><span class="p">,</span><span class="w"> </span><span class="n">storageAddr</span><span class="p">,</span><span class="w"> </span><span class="n">storageReg</span><span class="p">,</span><span class="w"> </span><span class="n">storageRegOffset</span><span class="w"> </span><span class="n">storageClass</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">storageRefUnset</span><span class="p">,</span><span class="w"> </span><span class="n">storageRef</span><span class="p">,</span><span class="w"> </span><span class="n">storageNoRef</span><span class="w"> </span><span class="n">storageRefClass</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">VariableLocation</span><span class="w"> </span><span class="n">storageClass</span><span class="w"> </span><span class="n">stClass</span><span class="p">;</span><span class="w"> </span><span class="n">storageRefClass</span><span class="w"> </span><span class="n">refClass</span><span class="p">;</span><span class="w"></span>
<span class="n">MachRegister</span><span class="w"> </span><span class="n">mr_reg</span><span class="p">;</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">frameOffset</span><span class="p">;</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="n">lowPC</span><span class="p">;</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="n">hiPC</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> is valid within the address range represented by
<code class="docutils literal notranslate"><span class="pre">lowPC</span></code> and <code class="docutils literal notranslate"><span class="pre">hiPC</span></code>. If these are 0 and (Address) -1, respectively,
the <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> is always valid.</p>
<p>The location represented by the <code class="docutils literal notranslate"><span class="pre">VariableLocation</span></code> can be determined
by the user as follows:</p>
<ul>
<li><p class="first">stClass == storageAddr</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The frameOffset member contains the address of a pointer to the
variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The frameOffset member contains the address of the variable.</p>
</dd>
</dl>
</li>
<li><p class="first">stClass == storageReg</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The register named by mr_reg contains the address of the variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The register named by mr_reg member contains the variable.</p>
</dd>
</dl>
</li>
<li><p class="first">stClass == storageRegOffset</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The address computed by adding frameOffset to the contents of
mr_reg contains a pointer to the variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The address computed by adding frameOffset to the contents of
mr_reg contains the variable.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="api-reference-line-number-interface">
<span id="linenointerface"></span><h1>API Reference - Line Number Interface<a class="headerlink" href="#api-reference-line-number-interface" title="Permalink to this headline"></a></h1>
<p>This section describes the line number interface for the SymtabAPI
library. Currently this interface has the following capabilities:</p>
<ul class="simple">
<li>Look up address ranges for a given line number.</li>
<li>Look up source lines for a given address.</li>
<li>Add new line information. This information will be available for
lookup, but will not be included with an emitted object file.</li>
</ul>
<p>In order to look up or add line information, the user/application must
have already parsed the object file and should have a Symtab handle to
the object file. For more information on line information lookups
through the Symtab class refer to Section <a class="reference external" href="#sec:symtabAPI">6</a>. The
rest of this section describes the classes that are part of the line
number interface.</p>
<div class="section" id="class-lineinformation">
<span id="lineinformation"></span><h2>Class LineInformation<a class="headerlink" href="#class-lineinformation" title="Permalink to this headline"></a></h2>
<p>This class represents an entire line map for a module. This contains
mappings from a line number within a source to the address ranges.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAddressRanges</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">LineNo</span><span class="p">,</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressRange</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ranges</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This methos returns the address ranges in <code class="docutils literal notranslate"><span class="pre">ranges</span></code> corresponding to
the line with line number <code class="docutils literal notranslate"><span class="pre">lineNo</span></code> in the source file <code class="docutils literal notranslate"><span class="pre">lineSource</span></code>.
Searches within this line map. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one address
range corresponding to the line number was found and returns <code class="docutils literal notranslate"><span class="pre">false</span></code>
if none found.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSourceLines</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">addressInRange</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Statement</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">lines</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">getSourceLines</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">addressInRange</span><span class="p">,</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LineNoTuple</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">lines</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>These methods returns the source file names and line numbers
corresponding to the given address <code class="docutils literal notranslate"><span class="pre">addressInRange</span></code>. Searches within
this line map. Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one tuple corresponding to
the offset was found and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if none found. Note that the
order of arguments is reversed from the corresponding interfaces in
<code class="docutils literal notranslate"><span class="pre">Module</span></code> and <code class="docutils literal notranslate"><span class="pre">Symtab</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addLine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineNo</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="n">lineOffset</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">lowInclusiveAddr</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">highExclusiveAddr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new line to the line Map. <code class="docutils literal notranslate"><span class="pre">lineSource</span></code> represents
the source file name. <code class="docutils literal notranslate"><span class="pre">lineNo</span></code> represents the line number.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">addAddressRange</span><span class="p">(</span><span class="n">Offset</span><span class="w"> </span><span class="n">lowInclusiveAddr</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">highExclusiveAddr</span><span class="p">,</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">lineSource</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineNo</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lineOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds an address range
<code class="docutils literal notranslate"><span class="pre">[lowInclusiveAddr,</span> <span class="pre">highExclusiveAddr)</span></code> for the line with line number
<code class="docutils literal notranslate"><span class="pre">lineNo</span></code> in source file <code class="docutils literal notranslate"><span class="pre">lineSource</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LineInformation</span><span class="o">::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns an iterator pointing to the beginning of the line
information for the module. This is useful for iterating over the entire
line information present in a module. An example described in Section
<a class="reference external" href="#subsec:LineNoIterating">7.3</a> gives more information on how to use
<code class="docutils literal notranslate"><span class="pre">begin()</span></code> for iterating over the line information.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LineInformation</span><span class="o">::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns an iterator pointing to the end of the line
information for the module. This is useful for iterating over the entire
line information present in a module. An example described in Section
<a class="reference external" href="#subsec:LineNoIterating">7.3</a> gives more information on how to use
<code class="docutils literal notranslate"><span class="pre">end()</span></code> for iterating over the line information.</p>
</div>
<div class="section" id="class-statement">
<span id="statement"></span><h2>Class Statement<a class="headerlink" href="#class-statement" title="Permalink to this headline"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">Statement</span></code> is the base representation of line information.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="18%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>startAddr</td>
<td>Offset</td>
<td>Starting address of this line in the file.</td>
</tr>
<tr class="row-odd"><td>endAddr</td>
<td>Offset</td>
<td>Ending address of this line in the file.</td>
</tr>
<tr class="row-even"><td>getFile</td>
<td>std::string</td>
<td>File that contains the line.</td>
</tr>
<tr class="row-odd"><td>getLine</td>
<td>unsigned int</td>
<td>Line number.</td>
</tr>
<tr class="row-even"><td>getColumn</td>
<td>unsigned int</td>
<td>Starting column number.</td>
</tr>
</tbody>
</table>
<p>For backwards compatibility, this class may also be referred to as a
<code class="docutils literal notranslate"><span class="pre">LineNoTuple</span></code>, and provides the following legacy member variables.
They should not be used and will be removed in a future version of
SymtabAPI.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="30%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>first</td>
<td>const char *</td>
<td>Equivalent to getFile.</td>
</tr>
<tr class="row-odd"><td>second</td>
<td>unsigned int</td>
<td>Equivalent to getLine.</td>
</tr>
<tr class="row-even"><td>column</td>
<td>unsigned int</td>
<td>Equivalent to getColumn.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="iterating-over-line-information">
<span id="subsec-linenoiterating"></span><h2>Iterating over Line Information<a class="headerlink" href="#iterating-over-line-information" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">LineInformation</span></code> class also provides the ability for iterating
over its data (line numbers and their corresponding address ranges). The
following example shows how to iterate over the line information for a
given module using SymtabAPI.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//Example showing how to iterate over the line information for a given module.</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Obj represents a handle to a parsed object file using symtabAPI</span>
<span class="c1">//Module handle for the module</span>
<span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">mod</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Find the module \lq foo\rq within the object.</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">findModuleByName</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Get the Line Information for module foo.</span>
<span class="n">LineInformation</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">getLineInformation</span><span class="p">();</span><span class="w"></span>

<span class="c1">//Iterate over the line information</span>
<span class="n">LineInformation</span><span class="o">::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="c1">// First component represents the address range for the line</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="o">&gt;</span><span class="w"> </span><span class="n">addrRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Second component gives information about the line itself.</span>
<span class="n">LineNoTuple</span><span class="w"> </span><span class="n">lt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="api-reference-type-interface">
<h1>API Reference - Type Interface<a class="headerlink" href="#api-reference-type-interface" title="Permalink to this headline"></a></h1>
<p>This section describes the type interface for the SymtabAPI library.
Currently this interface has the following capabilities:</p>
<ul class="simple">
<li>Look up types within an object file.</li>
<li>Extend the types to create new types and add them to the Symtab file
representation. These types will be available for lookup but will not
be added if a new object file is produced.</li>
</ul>
<p>The rest of the section describes the classes that are part of the type
interface.</p>
<div class="section" id="class-type">
<h2>Class Type<a class="headerlink" href="#class-type" title="Permalink to this headline"></a></h2>
<p>The class <code class="docutils literal notranslate"><span class="pre">Type</span></code> represents the types of variables, parameters, return
values, and functions. Instances of this class can represent language
predefined types (e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>), already defined types in the
Object File or binary (e.g., structures compiled into the binary), or
newly created types (created using the create factory methods of the
corresponding type classes described later in this section) that are
added to SymtabAPI by the user.</p>
<p>As described in Section <a class="reference external" href="#subsec:typeInterface">2.2</a>, this class
serves as a base class for all the other classes in this interface. An
object of this class is returned from type look up operations performed
through the Symtab class described in Section <a class="reference external" href="#sec:symtabAPI">6</a>.
The user can then obtain the specific type object from the generic Type
class object. The following example shows how to get the specific object
from a given <code class="docutils literal notranslate"><span class="pre">Type</span></code> object returned as part of a look up operation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example shows how to retrieve a structure type object from a given Type object</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Dyninst</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SymtabAPI</span><span class="p">;</span><span class="w"></span>

<span class="c1">//Obj represents a handle to a parsed object file using symtabAPI</span>
<span class="c1">//Find a structure type in the object file</span>
<span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">structType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">findType</span><span class="p">(</span><span class="s">&quot;structType1&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Get the specific typeStruct object</span>
<span class="n">typeStruct</span><span class="w"> </span><span class="o">*</span><span class="n">stType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">structType</span><span class="o">-&gt;</span><span class="n">isStructType</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the name associated with this type. Each of the
types is represented by a symbolic name. This method retrieves the name
for the type. For example, in the example above “structType1” represents
the name for the <code class="docutils literal notranslate"><span class="pre">structType</span></code> object.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">zname</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets the name of this type to name. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on
success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">enumdataEnum</span><span class="p">,</span><span class="w"> </span><span class="n">dataPointer</span><span class="p">,</span><span class="w"> </span><span class="n">dataFunction</span><span class="p">,</span><span class="w"> </span><span class="n">dataSubrange</span><span class="p">,</span><span class="w"></span>
<span class="n">dataArray</span><span class="p">,</span><span class="w"> </span><span class="n">dataStructure</span><span class="p">,</span><span class="w"> </span><span class="n">dataUnion</span><span class="p">,</span><span class="w"> </span><span class="n">dataCommon</span><span class="p">,</span><span class="w"> </span><span class="n">dataScalar</span><span class="p">,</span><span class="w"></span>
<span class="n">dataTypedef</span><span class="p">,</span><span class="w"> </span><span class="n">dataReference</span><span class="p">,</span><span class="w"> </span><span class="n">dataUnknownType</span><span class="p">,</span><span class="w"> </span><span class="n">dataNullType</span><span class="p">,</span><span class="w"> </span><span class="n">dataTypeClass</span><span class="w"></span>
<span class="n">dataClass</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">dataClass</span><span class="w"> </span><span class="n">getDataClass</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the data class associated with the type. This value
should be used to convert this generic type object to a specific type
object which offers more functionality by using the corresponding query
function described later in this section. For example, if this method
returns <code class="docutils literal notranslate"><span class="pre">dataStructure</span></code> then the <code class="docutils literal notranslate"><span class="pre">isStructureType()</span></code> should be
called to dynamically cast the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to the <code class="docutils literal notranslate"><span class="pre">typeStruct</span></code>
object.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeId_t</span><span class="w"> </span><span class="n">getID</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the ID associated with this type. Each type is
assigned a unique ID within the object file. For example an integer
scalar built-in type is assigned an ID -1.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="n">getSize</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the total size in bytes occupied by the type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeEnum</span><span class="w"> </span><span class="o">*</span><span class="n">getEnumType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> hobject represents an enum type, then return the object
casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeEnum</span></code> otherwise return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typePointer</span><span class="w"> </span><span class="o">*</span><span class="n">getPointerType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents an pointer type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typePointer</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeFunction</span><span class="w"> </span><span class="o">*</span><span class="n">getFunctionType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents an <code class="docutils literal notranslate"><span class="pre">Function</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeFunction</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeRange</span><span class="w"> </span><span class="o">*</span><span class="n">getSubrangeType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Subrange</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeSubrange</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeArray</span><span class="w"> </span><span class="o">*</span><span class="n">getArrayType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents an <code class="docutils literal notranslate"><span class="pre">Array</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeArray</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeStruct</span><span class="w"> </span><span class="o">*</span><span class="n">getStructType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Structure</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeStruct</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeUnion</span><span class="w"> </span><span class="o">*</span><span class="n">getUnionType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Union</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeUnion</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeScalar</span><span class="w"> </span><span class="o">*</span><span class="n">getScalarType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Scalar</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeScalar</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeCommon</span><span class="w"> </span><span class="o">*</span><span class="n">getCommonType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Common</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeCommon</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeTypedef</span><span class="w"> </span><span class="o">*</span><span class="n">getTypedefType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">TypeDef</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeTypedef</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">typeRef</span><span class="w"> </span><span class="o">*</span><span class="n">getRefType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>If this <code class="docutils literal notranslate"><span class="pre">Type</span></code> object represents a <code class="docutils literal notranslate"><span class="pre">Reference</span></code> type, then return the
object casting the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object to <code class="docutils literal notranslate"><span class="pre">typeRef</span></code> otherwise return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<div class="section" id="class-typeenum">
<h2>Class typeEnum<a class="headerlink" href="#class-typeenum" title="Permalink to this headline"></a></h2>
<p>This class represents an enumeration type containing a list of constants
with values. This class is derived from <code class="docutils literal notranslate"><span class="pre">Type</span></code>, so all those member
functions are applicable. <code class="docutils literal notranslate"><span class="pre">typeEnum</span></code> inherits from the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeEnum</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"></span>
<span class="o">&amp;</span><span class="n">consts</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">typeEnum</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constNames</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>These factory methods create a new enumerated type. There are two
variations to this function. <code class="docutils literal notranslate"><span class="pre">consts</span></code> supplies the names and Ids of
the constants of the enum. The first variant is used when user-defined
identifiers are required; the second variant is used when system-defined
identifiers will be used. The newly created type is added to the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added
to any object file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addConstant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constname</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a constant to an enum type with name <code class="docutils literal notranslate"><span class="pre">constName</span></code> and
value <code class="docutils literal notranslate"><span class="pre">value</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getConstants</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the vector containing the enum constants represented
by a (name, value) pair of the constant.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets the new name of the enum type to <code class="docutils literal notranslate"><span class="pre">name</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the enum type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typefunction">
<h2>Class typeFunction<a class="headerlink" href="#class-typefunction" title="Permalink to this headline"></a></h2>
<p>This class represents a function type, containing a list of parameters
and a return type. This class is derived from <code class="docutils literal notranslate"><span class="pre">Type</span></code>, so all the
member functions of class <code class="docutils literal notranslate"><span class="pre">Type</span></code> are applicable. <code class="docutils literal notranslate"><span class="pre">typeFunction</span></code>
inherits from the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeFunction</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">retType</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new function type with name <code class="docutils literal notranslate"><span class="pre">name</span></code>.
<code class="docutils literal notranslate"><span class="pre">retType</span></code> represents the return type of the function and
<code class="docutils literal notranslate"><span class="pre">paramTypes</span></code> is a vector of the types of the parameters in order. The
the newly created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If
<code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object file, but it
will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the function type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">addParam</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new function parameter with type <code class="docutils literal notranslate"><span class="pre">type</span></code> to the
function type. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">getReturnType</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the return type for this function type. Returns
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no return type associated with this function type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setRetType</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">rtype</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets the return type of the function type to <code class="docutils literal notranslate"><span class="pre">rtype</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets the new name of the function type to <code class="docutils literal notranslate"><span class="pre">name</span></code>. Returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getParams</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the vector containing the individual parameters
represented by their types in order. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there are no
parameters to the function type.</p>
</div>
<div class="section" id="class-typescalar">
<h2>Class typeScalar<a class="headerlink" href="#class-typescalar" title="Permalink to this headline"></a></h2>
<p>This class represents a scalar type. This class is derived from
<code class="docutils literal notranslate"><span class="pre">Type</span></code>, so all the member functions of class <code class="docutils literal notranslate"><span class="pre">Type</span></code> are applicable.
<code class="docutils literal notranslate"><span class="pre">typeScalar</span></code> inherits from the Type class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeScalar</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new scalar type. The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is
used to specify the name of the type, and the <code class="docutils literal notranslate"><span class="pre">size</span></code> parameter is used
to specify the size in bytes of each instance of the type. The newly
created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object file, but it will be
available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isSigned</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the scalar type is signed or else
returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the scalar type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-field">
<h2>Class Field<a class="headerlink" href="#class-field" title="Permalink to this headline"></a></h2>
<p>This class represents a field in a container. For e.g. a field in a
structure/union type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">visPrivate</span><span class="p">,</span><span class="w"> </span><span class="n">visProtected</span><span class="p">,</span><span class="w"> </span><span class="n">visPublic</span><span class="p">,</span><span class="w"> </span><span class="n">visUnknown</span><span class="w"> </span><span class="n">visibility_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>A handle for identifying the visibility of a certain <code class="docutils literal notranslate"><span class="pre">Field</span></code> in a
container type. This can represent private, public, protected or
unknown(default) visibility.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Field</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">visibility_t</span><span class="w"> </span><span class="n">vis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visUnknown</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This constructor creates a new field with name <code class="docutils literal notranslate"><span class="pre">name</span></code>, type <code class="docutils literal notranslate"><span class="pre">type</span></code>
and visibility <code class="docutils literal notranslate"><span class="pre">vis</span></code>. This newly created <code class="docutils literal notranslate"><span class="pre">Field</span></code> can be added to a
container type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the name associated with the field in the container.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">getType</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the type associated with the field in the container.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">getOffset</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the offset associated with the field in the
container.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">visibility_t</span><span class="w"> </span><span class="n">getVisibility</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the visibility associated with a field in a
container. This returns <code class="docutils literal notranslate"><span class="pre">visPublic</span></code> for the variables within a common
block.</p>
</div>
<div class="section" id="class-fieldlisttype">
<h2>Class fieldListType<a class="headerlink" href="#class-fieldlisttype" title="Permalink to this headline"></a></h2>
<p>This class represents a container type. It is one of the three
categories of types as described in Section
<a class="reference external" href="#subsec:typeInterface">2.2</a>. The structure and the union types fall
under this category. This class is derived from <code class="docutils literal notranslate"><span class="pre">Type</span></code>, so all the
member functions of class <code class="docutils literal notranslate"><span class="pre">Type</span></code> are applicable. <code class="docutils literal notranslate"><span class="pre">fieldListType</span></code>
inherits from the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Field</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">getComponents</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the list of all fields present in the container.
This gives information about the name, type and visibility of each of
the fields. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> of there are no fields.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">addField</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fieldname</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offsetVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"></span>
<span class="n">visibility_t</span><span class="w"> </span><span class="n">vis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visUnknown</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new field at the end to the container type with field
name <code class="docutils literal notranslate"><span class="pre">fieldname</span></code>, type <code class="docutils literal notranslate"><span class="pre">type</span></code> and type visibility <code class="docutils literal notranslate"><span class="pre">vis</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">addField</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fieldname</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="n">offsetVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">visibility_t</span><span class="w"> </span><span class="n">vis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visUnknown</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a field after the field with number <code class="docutils literal notranslate"><span class="pre">num</span></code> with field
name <code class="docutils literal notranslate"><span class="pre">fieldname</span></code>, type <code class="docutils literal notranslate"><span class="pre">type</span></code> and type visibility <code class="docutils literal notranslate"><span class="pre">vis</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">addField</span><span class="p">(</span><span class="n">Field</span><span class="w"> </span><span class="o">*</span><span class="n">fld</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a new field <code class="docutils literal notranslate"><span class="pre">fld</span></code> to the container type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">addField</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">Field</span><span class="w"> </span><span class="o">*</span><span class="n">fld</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method adds a field <code class="docutils literal notranslate"><span class="pre">fld</span></code> after field <code class="docutils literal notranslate"><span class="pre">num</span></code> to the container
type.</p>
<div class="section" id="class-typestruct-public-fieldlisttype">
<h3>Class typeStruct : public fieldListType<a class="headerlink" href="#class-typestruct-public-fieldlisttype" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a structure type. The structure type is a
special case of the container type. The fields of the structure
represent the fields in this case. As a subclass of class
<code class="docutils literal notranslate"><span class="pre">fieldListType</span></code>, all methods in <code class="docutils literal notranslate"><span class="pre">fieldListType</span></code> are applicable.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeStruct</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flds</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new struct type. The name of the structure
is specified in the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter. The <code class="docutils literal notranslate"><span class="pre">flds</span></code> vector specifies
the names and types of the fields of the structure type. The newly
created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object file, but it will be
available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeStruct</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Field</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fields</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new struct type. The name of the structure
is specified in the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter. The <code class="docutils literal notranslate"><span class="pre">fields</span></code> vector specifies
the fields of the type. The newly created type is added to the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added
to any object file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the struct type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typeunion">
<h3>Class typeUnion<a class="headerlink" href="#class-typeunion" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a union type, a special case of the container
type. The fields of the union type represent the fields in this case.
As a subclass of class <code class="docutils literal notranslate"><span class="pre">fieldListType</span></code>, all methods in
<code class="docutils literal notranslate"><span class="pre">fieldListType</span></code> are applicable. <code class="docutils literal notranslate"><span class="pre">typeUnion</span></code> inherits from the
<code class="docutils literal notranslate"><span class="pre">fieldListType</span></code> class.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeUnion</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*&gt;*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flds</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new union type. The name of the union is
specified in the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter. The <code class="docutils literal notranslate"><span class="pre">flds</span></code> vector specifies the
names and types of the fields of the union type. The newly created type
is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the
type is not added to any object file, but it will be available for
further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeUnion</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Field</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fields</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new union type. The name of the structure
is specified in the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter. The <code class="docutils literal notranslate"><span class="pre">fields</span></code> vector specifies
the fields of the type. The newly created type is added to the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added
to any object file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the union type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typecommon">
<h3>Class typeCommon<a class="headerlink" href="#class-typecommon" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a common block type in fortran, a special case
of the container type. The variables of the common block represent the
fields in this case. As a subclass of class <code class="docutils literal notranslate"><span class="pre">fieldListType</span></code>, all
methods in <code class="docutils literal notranslate"><span class="pre">fieldListType</span></code> are applicable. <code class="docutils literal notranslate"><span class="pre">typeCommon</span></code> inherits
from the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CBlocks</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">getCBlocks</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the common block objects for the type. The methods
of the <code class="docutils literal notranslate"><span class="pre">CBlock</span></code> can be used to access information about the members of
a common block. The vector returned by this function contains one
instance of <code class="docutils literal notranslate"><span class="pre">CBlock</span></code> for each unique definition of the common block.</p>
</div>
<div class="section" id="class-cblock">
<h3>Class CBlock<a class="headerlink" href="#class-cblock" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a common block in Fortran. Multiple functions
can share a common block.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getComponents</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Field</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">vars</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the vector containing the individual variables of
the common block. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is at least one variable,
else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getFunctions</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">funcs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the functions that can see this common block with
the set of variables described in <code class="docutils literal notranslate"><span class="pre">getComponents</span></code> method above.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is at least one function, else returns
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
</div>
<div class="section" id="class-derivedtype">
<h2>Class derivedType<a class="headerlink" href="#class-derivedtype" title="Permalink to this headline"></a></h2>
<p>This class represents a derived type which is a reference to another
type. It is one of the three categories of types as described in Section
<a class="reference external" href="#subsec:typeInterface">2.2</a>. The pointer, reference and the typedef
types fall under this category. This class is derived from <code class="docutils literal notranslate"><span class="pre">Type</span></code>, so
all the member functions of class <code class="docutils literal notranslate"><span class="pre">Type</span></code> are applicable.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">getConstituentType</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the type of the base type to which this type refers
to.</p>
<div class="section" id="class-typepointer">
<h3>Class typePointer<a class="headerlink" href="#class-typepointer" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a pointer type, a special case of the derived
type. The base type in this case is the type this particular type
points to. As a subclass of class <code class="docutils literal notranslate"><span class="pre">derivedType</span></code>, all methods in
<code class="docutils literal notranslate"><span class="pre">derivedType</span></code> are also applicable.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typePointer</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">typePointer</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>These factory methods create a new type, named <code class="docutils literal notranslate"><span class="pre">name</span></code>, which points to
objects of type <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. The first form creates a pointer whose size is
equal to sizeof(void*) on the target platform where the application is
running. In the second form, the size of the pointer is the value passed
in the <code class="docutils literal notranslate"><span class="pre">size</span></code> parameter. The newly created type is added to the
<code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If obj is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to
any object file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the Pointer type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">setPtr</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method sets the pointer type to point to the type in <code class="docutils literal notranslate"><span class="pre">ptr</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it succeeds, else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typetypedef">
<h3>Class typeTypedef<a class="headerlink" href="#class-typetypedef" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> type, a special case of the
derived type. The base type in this case is the <code class="docutils literal notranslate"><span class="pre">Type</span></code>. This
particular type is typedefed to. As a subclass of class
<code class="docutils literal notranslate"><span class="pre">derivedType</span></code>, all methods in <code class="docutils literal notranslate"><span class="pre">derivedType</span></code> are also applicable.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeTypedef</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new type called <code class="docutils literal notranslate"><span class="pre">name</span></code> and having the
type <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. The newly created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object
<code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object
file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the typedef type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typeref">
<h3>Class typeRef<a class="headerlink" href="#class-typeref" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a reference type, a special case of the derived
type. The base type in this case is the <code class="docutils literal notranslate"><span class="pre">Type</span></code> this particular type
refers to. As a subclass of class <code class="docutils literal notranslate"><span class="pre">derivedType</span></code>, all methods in
<code class="docutils literal notranslate"><span class="pre">derivedType</span></code> are also applicable here.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeRef</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new type, named <code class="docutils literal notranslate"><span class="pre">name</span></code>, which is a
reference to objects of type <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. The newly created type is added to
the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not
added to any object file, but it will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the ref type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
</div>
<div class="section" id="class-rangedtype">
<h2>Class rangedType<a class="headerlink" href="#class-rangedtype" title="Permalink to this headline"></a></h2>
<p>This class represents a range type with a lower and an upper bound. It
is one of the three categories of types as described in section
<a class="reference external" href="#subsec:typeInterface">2.2</a>. The sub-range and the array types fall
under this category. This class is derived from <code class="docutils literal notranslate"><span class="pre">Type</span></code>, so all the
member functions of class <code class="docutils literal notranslate"><span class="pre">Type</span></code> are applicable.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">getLow</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the lower bound of the range. This can be the lower
bound of the range type or the lowest index for an array type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">getHigh</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the higher bound of the range. This can be the
higher bound of the range type or the highest index for an array type.</p>
<div class="section" id="class-typesubrange">
<h3>Class typeSubrange<a class="headerlink" href="#class-typesubrange" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents a sub-range type. As a subclass of class
<code class="docutils literal notranslate"><span class="pre">rangedType</span></code>, all methods in <code class="docutils literal notranslate"><span class="pre">rangedType</span></code> are applicable here.
This type is usually used to represent a sub-range of another type.
For example, a <code class="docutils literal notranslate"><span class="pre">typeSubrange</span></code> can represent a sub-range of the array
type or a new integer type can be declared as a sub range of the
integer using this type.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeSubrange</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new sub-range type. The name of the type
is <code class="docutils literal notranslate"><span class="pre">name</span></code>, and the size is <code class="docutils literal notranslate"><span class="pre">size</span></code>. The lower bound of the type is
represented by <code class="docutils literal notranslate"><span class="pre">low</span></code>, and the upper bound is represented by <code class="docutils literal notranslate"><span class="pre">high</span></code>.
The newly created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If
<code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object file, but it
will be available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this sub range type is compatible with
the given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="class-typearray">
<h3>Class typeArray<a class="headerlink" href="#class-typearray" title="Permalink to this headline"></a></h3>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">This class represents an <code class="docutils literal notranslate"><span class="pre">Array</span></code> type. As a subclass of class
<code class="docutils literal notranslate"><span class="pre">rangedType</span></code>, all methods in <code class="docutils literal notranslate"><span class="pre">rangedType</span></code> are applicable.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">typeArray</span><span class="w"> </span><span class="o">*</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory method creates a new array type. The name of the type is
<code class="docutils literal notranslate"><span class="pre">name</span></code>, and the type of each element is <code class="docutils literal notranslate"><span class="pre">type</span></code>. The index of the
first element of the array is <code class="docutils literal notranslate"><span class="pre">low</span></code>, and the last is <code class="docutils literal notranslate"><span class="pre">high</span></code>. The
newly created type is added to the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object <code class="docutils literal notranslate"><span class="pre">obj</span></code>. If <code class="docutils literal notranslate"><span class="pre">obj</span></code>
is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> the type is not added to any object file, but it will be
available for further queries.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">isCompatible</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the array type is compatible with the
given type <code class="docutils literal notranslate"><span class="pre">type</span></code> or else returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">getBaseType</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
</pre></div>
</div>
<p>This method returns the base type of this array type.</p>
</div>
</div>
</div>
<div class="section" id="api-reference-dynamic-components">
<h1>API Reference - Dynamic Components<a class="headerlink" href="#api-reference-dynamic-components" title="Permalink to this headline"></a></h1>
<p>Unlike the static components discussed in Section
<a class="reference external" href="#sec:symtabAPI">6</a>, which operate on files, SymtabAPI’s dynamic
components operate on a process. The dynamic components currently
consist of the Dynamic Address Translation system, which translates
between absolute addresses in a running process and static SymtabAPI
objects.</p>
<div class="section" id="class-addresslookup">
<h2>Class AddressLookup<a class="headerlink" href="#class-addresslookup" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> class provides a mapping interface for determining
the address in a process where a SymtabAPI object is loaded. A single
dynamic library may load at different addresses in different processes.
The ‘address’ fields in a dynamic library’s symbol tables will contain
offsets rather than absolute addresses. These offsets can be added to
the library’s load address, which is computed at runtime, to determine
the absolute address where a symbol is loaded.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> class examines a process and finds its dynamic
libraries and executables and each one’s load address. This information
can be used to map between SymtabAPI objects and absolute addresses.
Each <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> instance is associated with one process. An
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object can be created to work with the currently
running process or a different process on the same system.</p>
<p>On the Linux platform the <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> class needs to read from the
process’ address space to determine its shared objects and load
addresses. By default, <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> will attach to another process
using a debugger interface to read the necessary information, or simply
use <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> if reading from the current process. The default behavior
can be changed by implementing a new ProcessReader class and passing an
instance of it to the create<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> factor constructors. The
ProcessReader class is discussed in more detail in Section
<a class="reference external" href="#subsec:ProcessReader">9.2</a>.</p>
<p>When an <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object is created for a running process it
takes a snapshot of the process’ currently loaded libraries and their
load addresses. This snapshot is used to answer queries into the
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object, and is not automatically updated when the
process loads or unloads libraries. The refresh function can be used to
updated an <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object’s view of its process.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">AddressLookup</span><span class="w"> </span><span class="o">*</span><span class="n">createAddressLookup</span><span class="p">(</span><span class="n">ProcessReader</span><span class="w"> </span><span class="o">*</span><span class="n">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory constructor creates a new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object
associated with the process that called this function. The returned
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object should be cleaned with the delete operator when
it is no longer needed. If the reader parameter is non-NULL on Linux
then the new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object will use reader to read from the
target process. This function returns the new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object
on success and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">AddressLookup</span><span class="w"> </span><span class="o">*</span><span class="n">createAddressLookup</span><span class="p">(</span><span class="n">PID</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">ProcessReader</span><span class="w"> </span><span class="o">*</span><span class="n">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory constructor creates a new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object
associated with the process referred to by <code class="docutils literal notranslate"><span class="pre">pid</span></code>. The returned
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object should be cleaned with the delete operator when
it is no longer needed. If the <code class="docutils literal notranslate"><span class="pre">reader</span></code> parameter is non-NULL on Linux
then the new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object will use it to read from the
target process. This function returns the new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object
on success and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="n">codeAddr</span><span class="p">;</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="n">dataAddr</span><span class="p">;</span><span class="w"> </span><span class="n">LoadedLibrary</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">AddressLookup</span><span class="w"> </span><span class="o">*</span><span class="n">createAddressLookup</span><span class="p">(</span><span class="k">const</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LoadedLibrary</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ll</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This factory constructor creates a new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> associated with
a previously collected list of libraries from a process. The list of
libraries can initially be collected with the <code class="docutils literal notranslate"><span class="pre">getLoadAddresses</span></code>
function. The list can then be used with this function to re-create the
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object, even if the original process no longer exists.
This can be useful for off-line address lookups, where only the load
addresses are collected while the process exists and then all address
translation is done after the process has terminated. This function
returns the new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object on success and <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on
error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getLoadAddresses</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LoadedLibrary</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ll</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function returns a vector of LoadedLibrary objects that can be used
by the <code class="docutils literal notranslate"><span class="pre">createAddressLookup(const</span> <span class="pre">std::vector&lt;LoadedLibrary&gt;</span> <span class="pre">&amp;ll)</span></code>
function to create a new <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object. This function is
usually used as part of an off-line address lookup mechanism. This
function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">refresh</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>When a <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object is initially created it takes a snapshot
of the libraries currently loaded in a process, which is then used to
answer queries into this API. As the process runs more libraries may be
loaded and unloaded, and this snapshot may become out of date. An
<code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code>’s view of a process can be updated by calling this
function, which causes it to examine the process for loaded and unloaded
objects and update its data structures accordingly. This function
returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAddress</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="n">sym</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given a <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object, <code class="docutils literal notranslate"><span class="pre">tab</span></code>, and a symbol, <code class="docutils literal notranslate"><span class="pre">sym</span></code>, this function
returns the address, <code class="docutils literal notranslate"><span class="pre">addr</span></code>, where the symbol can be found in the
process associated with this <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code>. This function returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> if it was able to successfully lookup the address of <code class="docutils literal notranslate"><span class="pre">sym</span></code>
and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAddress</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given a <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object, <code class="docutils literal notranslate"><span class="pre">tab</span></code>, and an offset into that object,
<code class="docutils literal notranslate"><span class="pre">off</span></code>, this function returns the address, <code class="docutils literal notranslate"><span class="pre">addr</span></code>, of that location
in the process associated with this <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code>. This function
returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it was able to successfully lookup the address of
sym and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getSymbol</span><span class="p">(</span><span class="n">Address</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">close</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given an address, <code class="docutils literal notranslate"><span class="pre">addr</span></code>, this function returns the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object,
<code class="docutils literal notranslate"><span class="pre">tab</span></code>, and <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>, <code class="docutils literal notranslate"><span class="pre">sym</span></code>, that reside at that address. If the
close parameter is <code class="docutils literal notranslate"><span class="pre">true</span></code> then <code class="docutils literal notranslate"><span class="pre">getSymbol</span></code> will return the nearest
symbol that comes before <code class="docutils literal notranslate"><span class="pre">addr</span></code>; this can be useful when looking up
the function that resides at an address. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
if it was able to find a symbol and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getOffset</span><span class="p">(</span><span class="n">Address</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">Symtab</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">off</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given an address, <code class="docutils literal notranslate"><span class="pre">addr</span></code>, this function returns the <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object,
<code class="docutils literal notranslate"><span class="pre">tab</span></code>, and an offset into <code class="docutils literal notranslate"><span class="pre">tab</span></code>, <code class="docutils literal notranslate"><span class="pre">off</span></code>, that reside at that
address. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getOffset</span><span class="p">(</span><span class="n">Address</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">LoadedLibrary</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lib</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">off</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>As above, but returns a <code class="docutils literal notranslate"><span class="pre">LoadedLibrary</span></code> data structure instead of a
Symtab.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getAllSymtabs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tabs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This function returns all <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> objects that are contained in the
process represented by this <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> object. This will include
the process’s executable and all shared objects loaded by this process.
This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getLoadAddress</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">sym</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">load_address</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given a <code class="docutils literal notranslate"><span class="pre">Symtab</span></code> object, <code class="docutils literal notranslate"><span class="pre">sym</span></code>, that resides in the process
associated with this <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code>, this function returns
<code class="docutils literal notranslate"><span class="pre">sym</span></code>’s load address. On systems where an object can have one load
address for its code and one for its data, this function will return the
code’s load address. Use <code class="docutils literal notranslate"><span class="pre">getDataLoadAddress</span></code> to get the data load
address. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">getDataLoadAddress</span><span class="p">(</span><span class="n">Symtab</span><span class="w"> </span><span class="o">*</span><span class="n">sym</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">load_addr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Given a Symtab object, <code class="docutils literal notranslate"><span class="pre">sym</span></code>, this function returns the load address
of its data section. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<div class="section" id="class-processreader">
<span id="subsec-processreader"></span><h2>Class ProcessReader<a class="headerlink" href="#class-processreader" title="Permalink to this headline"></a></h2>
<p>The implementation of the <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code> on Linux requires it to be
able to read from the target process’s address space. By default,
reading from another process on the same system this is done through the
operating system debugger interface. A user can provide their own
process reading mechanism by implementing a child of the
<code class="docutils literal notranslate"><span class="pre">ProcessReader</span></code> class and passing it to the <code class="docutils literal notranslate"><span class="pre">AddressLookup</span></code>
constructors. The API described in this section is an interface that a
user can implement. With the exception of the <code class="docutils literal notranslate"><span class="pre">ProcessReader</span></code>
constructor, these functions should not be called by user code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ProcessReader</span></code> is defined, but not used, on non-Linux systems.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ProcessReader</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>This constructor for a <code class="docutils literal notranslate"><span class="pre">ProcessReader</span></code> should be called by any child
class constructor.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ReadMem</span><span class="p">(</span><span class="n">Address</span><span class="w"> </span><span class="n">traced</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">inSelf</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>This function should read <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from the address at <code class="docutils literal notranslate"><span class="pre">traced</span></code>
into the buffer pointed to by <code class="docutils literal notranslate"><span class="pre">inSelf</span></code>. This function must return
<code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code> on error.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">GetReg</span><span class="p">(</span><span class="n">MachRegister</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">MachRegisterVal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>This function reads from the register specified by <code class="docutils literal notranslate"><span class="pre">reg</span></code> and places
the result in <code class="docutils literal notranslate"><span class="pre">val</span></code>. It must return <code class="docutils literal notranslate"><span class="pre">true</span></code> on success and <code class="docutils literal notranslate"><span class="pre">false</span></code>
on failure.</p>
</div>
</div>
<div class="section" id="building-symtabapi">
<h1>Building SymtabAPI<a class="headerlink" href="#building-symtabapi" title="Permalink to this headline"></a></h1>
<p>This appendix describes how to build SymtabAPI from source code, which
can be downloaded from <a class="reference external" href="http://www.paradyn.org">http://www.paradyn.org</a> or <a class="reference external" href="http://www.dyninst.org">http://www.dyninst.org</a>.</p>
<div class="section" id="building-on-unix">
<h2>Building on Unix<a class="headerlink" href="#building-on-unix" title="Permalink to this headline"></a></h2>
<p>Building SymtabAPI on UNIX platforms is a four step process that
involves: unpacking the SymtabAPI source, installing any SymtabAPI
dependencies, configuring paths in make.config.local, and running the
build.</p>
<p>SymtabAPI’s source code is packaged in a tar.gz format. If your
SymtabAPI source tarball is called <code class="docutils literal notranslate"><span class="pre">symtab_src_1.0.tar.gz</span></code>, then you
could extract it with the command
<code class="docutils literal notranslate"><span class="pre">gunzip</span> <span class="pre">symtab_src_1.0.tar.gz;</span> <span class="pre">tar</span> <span class="pre">-xvf</span> <span class="pre">symtab_src_1.0.tar</span></code>. This will
create two directories: core and scripts.</p>
<p>SymtabAPI has several dependencies, depending on what platform you are
using, which must be installed before SymtabAPI can be built. Note that
for most of these packages Symtab needs to be able to access the
package’s include files, which means that development versions are
required. If a version number is listed for a packaged, then there are
known bugs that may affect Symtab with earlier versions of the package.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Linux/x86</td>
<td>libdwarf-200120327</td>
</tr>
<tr class="row-even"><td></td>
<td>libelf</td>
</tr>
<tr class="row-odd"><td>Linux/x86-64</td>
<td>libdwarf-200120327</td>
</tr>
<tr class="row-even"><td></td>
<td>libelf</td>
</tr>
<tr class="row-odd"><td>Windows/x86</td>
<td>&lt;none&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>At the time of this writing the Linux packages could be found at:</p>
<ul class="simple">
<li>libdwarf - <a class="reference external" href="http://reality.sgiweb.org/davea/dwarf.html">http://reality.sgiweb.org/davea/dwarf.html</a></li>
<li>libelf - <a class="reference external" href="http://www.mr511.de/software/english.html">http://www.mr511.de/software/english.html</a></li>
</ul>
<p>Once the dependencies for SymtabAPI have been installed, SymtabAPI must
be configured to know where to find these packages. This is done through
SymtabAPI’s <code class="docutils literal notranslate"><span class="pre">core/make.config.local</span></code> file. This file must be written
in GNU Makefile syntax and must specify directories for each dependency.
Specifically, LIBDWARFDIR, LIBELFDIR and LIBXML2DIR variables must be
set. LIBDWARFDIR should be set to the absolute path of libdwarf library
where <code class="docutils literal notranslate"><span class="pre">dwarf.h</span></code> and <code class="docutils literal notranslate"><span class="pre">libdw.h</span></code> files reside. LIBELFDIR should be set
to the absolute path where <code class="docutils literal notranslate"><span class="pre">libelf.a</span></code> and <code class="docutils literal notranslate"><span class="pre">libelf.so</span></code> files are
located. Finally, LIBXML2DIR to the absolute path where libxml2 is
located.</p>
<p>The next thing is to set DYNINST_ROOT, PLATFORM, and LD_LIBRARY_PATH
environment variables. DYNINST_ROOT should be set to the path of the
directory that contains core and scripts subdirectories.</p>
<p>PLATFORM should be set to one of the following values depending upon
what operating system you are running on:</p>
<div class="description container">
<p>i386-unknown-linux2.4Linux 2.4/2.6 on an Intel x86 processor</p>
<p>x86_64-unknown-linux2.4Linux 2.4/2.6 on an AMD-64 processor</p>
</div>
<p>LD_LIBRARY_PATH variable should be set in a way that it includes
libdwarf home directory/lib and $DYNINST_ROOT/$PLATFORM/lib directories.</p>
<p>Once <code class="docutils literal notranslate"><span class="pre">make.config.local</span></code> is set you are ready to build SymtabAPI.
Change to the core directory and execute the command make SymtabAPI.
This will build the SymtabAPI library. Successfully built binaries will
be stored in a directory named after your platform at the same level as
the core directory.</p>
</div>
<div class="section" id="building-on-windows">
<h2>Building on Windows<a class="headerlink" href="#building-on-windows" title="Permalink to this headline"></a></h2>
<p>SymtabAPI for Windows is built with Microsoft Visual Studio 2003 project
and solution files. Building SymtabAPI for Windows is similar to UNIX in
that it is a four step process: unpack the SymtabAPI source code,
install SymtabAPI’s package dependencies, configure Visual Studio to use
the dependencies, and run the build system.</p>
<p>SymtabAPI’s source code is distributed as part of a tar.gz package. Most
popular unzipping programs are capable of handling this format.
Extracting the Symtab tarball results in two directories: core and
scripts.</p>
<p>Symtab for Windows depends on Microsoft’s Debugging Tools for Windows,
which could be found at
<a class="reference external" href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx">http://www.microsoft.com/whdc/devtools/debugging/default.mspx</a> at the
time of this writing. Download these tools and install them at an
appropriate location. Make sure to do a custom install and install the
SDK, which is not always installed by default. For the rest of this
section, we will assume that the Debugging Tools are installed at
<code class="docutils literal notranslate"><span class="pre">C:\</span> <span class="pre">Program</span> <span class="pre">Files\Debugging</span> <span class="pre">Tools</span> <span class="pre">for</span> <span class="pre">Windows</span></code>. If this is not the
case, then adjust the following instruction appropriately.</p>
<p>Once the Debugging Tools are installed, Visual Studio must be configured
to use them. We need to add the Debugging Tools include and library
directories to Visual Studios search paths. In Visual Studio 2003 select
<code class="docutils literal notranslate"><span class="pre">Options...</span></code> from the tools menu. Next select Projects and VC++
Directories from the pane on the left. You should see a list of
directories that are sorted into categories such as ‘Executable files’,
‘Include files’, etc. The current category can be changed with a drop
down box in the upper right hand side of the Dialog.</p>
<div class="line-block">
<div class="line">First, change to the ‘Library files’ category, and add an entry that
points to</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Debugging</span> <span class="pre">Tools</span> <span class="pre">for</span> <span class="pre">Windows\sdk\lib\i386</span></code>. Make
sure that this entry is above Visual Studio’s default search paths.</div>
</div>
<p>Next, Change to the ‘Include files’ category and make a new entry in the
list that points to
<code class="docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Debugging</span> <span class="pre">Tools</span> <span class="pre">for</span> <span class="pre">Windows\sdk\inc</span></code>. Also make sure
that this entry is above Visual Studio’s default search paths. Some
users have had a problem where Visual Studio cannot find the
<code class="docutils literal notranslate"><span class="pre">cvconst.h</span></code> file. You may need to add the directory containing this
file to the include search path. We have seen it installed at
<code class="docutils literal notranslate"><span class="pre">$(VCInstallDir)\</span> <span class="pre">..\Visual</span> <span class="pre">Studio</span> <span class="pre">SDKs\DIA</span> <span class="pre">SDK\include</span></code>, although you
may need to search for it. You also need to add the libxml2 include path
depending on the where the libxml2 is installed on the system.</p>
<p>Once you have installed and configured the Debugging Tools for Windows
you are ready to build Symtab. First, you need to create the directories
where Dyninst will install its completed build. From the core directory
you need to create the directories <code class="docutils literal notranslate"><span class="pre">..\i386-unknown-nt4.0\bin</span></code> and
<code class="docutils literal notranslate"><span class="pre">..\i386-unknown-nt4.0\lib</span></code>. Next open the solution file
core/SymtabAPI.sln with Visual Studio. You can then build SymtabAPI by
select ‘Build Solution’ from the build menu. This will build the
SymtabAPI library.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../stackwalk/index.html" class="btn btn-neutral float-left" title="Stackwalk Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>