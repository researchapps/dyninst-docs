<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference - Symbol Table Interface &mdash; Dyninst 12.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx-argparse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Dyninst
          </a>
              <div class="version">
                12.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">The Dataflow API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataflowAPI/index.html#api-reference">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">dynC API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html">DynC API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#dync-language-description">DynC Language Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dynC_API/index.html#the-dyninst-domain">The Dyninst Domain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Instruction API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-modules-and-abstractions">InstructionAPI Modules and Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructionAPI/index.html#instructionapi-class-reference">InstructionAPI Class Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parse API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#the-parsing-api">The Parsing API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#extending-parseapi">Extending ParseAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parseAPI/index.html#defensive-mode-parsing">Defensive Mode Parsing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Patch API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#examples">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#public-api-reference">Public API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#modification-api-reference">Modification API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#plugin-api-reference">Plugin API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../patchAPI/index.html#patchapi-for-dyninst-programmers">PatchAPI for Dyninst Programmers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stackwalk</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stackwalk/index.html#callback-interface-default-implementations">Callback Interface Default Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Symtab API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#abstractions">Abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#simple-examples">Simple Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#definitions-and-basic-types">Definitions and Basic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#namespace-symtabapi">Namespace SymtabAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#api-reference-symbol-table-interface">API Reference - Symbol Table Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#api-reference-line-number-interface">API Reference - Line Number Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#api-reference-type-interface">API Reference - Type Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#api-reference-dynamic-components">API Reference - Dynamic Components</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Dyninst</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference - Symbol Table Interface</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/symtabAPI/6-SymtabAPI.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="api-reference-symbol-table-interface">
<span id="sec-symtabapi"></span><h1>API Reference - Symbol Table Interface<a class="headerlink" href="#api-reference-symbol-table-interface" title="Permalink to this headline"></a></h1>
<p>This section describes the symbol table interface for the SymtabAPI
library. Currently this interface has the following capabilities:</p>
<ul class="simple">
<li>Parsing the symbols in a binary, either on disk or in memory</li>
<li>Querying for symbols</li>
<li>Updating existing symbol information</li>
<li>Adding new symbols</li>
<li>Exporting symbols in standard formats</li>
<li>Accessing relocation and exception information</li>
<li>Accessing and modifying header information</li>
</ul>
<p>The symbol table information is represented by the Symtab, Symbol,
Archive, and Region classes. Module, Function, and Variable provide
abstractions that support common use patterns. Finally, LocalVar
represents function-local variables and parameters.</p>
<div class="section" id="class-symtab">
<h2>Class Symtab<a class="headerlink" href="#class-symtab" title="Permalink to this headline"></a></h2>
<p>The class represents an object file either on-disk or in-memory. This
class is responsible for the parsing of the file information and holding
the data that can be accessed through look up functions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>std::string</td>
<td>Full path to the opened file or
provided name for the memory image.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>std::string</td>
<td>File name without path.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>std::string</td>
<td>For archive (.a) files, returns the
object file (.o) this Symtab
represents.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>unsigned</td>
<td>Number of regions.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>unsigned</td>
<td>Total number of symbols in both the
static and dynamic tables.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>char *</td>
<td>Pointer to memory image for the
Symtab; not valid for disk files.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Offset</td>
<td>Offset of the first code segment from
the start of the binary.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>Offset</td>
<td>Offset of the first data segment from
the start of the binary.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Offset</td>
<td>Size of the primary code-containing
region, typically .text.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>Offset</td>
<td>Size of the primary data-containing
region, typically .data.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>bool</td>
<td>True if the binary was compiled
statically.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>bool</td>
<td>True if the file is an executable.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>bool</td>
<td>True if the file is a shared library.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>bool</td>
<td>True if the file is can only be an
executable, false otherwise including
files that are both exeutables and
shared libraries. Typically files
that are both executables and shared
libraries are primarily used as
libraries, if you need to determine
specifics use the methods and .</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>bool</td>
<td>True if the file was stripped of
symbol table information.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>unsigned</td>
<td>Size (in bytes) of a pointer value in
the Symtab; 4 for 32-bit binaries and
8 for 64-bit binaries.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Architecture</td>
<td>Representation of the system
architecture for the binary.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>Offset</td>
<td>The suggested load offset of the
file; typically 0 for shared
libraries.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Offset</td>
<td>The entry point (where execution
begins) of the binary.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>Offset</td>
<td>(Windows only) the OS-specified base
offset of the file.</td>
</tr>
</tbody>
</table>
<div class="apient container">
ObjectType getObjectType() const</div>
<div class="apient container">
bool isExecutable() bool isSharedLibrary() bool isExec()</div>
<div class="section" id="file-opening-parsing">
<h3>File opening/parsing<a class="headerlink" href="#file-opening-parsing" title="Permalink to this headline"></a></h3>
<div class="apient container">
static bool openFile(Symtab *&amp;obj, string filename)</div>
<div class="apient container">
static bool openFile(Symtab *&amp;obj, char *mem_image, size_t size,
std::string name)</div>
<div class="apient container">
static Symtab *findOpenSymtab(string name)</div>
</div>
<div class="section" id="module-lookup">
<h3>Module lookup<a class="headerlink" href="#module-lookup" title="Permalink to this headline"></a></h3>
<div class="apient container">
Module *getDefaultModule()</div>
<div class="apient container">
bool findModuleByName(Module *&amp;ret, const string name)</div>
<div class="apient container">
bool findModuleByOffset(Module *&amp;ret, Offset offset)</div>
<div class="apient container">
bool getAllModules(vector&lt;module *&gt; &amp;ret)</div>
</div>
<div class="section" id="function-variable-and-symbol-lookup">
<h3>Function, Variable, and Symbol lookup<a class="headerlink" href="#function-variable-and-symbol-lookup" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool findFuncByEntryOffset(Function *&amp;ret, const Offset offset)</div>
<div class="apient container">
bool findFunctionsByName(std::vector&lt;Function *&gt; &amp;ret, const
std::string name, NameType nameType = anyName, bool isRegex = false,
bool checkCase = true)</div>
<div class="apient container">
bool getContainingFunction(Offset offset, Function *&amp;ret)</div>
<div class="apient container">
bool getAllFunctions(vector&lt;Function *&gt; &amp;ret)</div>
<div class="apient container">
bool findVariablesByOffset(std::vector&lt;Variable *&gt; &amp;ret, const
Offset offset)</div>
<div class="apient container">
bool findVariablesByName(std::vector&lt;Variable *&gt; &amp;ret, const
std::string name, NameType nameType = anyName, bool isRegex = false,
bool checkCase = true)</div>
<div class="apient container">
bool getAllVariables(vector&lt;Variable *&gt; &amp;ret)</div>
<div class="apient container">
bool findSymbol(vector &lt;Symbol *&gt; &amp;ret, const string name,
Symbol::SymbolType sType, NameType nameType = anyName, bool isRegex =
false, bool checkCase = false)</div>
<div class="apient container">
const vector&lt;Symbol *&gt; *findSymbolByOffset(Offset offset)</div>
<div class="apient container">
bool getAllSymbols(vector&lt;Symbol *&gt; &amp;ret)</div>
<div class="apient container">
bool getAllSymbolsByType(vector&lt;Symbol *&gt; &amp;ret, Symbol::SymbolType
sType)</div>
<div class="apient container">
bool getAllUndefinedSymbols(std::vector&lt;Symbol *&gt; &amp;ret)</div>
</div>
<div class="section" id="region-lookup">
<h3>Region lookup<a class="headerlink" href="#region-lookup" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool getCodeRegions(std::vector&lt;Region *&gt;&amp;ret)</div>
<div class="apient container">
bool getDataRegions(std::vector&lt;Region *&gt;&amp;ret)</div>
<div class="apient container">
bool getMappedRegions(std::vector&lt;Region *&gt;&amp;ret)</div>
<div class="apient container">
bool getAllRegions(std::vector&lt;Region *&gt;&amp;ret)</div>
<div class="apient container">
bool getAllNewRegions(std::vector&lt;Region *&gt;&amp;ret)</div>
<div class="apient container">
bool findRegion(Region *&amp;reg, string sname)</div>
<div class="apient container">
bool findRegion(Region *&amp;reg, const Offset addr, const unsigned long
size)</div>
<div class="apient container">
bool findRegionByEntry(Region *&amp;reg, const Offset soff)</div>
<div class="apient container">
Region *findEnclosingRegion(const Offset offset)</div>
</div>
<div class="section" id="insertion-and-modification">
<h3>Insertion and modification<a class="headerlink" href="#insertion-and-modification" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool emit(string file)</div>
<div class="apient container">
bool addLibraryPrereq(string lib)</div>
<div class="apient container">
Function *createFunction(std::string name, Offset offset, size_t
size, Module *mod = NULL)</div>
<div class="apient container">
Variable *createVariable(std::string name, Offset offset, size_t
size, Module *mod = NULL)</div>
<div class="apient container">
bool addSymbol(Symbol *newsym)</div>
<div class="apient container">
bool addSymbol(Symbol *newsym, Symbol *referringSymbol)</div>
<div class="apient container">
bool deleteFunction(Function *func)</div>
<div class="apient container">
bool deleteVariable(Variable *var)</div>
<div class="apient container">
bool deleteSymbol(Symbol *sym)</div>
<div class="apient container">
bool addRegion(Offset vaddr, void *data, unsigned int dataSize,
std::string name, Region::RegionType <a href="#id3"><span class="problematic" id="id4">rType_</span></a>, bool loadable = false,
unsigned long memAlign = sizeof(unsigned), bool tls = false)</div>
<div class="apient container">
Offset getFreeOffset(unsigned size)</div>
<div class="apient container">
bool addRegion(Region *newreg);</div>
</div>
<div class="section" id="catch-and-exception-block-lookup">
<h3>Catch and Exception block lookup<a class="headerlink" href="#catch-and-exception-block-lookup" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool getAllExceptions(vector&lt;ExceptionBlock *&gt; &amp;exceptions)</div>
<div class="apient container">
bool findException(ExceptionBlock &amp;excp, Offset addr)</div>
<div class="apient container">
bool findCatchBlock(ExceptionBlock &amp;excp, Offset addr, unsigned size
= 0)</div>
</div>
<div class="section" id="symtab-information">
<h3>Symtab information<a class="headerlink" href="#symtab-information" title="Permalink to this headline"></a></h3>
<div class="apient container">
typedef enum obj_Unknown, obj_SharedLib, obj_Executable,
obj_RelocatableFile, ObjectType;</div>
<div class="apient container">
bool isCode(const Offset where) const</div>
<div class="apient container">
bool isData(const Offset where) const</div>
<div class="apient container">
bool isValidOffset(const Offset where) const</div>
</div>
<div class="section" id="line-number-information">
<h3>Line number information<a class="headerlink" href="#line-number-information" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool getAddressRanges(vector&lt;pair&lt;Offset, Offset&gt; &gt; &amp; ranges, string
lineSource, unsigned int LineNo)</div>
<div class="apient container">
bool getSourceLines(vector&lt;LineNoTuple&gt; &amp;lines, Offset
addressInRange)</div>
<div class="apient container">
bool addLine(string lineSource, unsigned int lineNo, unsigned int
lineOffset, Offset lowInclusiveAddr, Offset highExclusiveAddr)</div>
<div class="apient container">
bool addAddressRange(Offset lowInclusiveAddr, Offset
highExclusiveAddr, string lineSource, unsigned int lineNo, unsigned
int lineOffset = 0);</div>
</div>
<div class="section" id="type-information">
<h3>Type information<a class="headerlink" href="#type-information" title="Permalink to this headline"></a></h3>
<div class="apient container">
void parseTypesNow()</div>
<div class="apient container">
bool findType(Type *&amp;type, string name)</div>
<div class="apient container">
bool addType(Type * type)</div>
<div class="apient container">
static std::vector&lt;Type *&gt; * getAllstdTypes()</div>
<div class="apient container">
static std::vector&lt;Type *&gt; * getAllbuiltInTypes()</div>
<div class="apient container">
bool findLocalVariable(vector&lt;localVar *&gt; &amp;vars, string name)</div>
<div class="apient container">
bool findVariableType(Type *&amp;type, std::string name)</div>
<div class="apient container">
typedef enum … SymtabError</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymtabError enum</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Obj_Parsing</td>
<td>An error occurred during object
parsing(internal error).</td>
</tr>
<tr class="row-odd"><td>Syms_To_Functions</td>
<td>An error occurred in converting symbols
to functions(internal error).</td>
</tr>
<tr class="row-even"><td>Build_Function_Lists</td>
<td>An error occurred while building function
lists(internal error).</td>
</tr>
<tr class="row-odd"><td>No_Such_Function</td>
<td>No matching function exists with the
given inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Variable</td>
<td>No matching variable exists with the
given inputs.</td>
</tr>
<tr class="row-odd"><td>No_Such_Module</td>
<td>No matching module exists with the given
inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Symbol</td>
<td>No matching symbol exists with the given
inputs.</td>
</tr>
<tr class="row-odd"><td>No_Such_Region</td>
<td>No matching region exists with the given
inputs.</td>
</tr>
<tr class="row-even"><td>No_Such_Member</td>
<td>No matching member exists in the archive
with the given inputs.</td>
</tr>
<tr class="row-odd"><td>Not_A_File</td>
<td>Binary to be parsed may be an archive and
not a file.</td>
</tr>
<tr class="row-even"><td>Not_An_Archive</td>
<td>Binary to be parsed is not an archive.</td>
</tr>
<tr class="row-odd"><td>Duplicate_Symbol</td>
<td>Duplicate symbol found in symbol table.</td>
</tr>
<tr class="row-even"><td>Export_Error</td>
<td>Error occurred during export of modified
symbol table.</td>
</tr>
<tr class="row-odd"><td>Emit_Error</td>
<td>Error occurred during generation of
modified binary.</td>
</tr>
<tr class="row-even"><td>Invalid_Flags</td>
<td>Flags passed are invalid.</td>
</tr>
<tr class="row-odd"><td>Bad_Frame_Data</td>
<td>Stack walking DWARF information has bad
frame data.</td>
</tr>
<tr class="row-even"><td>No_Frame_Entry</td>
<td>No stack walking frame data found in
debug information for this location.</td>
</tr>
<tr class="row-odd"><td>Frame_Read_Error</td>
<td>Failed to read stack frame data.</td>
</tr>
<tr class="row-even"><td>Multiple_Region_Matches</td>
<td>Multiple regions match the provided data.</td>
</tr>
<tr class="row-odd"><td>No_Error</td>
<td>Previous operation did not result in
failure.</td>
</tr>
</tbody>
</table>
</div>
<div class="apient container">
static SymtabError getLastSymtabError()</div>
<div class="apient container">
static string printError(SymtabError serr)</div>
</div>
</div>
<div class="section" id="class-module">
<span id="module"></span><h2>Class Module<a class="headerlink" href="#class-module" title="Permalink to this headline"></a></h2>
<p>This class represents the concept of a single source file. Currently,
Modules are only identified for the executable file; each shared library
is made up of a single Module, ignoring any source file information that
may be present. We also create a single module, called , for each Symtab
that contains any symbols for which module information was unavailable.
This may be compiler template code, or files produced without module
information.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">supportedLanguages</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lang_Unknown</td>
<td>Unknown source language</td>
</tr>
<tr class="row-odd"><td>lang_Assembly</td>
<td>Raw assembly code</td>
</tr>
<tr class="row-even"><td>lang_C</td>
<td>C source code</td>
</tr>
<tr class="row-odd"><td>lang_CPlusPlus</td>
<td>C++ source code</td>
</tr>
<tr class="row-even"><td>lang_GnuCPlusPlus</td>
<td>C++ with GNU extensions</td>
</tr>
<tr class="row-odd"><td>lang_Fortran</td>
<td>Fortran source code</td>
</tr>
<tr class="row-even"><td>lang_Fortran_with_pretty_debug</td>
<td>Fortran with debug annotations</td>
</tr>
<tr class="row-odd"><td>lang_CMFortran</td>
<td>Fortran with CM extensions</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="30%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>isShared</td>
<td>bool</td>
<td>True if the module is for a
shared library, false for an
executable.</td>
</tr>
<tr class="row-odd"><td>fullName</td>
<td>std::string &amp;</td>
<td>Name, including path, of the
source file represented by the
module.</td>
</tr>
<tr class="row-even"><td>fileName</td>
<td>std::string &amp;</td>
<td>Name, not including path, of
the source file represented by
the module.</td>
</tr>
<tr class="row-odd"><td>language</td>
<td>supportedLanguages</td>
<td>The source language used by the
Module.</td>
</tr>
<tr class="row-even"><td>addr</td>
<td>Offset</td>
<td>Offset of the start of the
module, as reported by the
symbol table, assuming
contiguous modules.</td>
</tr>
<tr class="row-odd"><td>exec</td>
<td>Symtab *</td>
<td>Symtab object that contains the
module.</td>
</tr>
</tbody>
</table>
<div class="section" id="function-variable-symbol-lookup">
<h3>Function, Variable, Symbol lookup<a class="headerlink" href="#function-variable-symbol-lookup" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool findFunctionByEntryOffset(Function *&amp;ret, const Offset offset)</div>
<div class="apient container">
typedef enum mangledName, prettyName, typedName, anyName NameType;</div>
<div class="apient container">
bool findFunctionsByName(vector&lt;Function&gt; &amp;ret, const string name,
Symtab::NameType nameType = anyName, bool isRegex = false, bool
checkCase = true)</div>
<div class="apient container">
bool getAllFunctions(vector&lt;Function *&gt; &amp;ret)</div>
<div class="apient container">
bool findVariablesByOffset(std::vector&lt;Variable *&gt; &amp;ret, const
Offset offset)</div>
<div class="apient container">
bool findVariablesByName(vector&lt;Function&gt; &amp;ret, const string &amp;name,
Symtab::NameType nameType, bool isRegex = false, bool checkCase =
true)</div>
<div class="apient container">
bool getAllSymbols(vector&lt;Symbol *&gt; &amp;ret)</div>
<div class="apient container">
bool getAllSymbolsByType(vector&lt;Symbol *&gt; &amp;ret, Symbol::SymbolType
sType)</div>
</div>
<div class="section" id="line-number-information-1">
<span id="id1"></span><h3>Line number information<a class="headerlink" href="#line-number-information-1" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool getAddressRanges(vector&lt;pair&lt;unsigned long, unsigned long&gt; &gt; &amp;
ranges, string lineSource, unsigned int lineNo)</div>
<div class="apient container">
bool getSourceLines(vector&lt;Statement *&gt; &amp;lines, Offset
addressInRange)</div>
<div class="apient container">
LineInformation *getLineInformation() const</div>
<div class="apient container">
bool getStatements(std::vector&lt;Statement *&gt; &amp;statements)</div>
</div>
<div class="section" id="subsubsec-typeinfo">
<span id="id2"></span><h3>Type information<a class="headerlink" href="#subsubsec-typeinfo" title="Permalink to this headline"></a></h3>
<div class="apient container">
bool findType(Type * &amp;type, string name)</div>
<div class="apient container">
bool findLocalVariable(vector&lt;localVar *&gt; &amp;vars, string name)</div>
<div class="apient container">
bool findVariableType(Type *&amp;type, std::string name)</div>
</div>
</div>
<div class="section" id="class-functionbase">
<span id="functionbase"></span><h2>Class FunctionBase<a class="headerlink" href="#class-functionbase" title="Permalink to this headline"></a></h2>
<p>The class provides a common interface that can represent either a
regular function or an inlined function.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="26%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getModule</td>
<td>const Module *</td>
<td>Module this function belongs to.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>Size encoded in the symbol
table; may not be actual
function size.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>Region containing this function.</td>
</tr>
<tr class="row-odd"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing the return
type of the function.</td>
</tr>
<tr class="row-even"><td>getName</td>
<td>std::string</td>
<td>Returns primary name of the
function (first mangled name or
DWARF name)</td>
</tr>
</tbody>
</table>
<div class="apient container">
bool setModule (Module *module)</div>
<div class="apient container">
bool setSize (unsigned size)</div>
<div class="apient container">
bool setOffset (Offset offset)</div>
<div class="apient container">
bool addMangledName(string name, bool isPrimary)</div>
<div class="apient container">
bool addPrettyName(string name, bool isPrimary)</div>
<div class="apient container">
bool addTypedName(string name, bool isPrimary)</div>
<div class="apient container">
bool getLocalVariables(vector&lt;localVar *&gt; &amp;vars)</div>
<div class="apient container">
std::vector&lt;VariableLocation&gt; &amp;getFramePtr()</div>
<div class="apient container">
bool getParams(vector&lt;localVar *&gt; &amp;params)</div>
<div class="apient container">
bool findLocalVariable(vector&lt;localVar *&gt; &amp;vars, string name)</div>
<div class="apient container">
bool setReturnType(Type *type)</div>
<div class="apient container">
FunctionBase* getInlinedParent()</div>
<div class="apient container">
const InlineCollection&amp; getInlines()</div>
</div>
<div class="section" id="class-function">
<span id="function"></span><h2>Class Function<a class="headerlink" href="#class-function" title="Permalink to this headline"></a></h2>
<p>The class represents a collection of symbols that have the same address
and a type of . When appropriate, use this representation instead of the
underlying objects.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getModule</td>
<td>const Module *</td>
<td>Module this function
belongs to.</td>
</tr>
<tr class="row-odd"><td>getOffset</td>
<td>Offset</td>
<td>Offset in the file
associated with the
function.</td>
</tr>
<tr class="row-even"><td>getSize</td>
<td>unsigned</td>
<td>Size encoded in the
symbol table; may
not be actual
function size.</td>
</tr>
<tr class="row-odd"><td>mangled_names_begin</td>
<td>Aggregate::name_iter</td>
<td>Beginning of a range
of unique names of
symbols pointing to
this function.</td>
</tr>
<tr class="row-even"><td>mangled_names_end</td>
<td>Aggregate::name_iter</td>
<td>End of a range of
unique names of
symbols pointing to
this function.</td>
</tr>
<tr class="row-odd"><td>pretty_names_begin</td>
<td>Aggregate::name_iter</td>
<td>As above, but
prettified with the
demangler.</td>
</tr>
<tr class="row-even"><td>pretty_names_end</td>
<td>Aggregate::name_iter</td>
<td>As above, but
prettified with the
demangler.</td>
</tr>
<tr class="row-odd"><td>typed_names_begin</td>
<td>Aggregate::name_iter</td>
<td>As above, but
including full type
strings.</td>
</tr>
<tr class="row-even"><td>typed_names_end</td>
<td>Aggregate::name_iter</td>
<td>As above, but
including full type
strings.</td>
</tr>
<tr class="row-odd"><td>getRegion</td>
<td>Region *</td>
<td>Region containing
this function.</td>
</tr>
<tr class="row-even"><td>getReturnType</td>
<td>Type *</td>
<td>Type representing
the return type of
the function.</td>
</tr>
</tbody>
</table>
<div class="apient container">
bool getSymbols(vector&lt;Symbol *&gt; &amp;syms) const</div>
<div class="apient container">
bool setModule (Module *module)</div>
<div class="apient container">
bool setSize (unsigned size)</div>
<div class="apient container">
bool setOffset (Offset offset)</div>
<div class="apient container">
bool addMangledName(string name, bool isPrimary)</div>
<div class="apient container">
bool addPrettyName(string name, bool isPrimary)</div>
<div class="apient container">
bool addTypedName(string name, bool isPrimary)</div>
<div class="apient container">
bool getLocalVariables(vector&lt;localVar *&gt; &amp;vars)</div>
<div class="apient container">
std::vector&lt;VariableLocation&gt; &amp;getFramePtr()</div>
<div class="apient container">
bool getParams(vector&lt;localVar *&gt; &amp;params)</div>
<div class="apient container">
bool findLocalVariable(vector&lt;localVar *&gt; &amp;vars, string name)</div>
<div class="apient container">
bool setReturnType(Type *type)</div>
</div>
<div class="section" id="class-inlinedfunction">
<span id="inlinedfunction"></span><h2>Class InlinedFunction<a class="headerlink" href="#class-inlinedfunction" title="Permalink to this headline"></a></h2>
<p>The class represents an inlined function, as found in DWARF information.
Its interface is almost entirely inherited from .</p>
<div class="apient container">
std::pair&lt;std::string, Dyninst::Offset&gt; getCallsite()</div>
</div>
<div class="section" id="class-variable">
<h2>Class Variable<a class="headerlink" href="#class-variable" title="Permalink to this headline"></a></h2>
<p>The class represents a collection of symbols that have the same address
and represent data.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getOffset</td>
<td>Offset</td>
<td>Offset associated
with this variable.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>Size of this
variable in the
symbol table.</td>
</tr>
<tr class="row-even"><td>mangled_names_begin</td>
<td>Aggregate::name_iter</td>
<td>Beginning of a range
of unique names of
symbols pointing to
this variable.</td>
</tr>
<tr class="row-odd"><td>mangled_names_end</td>
<td>Aggregate::name_iter</td>
<td>End of a range of
unique names of
symbols pointing to
this variable.</td>
</tr>
<tr class="row-even"><td>getType</td>
<td>Type *</td>
<td>Type of this
variable, if known.</td>
</tr>
<tr class="row-odd"><td>getModule</td>
<td>const Module *</td>
<td>Module that contains
this variable.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>Region that contains
this variable.</td>
</tr>
</tbody>
</table>
<div class="apient container">
bool getSymbols(vector&lt;Symbol *&gt; &amp;syms) const</div>
<div class="apient container">
bool setModule (Module *module)</div>
<div class="apient container">
bool setSize (unsigned size)</div>
<div class="apient container">
bool setOffset (Offset offset)</div>
<div class="apient container">
bool addMangledName(string name, bool isPrimary)</div>
<div class="apient container">
bool addPrettyName(string name, bool isPrimary)</div>
<div class="apient container">
bool addTypedName(string name, bool isPrimary)</div>
<div class="apient container">
bool setType(Type *type)</div>
</div>
<div class="section" id="class-symbol">
<h2>Class Symbol<a class="headerlink" href="#class-symbol" title="Permalink to this headline"></a></h2>
<p>The class represents a symbol in the object file. This class holds the
symbol information such as the mangled, pretty and typed names, the
module in which it is present, type, linkage, offset and size.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymbolType</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ST_UNKNOWN</td>
<td>Unknown type</td>
</tr>
<tr class="row-odd"><td>ST_FUNCTION</td>
<td>Function or other executable code sequence</td>
</tr>
<tr class="row-even"><td>ST_OBJECT</td>
<td>Variable or other data object</td>
</tr>
<tr class="row-odd"><td>ST_MODULE</td>
<td>Source file declaration</td>
</tr>
<tr class="row-even"><td>ST_SETION</td>
<td>Region declaration</td>
</tr>
<tr class="row-odd"><td>ST_TLS</td>
<td>Thread-local storage declaration</td>
</tr>
<tr class="row-even"><td>ST_DELETED</td>
<td>Deleted symbol</td>
</tr>
<tr class="row-odd"><td>ST_NOTYPE</td>
<td>Miscellaneous symbol</td>
</tr>
</tbody>
</table>
</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SymbolLinkage</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SL_UNKNOWN</td>
<td>Unknown linkage</td>
</tr>
<tr class="row-odd"><td>SL_GLOBAL</td>
<td>Process-global symbol</td>
</tr>
<tr class="row-even"><td>SL_LOCAL</td>
<td>Process-local (e.g., static) symbol</td>
</tr>
<tr class="row-odd"><td>SL_WEAK</td>
<td>Alternate name for a function or variable</td>
</tr>
</tbody>
</table>
</div>
<p>The following two types are platform-specific:</p>
<div class="apient container">
typedef enum SV_UNKNOWN, SV_DEFAULT, SV_INTERNAL, SV_HIDDEN,
SV_PROTECTED SymbolVisibility;</div>
<div class="apient container">
typedef enum TAG_UNKNOWN, TAG_USER, TAG_LIBRARY, TAG_INTERNAL
SymbolTag;</div>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="27%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getMangledName</td>
<td>string</td>
<td>Raw name of the symbol in the
symbol table, including name
mangling.</td>
</tr>
<tr class="row-odd"><td>getPrettyName</td>
<td>string</td>
<td>Demangled name of the symbol
with parameters (for
functions) removed.</td>
</tr>
<tr class="row-even"><td>getTypedName</td>
<td>string</td>
<td>Demangled name of the symbol
including full function
parameters.</td>
</tr>
<tr class="row-odd"><td>getModule</td>
<td>Module *</td>
<td>The module, if any, that
contains the symbol.</td>
</tr>
<tr class="row-even"><td>getType</td>
<td>SymbolType</td>
<td>The symbol type (as defined
above) of the symbol.</td>
</tr>
<tr class="row-odd"><td>getLinkage</td>
<td>SymbolLinkage</td>
<td>The linkage (as defined
above) of the symbol.</td>
</tr>
<tr class="row-even"><td>getVisibility</td>
<td>SymbolVisibility</td>
<td>The visibility (as defined
above) of the symbol.</td>
</tr>
<tr class="row-odd"><td>tag</td>
<td>SymbolTag</td>
<td>The tag (as defined above) of
the symbol.</td>
</tr>
<tr class="row-even"><td>getOffset</td>
<td>Offset</td>
<td>The offset of the object the
symbols refers to.</td>
</tr>
<tr class="row-odd"><td>getSize</td>
<td>unsigned</td>
<td>The size of the object the
symbol refers to.</td>
</tr>
<tr class="row-even"><td>getRegion</td>
<td>Region *</td>
<td>The region containing the
symbol.</td>
</tr>
<tr class="row-odd"><td>getIndex</td>
<td>int</td>
<td>The index of the symbol
within the symbol table.</td>
</tr>
<tr class="row-even"><td>getStrIndex</td>
<td>int</td>
<td>The index of the symbol name
in the string table.</td>
</tr>
<tr class="row-odd"><td>isInDynSymtab</td>
<td>bool</td>
<td>If true, the symbol is
dynamic and can be used as
the target of an intermodule
reference. Implies isInSymtab
is false.</td>
</tr>
<tr class="row-even"><td>isInSymtab</td>
<td>bool</td>
<td>If true, the symbol is
static. Implies isInDynSymtab
is false.</td>
</tr>
<tr class="row-odd"><td>isAbsolute</td>
<td>bool</td>
<td>If true, the offset encoded
in the symbol is an absolute
value rather than an offset.</td>
</tr>
<tr class="row-even"><td>isFunction</td>
<td>bool</td>
<td>If true, the symbol refers to
a function.</td>
</tr>
<tr class="row-odd"><td>getFunction</td>
<td>Function *</td>
<td>The Function that contains
this symbol if such a
Function exists.</td>
</tr>
<tr class="row-even"><td>isVariable</td>
<td>bool</td>
<td>If true, the symbol refers to
a variable.</td>
</tr>
<tr class="row-odd"><td>getVariable</td>
<td>Variable *</td>
<td>The Variable that contains
this symbol if such a
Variable exists.</td>
</tr>
<tr class="row-even"><td>getSymtab</td>
<td>Symtab *</td>
<td>The Symtab that contains this
symbol.</td>
</tr>
<tr class="row-odd"><td>getPtrOffset</td>
<td>Offset</td>
<td>For binaries with an OPD
section, the offset in the
OPD that contains the
function pointer data
structure for this symbol.</td>
</tr>
<tr class="row-even"><td>getLocalTOC</td>
<td>Offset</td>
<td>For platforms with a TOC
register, the expected TOC
for the object referred to by
this symbol.</td>
</tr>
<tr class="row-odd"><td>isCommonStorage</td>
<td>bool</td>
<td>True if the symbol represents
a common section (Fortran).</td>
</tr>
</tbody>
</table>
<div class="apient container">
SYMTAB_EXPORT Symbol(const std::string&amp; name, SymbolType type,
SymbolLinkage linkage, SymbolVisibility visibility, Offset offset,
Module *module = NULL, Region *region = NULL, unsigned size = 0,
bool dyamic = false, bool absolute = false, int index = -1, int
strindex = -1, bool commonStorage = false)</div>
<div class="apient container">
bool getVersionFileName(std::string &amp;fileName)</div>
<div class="apient container">
bool getVersions(std::vector&lt;std::string&gt; *&amp;vers)</div>
<div class="apient container">
bool getVersionNum(unsigned &amp;verNum)</div>
<div class="section" id="symbol-modification">
<h3>Symbol modification<a class="headerlink" href="#symbol-modification" title="Permalink to this headline"></a></h3>
<p>Most elements of a can be modified using the functions below. Each
returns on success and otherwise.</p>
<div class="apient container">
bool setSize (unsigned size) bool setOffset (Offset newOffset) bool
setMangledName (string name) bool setType (SymbolType sType) bool
setModule (Module *module) bool setRegion (Region *region) bool
setDynamic (bool dyn) bool setAbsolute (bool absolute) bool
setCommonStorage (bool common) bool setFunction (Function *func)
bool setVariable (Variable *var) bool setIndex (int index) bool
setStrIndex (int index) bool setPtrOffset (Offset ptr) bool
setLocalTOC (Offset toc) bool setVersionNum (unsigned num) bool
setVersionFileName (std::string &amp;fileName) bool setVersions
(std::vector&lt;std::string&gt; &amp;vers)</div>
</div>
</div>
<div class="section" id="class-archive">
<span id="archive"></span><h2>Class Archive<a class="headerlink" href="#class-archive" title="Permalink to this headline"></a></h2>
<p>This is used only on ELF platforms. This class represents an archive.
This class has information of all the members in the archives.</p>
<div class="apient container">
static bool openArchive(Archive *&amp;img, string name)</div>
<div class="apient container">
static bool openArchive(Archive *&amp;img, char *mem_image, size_t
size)</div>
<div class="apient container">
bool getMember(Symtab *&amp;img, string member_name)</div>
<div class="apient container">
bool getMemberByOffset(Symtab *&amp;img, Offset memberOffset)</div>
<div class="apient container">
bool getAllMembers(vector &lt;Symtab *&gt; &amp;members)</div>
<div class="apient container">
bool isMemberInArchive(string member_name)</div>
<div class="apient container">
bool findMemberWithDefinition(Symtab *&amp;obj, string name)</div>
<div class="apient container">
static SymtabError getLastError()</div>
<div class="apient container">
static string printError(SymtabError serr)</div>
</div>
<div class="section" id="class-region">
<h2>Class Region<a class="headerlink" href="#class-region" title="Permalink to this headline"></a></h2>
<p>This class represents a contiguous range of code or data as encoded in
the object file. For ELF, regions represent ELF sections.</p>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">perm_t</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RP_R</td>
<td>Read-only data</td>
</tr>
<tr class="row-odd"><td>RP_RW</td>
<td>Read/write data</td>
</tr>
<tr class="row-even"><td>RP_RX</td>
<td>Read-only code</td>
</tr>
<tr class="row-odd"><td>RP_RWX</td>
<td>Read/write code</td>
</tr>
</tbody>
</table>
</div>
<div class="center container">
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">RegionType</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT_TEXT</td>
<td>Executable code</td>
</tr>
<tr class="row-odd"><td>RT_DATA</td>
<td>Read/write data</td>
</tr>
<tr class="row-even"><td>RT_TEXTDATA</td>
<td>Mix of code and data</td>
</tr>
<tr class="row-odd"><td>RT_SYMTAB</td>
<td>Static symbol table</td>
</tr>
<tr class="row-even"><td>RT_STRTAB</td>
<td>String table used by the symbol table</td>
</tr>
<tr class="row-odd"><td>RT_BSS</td>
<td>0-initialized memory</td>
</tr>
<tr class="row-even"><td>RT_SYMVERSIONS</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-odd"><td>RT_SYMVERDEF</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-even"><td>RT_SYMVERNEEDED</td>
<td>Versioning information for symbols</td>
</tr>
<tr class="row-odd"><td>RT_REL</td>
<td>Relocation section</td>
</tr>
<tr class="row-even"><td>RT_RELA</td>
<td>Relocation section</td>
</tr>
<tr class="row-odd"><td>RT_PLTREL</td>
<td>Relocation section for PLT (inter-library
references) entries</td>
</tr>
<tr class="row-even"><td>RT_PLTRELA</td>
<td>Relocation section for PLT (inter-library
references) entries</td>
</tr>
<tr class="row-odd"><td>RT_DYNAMIC</td>
<td>Decription of library dependencies</td>
</tr>
<tr class="row-even"><td>RT_HASH</td>
<td>Fast symbol lookup section</td>
</tr>
<tr class="row-odd"><td>RT_GNU_HASH</td>
<td>GNU-specific fast symbol lookup section</td>
</tr>
<tr class="row-even"><td>RT_OTHER</td>
<td>Miscellaneous information</td>
</tr>
</tbody>
</table>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="24%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getRegionNumber</td>
<td>unsigned</td>
<td>Index of the region in
the file, starting at
0.</td>
</tr>
<tr class="row-odd"><td>getRegionName</td>
<td>std::string</td>
<td>Name of the region
(e.g. .text, .data).</td>
</tr>
<tr class="row-even"><td>getPtrToRawData</td>
<td>void *</td>
<td>Read-only pointer to
the region’s raw data
buffer.</td>
</tr>
<tr class="row-odd"><td>getDiskOffset</td>
<td>Offset</td>
<td>Offset within the file
where the region
begins.</td>
</tr>
<tr class="row-even"><td>getDiskSize</td>
<td>unsigned long</td>
<td>Size of the region’s
data in the file.</td>
</tr>
<tr class="row-odd"><td>getMemOffset</td>
<td>Offset</td>
<td>Location where the
region will be loaded
into memory, modified
by the file’s base load
address.</td>
</tr>
<tr class="row-even"><td>getMemSize</td>
<td>unsigned long</td>
<td>Size of the region in
memory, including zero
padding.</td>
</tr>
<tr class="row-odd"><td>isBSS</td>
<td>bool</td>
<td>Type query for
uninitialized data
regions (zero disk
size, non-zero memory
size).</td>
</tr>
<tr class="row-even"><td>isText</td>
<td>bool</td>
<td>Type query for
executable code
regions.</td>
</tr>
<tr class="row-odd"><td>isData</td>
<td>bool</td>
<td>Type query for
initialized data
regions.</td>
</tr>
<tr class="row-even"><td>getRegionPermissions</td>
<td>perm_t</td>
<td>Permissions for the
region; perm_ t is
defined above.</td>
</tr>
<tr class="row-odd"><td>getRegionType</td>
<td>RegionType</td>
<td>Type of the region as
defined above.</td>
</tr>
<tr class="row-even"><td>isLoadable</td>
<td>bool</td>
<td>True if the region will
be loaded into memory
(e.g., code or data),
false otherwise (e.g.,
debug information).</td>
</tr>
<tr class="row-odd"><td>isDirty</td>
<td>bool</td>
<td>True if the region’s
raw data buffer has
been modified by the
user.</td>
</tr>
</tbody>
</table>
<div class="apient container">
static Region *createRegion(Offset diskOff, perm_t perms, RegionType
regType, unsigned long diskSize = 0, Offset memOff = 0, unsigned long
memSize = 0, std::string name = “”, char *rawDataPtr = NULL, bool
isLoadable = false, bool isTLS = false, unsigned long memAlign =
sizeof(unsigned))</div>
<div class="apient container">
bool isOffsetInRegion(const Offset &amp;offset) const</div>
<div class="apient container">
void setRegionNumber(unsigned index) const</div>
<div class="apient container">
bool setPtrToRawData(void *newPtr, unsigned long rawsize)</div>
<div class="apient container">
bool setRegionPermissions(perm_t newPerms)</div>
<div class="apient container">
bool setLoadable(bool isLoadable)</div>
<div class="apient container">
bool addRelocationEntry(Offset relocationAddr, Symbol *dynref,
unsigned long relType, Region::RegionType rtype = Region::RT_REL)</div>
<div class="apient container">
vector&lt;relocationEntry&gt; &amp;getRelocations()</div>
<div class="apient container">
bool addRelocationEntry(const relocationEntry&amp; rel)</div>
<div class="apient container">
bool patchData(Offset off, void *buf, unsigned size);</div>
<div class="section" id="removed">
<h3>REMOVED<a class="headerlink" href="#removed" title="Permalink to this headline"></a></h3>
<p>The following methods were removed since they were inconsistent and
dangerous to use.</p>
<div class="apient container">
Offset getRegionAddr() const</div>
<div class="apient container">
unsigned long getRegionSize() const</div>
</div>
</div>
<div class="section" id="relocation-information">
<h2>Relocation Information<a class="headerlink" href="#relocation-information" title="Permalink to this headline"></a></h2>
<p>This class represents object relocation information.</p>
<div class="apient container">
Offset target_addr() const</div>
<div class="apient container">
Offset rel_addr() const</div>
<div class="apient container">
Offset addend() const</div>
<div class="apient container">
const std::string name() const</div>
<div class="apient container">
Symbol *getDynSym() const</div>
<div class="apient container">
unsigned long getRelType() const</div>
</div>
<div class="section" id="class-exceptionblock">
<span id="exceptionblock"></span><h2>Class ExceptionBlock<a class="headerlink" href="#class-exceptionblock" title="Permalink to this headline"></a></h2>
<p>This class represents an exception block present in the object file.
This class gives all the information pertaining to that exception block.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>hasTry</td>
<td>bool</td>
<td>True if the exception block has a try block.</td>
</tr>
<tr class="row-odd"><td>tryStart</td>
<td>Offset</td>
<td>Start of the try block if it exists, else 0.</td>
</tr>
<tr class="row-even"><td>tryEnd</td>
<td>Offset</td>
<td>End of the try block if it exists, else 0.</td>
</tr>
<tr class="row-odd"><td>trySize</td>
<td>Offset</td>
<td>Size of the try block if it exists, else 0.</td>
</tr>
<tr class="row-even"><td>catchStart</td>
<td>Offset</td>
<td>Start of the catch block.</td>
</tr>
</tbody>
</table>
<div class="apient container">
bool contains(Offset addr) const</div>
</div>
<div class="section" id="class-localvar">
<span id="localvar"></span><h2>Class localVar<a class="headerlink" href="#class-localvar" title="Permalink to this headline"></a></h2>
<p>This represents a local variable or parameter of a function.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Return type</th>
<th class="head">Method description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getName</td>
<td>string &amp;</td>
<td>Name of the local variable or
parameter.</td>
</tr>
<tr class="row-odd"><td>getType</td>
<td>Type *</td>
<td>Type associated with the variable.</td>
</tr>
<tr class="row-even"><td>getFileName</td>
<td>string &amp;</td>
<td>File where the variable was declared,
if known.</td>
</tr>
<tr class="row-odd"><td>getLineNum</td>
<td>int</td>
<td>Line number where the variable was
declared, if known.</td>
</tr>
</tbody>
</table>
<div class="apient container">
vector&lt;VariableLocation&gt; &amp;getLocationLists()</div>
</div>
<div class="section" id="class-variablelocation">
<span id="variablelocation"></span><h2>Class VariableLocation<a class="headerlink" href="#class-variablelocation" title="Permalink to this headline"></a></h2>
<p>The class is an encoding of the location of a variable in memory or
registers.</p>
<div class="apient container">
<p>typedef enum storageUnset, storageAddr, storageReg, storageRegOffset
storageClass;</p>
<p>typedef enum storageRefUnset, storageRef, storageNoRef
storageRefClass;</p>
<p>struct VariableLocation storageClass stClass; storageRefClass
refClass; MachRegister mr_reg; long frameOffset; Address lowPC;
Address hiPC;</p>
</div>
<p>A is valid within the address range represented by and . If these are 0
and (Address) -1, respectively, the is always valid.</p>
<p>The location represented by the can be determined by the user as
follows:</p>
<ul>
<li><p class="first">stClass == storageAddr</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The frameOffset member contains the address of a pointer to the
variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The frameOffset member contains the address of the variable.</p>
</dd>
</dl>
</li>
<li><p class="first">stClass == storageReg</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The register named by mr_reg contains the address of the variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The register named by mr_reg member contains the variable.</p>
</dd>
</dl>
</li>
<li><p class="first">stClass == storageRegOffset</p>
<dl class="docutils">
<dt>refClass == storageRef</dt><dd><p>The address computed by adding frameOffset to the contents of
mr_reg contains a pointer to the variable.</p>
</dd>
<dt>refClass == storageNoRef</dt><dd><p>The address computed by adding frameOffset to the contents of
mr_reg contains the variable.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2022, Barton P. Miller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>